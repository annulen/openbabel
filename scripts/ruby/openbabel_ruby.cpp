/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 1.3.31
 * 
 * This file is not intended to be easily readable and contains a number of 
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG 
 * interface file instead. 
 * ----------------------------------------------------------------------------- */

#define SWIGRUBY

#ifdef __cplusplus
template<class T> class SwigValueWrapper {
    T *tt;
public:
    SwigValueWrapper() : tt(0) { }
    SwigValueWrapper(const SwigValueWrapper<T>& rhs) : tt(new T(*rhs.tt)) { }
    SwigValueWrapper(const T& t) : tt(new T(t)) { }
    ~SwigValueWrapper() { delete tt; } 
    SwigValueWrapper& operator=(const T& t) { delete tt; tt = new T(t); return *this; }
    operator T&() const { return *tt; }
    T *operator&() { return tt; }
private:
    SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
};
#endif

/* -----------------------------------------------------------------------------
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 * ----------------------------------------------------------------------------- */

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
# if defined(__SUNPRO_CC)
#   if (__SUNPRO_CC <= 0x560)
#     define SWIGTEMPLATEDISAMBIGUATOR template
#   else
#     define SWIGTEMPLATEDISAMBIGUATOR 
#   endif
# else
#   define SWIGTEMPLATEDISAMBIGUATOR 
# endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define SWIGUNUSED __attribute__ ((__unused__)) 
#   else
#     define SWIGUNUSED
#   endif
# elif defined(__ICC)
#   define SWIGUNUSED __attribute__ ((__unused__)) 
# else
#   define SWIGUNUSED 
# endif
#endif

#ifndef SWIGUNUSEDPARM
# ifdef __cplusplus
#   define SWIGUNUSEDPARM(p)
# else
#   define SWIGUNUSEDPARM(p) p SWIGUNUSED 
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods */
#if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
#  ifndef GCC_HASCLASSVISIBILITY
#    define GCC_HASCLASSVISIBILITY
#  endif
#endif

#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
#     define SWIGEXPORT __attribute__ ((visibility("default")))
#   else
#     define SWIGEXPORT
#   endif
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif 
#endif

/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
# define _CRT_SECURE_NO_DEPRECATE
#endif

/* -----------------------------------------------------------------------------
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 * ----------------------------------------------------------------------------- */

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
# if defined(__SUNPRO_CC)
#   if (__SUNPRO_CC <= 0x560)
#     define SWIGTEMPLATEDISAMBIGUATOR template
#   else
#     define SWIGTEMPLATEDISAMBIGUATOR 
#   endif
# else
#   define SWIGTEMPLATEDISAMBIGUATOR 
# endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define SWIGUNUSED __attribute__ ((__unused__)) 
#   else
#     define SWIGUNUSED
#   endif
# elif defined(__ICC)
#   define SWIGUNUSED __attribute__ ((__unused__)) 
# else
#   define SWIGUNUSED 
# endif
#endif

#ifndef SWIGUNUSEDPARM
# ifdef __cplusplus
#   define SWIGUNUSEDPARM(p)
# else
#   define SWIGUNUSEDPARM(p) p SWIGUNUSED 
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods */
#if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
#  ifndef GCC_HASCLASSVISIBILITY
#    define GCC_HASCLASSVISIBILITY
#  endif
#endif

#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
#     define SWIGEXPORT __attribute__ ((visibility("default")))
#   else
#     define SWIGEXPORT
#   endif
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif 
#endif

/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
# define _CRT_SECURE_NO_DEPRECATE
#endif

/* -----------------------------------------------------------------------------
 * swigrun.swg
 *
 * This file contains generic CAPI SWIG runtime support for pointer
 * type checking.
 * ----------------------------------------------------------------------------- */

/* This should only be incremented when either the layout of swig_type_info changes,
   or for whatever reason, the runtime changes incompatibly */
#define SWIG_RUNTIME_VERSION "3"

/* define SWIG_TYPE_TABLE_NAME as "SWIG_TYPE_TABLE" */
#ifdef SWIG_TYPE_TABLE
# define SWIG_QUOTE_STRING(x) #x
# define SWIG_EXPAND_AND_QUOTE_STRING(x) SWIG_QUOTE_STRING(x)
# define SWIG_TYPE_TABLE_NAME SWIG_EXPAND_AND_QUOTE_STRING(SWIG_TYPE_TABLE)
#else
# define SWIG_TYPE_TABLE_NAME
#endif

/*
  You can use the SWIGRUNTIME and SWIGRUNTIMEINLINE macros for
  creating a static or dynamic library from the swig runtime code.
  In 99.9% of the cases, swig just needs to declare them as 'static'.
  
  But only do this if is strictly necessary, ie, if you have problems
  with your compiler or so.
*/

#ifndef SWIGRUNTIME
# define SWIGRUNTIME SWIGINTERN
#endif

#ifndef SWIGRUNTIMEINLINE
# define SWIGRUNTIMEINLINE SWIGRUNTIME SWIGINLINE
#endif

/*  Generic buffer size */
#ifndef SWIG_BUFFER_SIZE
# define SWIG_BUFFER_SIZE 1024
#endif

/* Flags for pointer conversions */
#define SWIG_POINTER_DISOWN        0x1

/* Flags for new pointer objects */
#define SWIG_POINTER_OWN           0x1


/* 
   Flags/methods for returning states.
   
   The swig conversion methods, as ConvertPtr, return and integer 
   that tells if the conversion was successful or not. And if not,
   an error code can be returned (see swigerrors.swg for the codes).
   
   Use the following macros/flags to set or process the returning
   states.
   
   In old swig versions, you usually write code as:

     if (SWIG_ConvertPtr(obj,vptr,ty.flags) != -1) {
       // success code
     } else {
       //fail code
     }

   Now you can be more explicit as:

    int res = SWIG_ConvertPtr(obj,vptr,ty.flags);
    if (SWIG_IsOK(res)) {
      // success code
    } else {
      // fail code
    }

   that seems to be the same, but now you can also do

    Type *ptr;
    int res = SWIG_ConvertPtr(obj,(void **)(&ptr),ty.flags);
    if (SWIG_IsOK(res)) {
      // success code
      if (SWIG_IsNewObj(res) {
        ...
	delete *ptr;
      } else {
        ...
      }
    } else {
      // fail code
    }
    
   I.e., now SWIG_ConvertPtr can return new objects and you can
   identify the case and take care of the deallocation. Of course that
   requires also to SWIG_ConvertPtr to return new result values, as

      int SWIG_ConvertPtr(obj, ptr,...) {         
        if (<obj is ok>) {			       
          if (<need new object>) {		       
            *ptr = <ptr to new allocated object>; 
            return SWIG_NEWOBJ;		       
          } else {				       
            *ptr = <ptr to old object>;	       
            return SWIG_OLDOBJ;		       
          } 				       
        } else {				       
          return SWIG_BADOBJ;		       
        }					       
      }

   Of course, returning the plain '0(success)/-1(fail)' still works, but you can be
   more explicit by returning SWIG_BADOBJ, SWIG_ERROR or any of the
   swig errors code.

   Finally, if the SWIG_CASTRANK_MODE is enabled, the result code
   allows to return the 'cast rank', for example, if you have this

       int food(double)
       int fooi(int);

   and you call
 
      food(1)   // cast rank '1'  (1 -> 1.0)
      fooi(1)   // cast rank '0'

   just use the SWIG_AddCast()/SWIG_CheckState()


 */
#define SWIG_OK                    (0) 
#define SWIG_ERROR                 (-1)
#define SWIG_IsOK(r)               (r >= 0)
#define SWIG_ArgError(r)           ((r != SWIG_ERROR) ? r : SWIG_TypeError)  

/* The CastRankLimit says how many bits are used for the cast rank */
#define SWIG_CASTRANKLIMIT         (1 << 8)
/* The NewMask denotes the object was created (using new/malloc) */
#define SWIG_NEWOBJMASK            (SWIG_CASTRANKLIMIT  << 1)
/* The TmpMask is for in/out typemaps that use temporal objects */
#define SWIG_TMPOBJMASK            (SWIG_NEWOBJMASK << 1)
/* Simple returning values */
#define SWIG_BADOBJ                (SWIG_ERROR)
#define SWIG_OLDOBJ                (SWIG_OK)
#define SWIG_NEWOBJ                (SWIG_OK | SWIG_NEWOBJMASK)
#define SWIG_TMPOBJ                (SWIG_OK | SWIG_TMPOBJMASK)
/* Check, add and del mask methods */
#define SWIG_AddNewMask(r)         (SWIG_IsOK(r) ? (r | SWIG_NEWOBJMASK) : r)
#define SWIG_DelNewMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_NEWOBJMASK) : r)
#define SWIG_IsNewObj(r)           (SWIG_IsOK(r) && (r & SWIG_NEWOBJMASK))
#define SWIG_AddTmpMask(r)         (SWIG_IsOK(r) ? (r | SWIG_TMPOBJMASK) : r)
#define SWIG_DelTmpMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_TMPOBJMASK) : r)
#define SWIG_IsTmpObj(r)           (SWIG_IsOK(r) && (r & SWIG_TMPOBJMASK))


/* Cast-Rank Mode */
#if defined(SWIG_CASTRANK_MODE)
#  ifndef SWIG_TypeRank
#    define SWIG_TypeRank             unsigned long
#  endif
#  ifndef SWIG_MAXCASTRANK            /* Default cast allowed */
#    define SWIG_MAXCASTRANK          (2)
#  endif
#  define SWIG_CASTRANKMASK          ((SWIG_CASTRANKLIMIT) -1)
#  define SWIG_CastRank(r)           (r & SWIG_CASTRANKMASK)
SWIGINTERNINLINE int SWIG_AddCast(int r) { 
  return SWIG_IsOK(r) ? ((SWIG_CastRank(r) < SWIG_MAXCASTRANK) ? (r + 1) : SWIG_ERROR) : r;
}
SWIGINTERNINLINE int SWIG_CheckState(int r) { 
  return SWIG_IsOK(r) ? SWIG_CastRank(r) + 1 : 0; 
}
#else /* no cast-rank mode */
#  define SWIG_AddCast
#  define SWIG_CheckState(r) (SWIG_IsOK(r) ? 1 : 0)
#endif




#include <string.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef void *(*swig_converter_func)(void *);
typedef struct swig_type_info *(*swig_dycast_func)(void **);

/* Structure to store inforomation on one type */
typedef struct swig_type_info {
  const char             *name;			/* mangled name of this type */
  const char             *str;			/* human readable name of this type */
  swig_dycast_func        dcast;		/* dynamic cast function down a hierarchy */
  struct swig_cast_info  *cast;			/* linked list of types that can cast into this type */
  void                   *clientdata;		/* language specific type data */
  int                    owndata;		/* flag if the structure owns the clientdata */
} swig_type_info;

/* Structure to store a type and conversion function used for casting */
typedef struct swig_cast_info {
  swig_type_info         *type;			/* pointer to type that is equivalent to this type */
  swig_converter_func     converter;		/* function to cast the void pointers */
  struct swig_cast_info  *next;			/* pointer to next cast in linked list */
  struct swig_cast_info  *prev;			/* pointer to the previous cast */
} swig_cast_info;

/* Structure used to store module information
 * Each module generates one structure like this, and the runtime collects
 * all of these structures and stores them in a circularly linked list.*/
typedef struct swig_module_info {
  swig_type_info         **types;		/* Array of pointers to swig_type_info structures that are in this module */
  size_t                 size;		        /* Number of types in this module */
  struct swig_module_info *next;		/* Pointer to next element in circularly linked list */
  swig_type_info         **type_initial;	/* Array of initially generated type structures */
  swig_cast_info         **cast_initial;	/* Array of initially generated casting structures */
  void                    *clientdata;		/* Language specific module data */
} swig_module_info;

/* 
  Compare two type names skipping the space characters, therefore
  "char*" == "char *" and "Class<int>" == "Class<int >", etc.

  Return 0 when the two name types are equivalent, as in
  strncmp, but skipping ' '.
*/
SWIGRUNTIME int
SWIG_TypeNameComp(const char *f1, const char *l1,
		  const char *f2, const char *l2) {
  for (;(f1 != l1) && (f2 != l2); ++f1, ++f2) {
    while ((*f1 == ' ') && (f1 != l1)) ++f1;
    while ((*f2 == ' ') && (f2 != l2)) ++f2;
    if (*f1 != *f2) return (*f1 > *f2) ? 1 : -1;
  }
  return (l1 - f1) - (l2 - f2);
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if not equal, 1 if equal
*/
SWIGRUNTIME int
SWIG_TypeEquiv(const char *nb, const char *tb) {
  int equiv = 0;
  const char* te = tb + strlen(tb);
  const char* ne = nb;
  while (!equiv && *ne) {
    for (nb = ne; *ne; ++ne) {
      if (*ne == '|') break;
    }
    equiv = (SWIG_TypeNameComp(nb, ne, tb, te) == 0) ? 1 : 0;
    if (*ne) ++ne;
  }
  return equiv;
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if equal, -1 if nb < tb, 1 if nb > tb
*/
SWIGRUNTIME int
SWIG_TypeCompare(const char *nb, const char *tb) {
  int equiv = 0;
  const char* te = tb + strlen(tb);
  const char* ne = nb;
  while (!equiv && *ne) {
    for (nb = ne; *ne; ++ne) {
      if (*ne == '|') break;
    }
    equiv = (SWIG_TypeNameComp(nb, ne, tb, te) == 0) ? 1 : 0;
    if (*ne) ++ne;
  }
  return equiv;
}


/* think of this as a c++ template<> or a scheme macro */
#define SWIG_TypeCheck_Template(comparison, ty)         \
  if (ty) {                                             \
    swig_cast_info *iter = ty->cast;                    \
    while (iter) {                                      \
      if (comparison) {                                 \
        if (iter == ty->cast) return iter;              \
        /* Move iter to the top of the linked list */   \
        iter->prev->next = iter->next;                  \
        if (iter->next)                                 \
          iter->next->prev = iter->prev;                \
        iter->next = ty->cast;                          \
        iter->prev = 0;                                 \
        if (ty->cast) ty->cast->prev = iter;            \
        ty->cast = iter;                                \
        return iter;                                    \
      }                                                 \
      iter = iter->next;                                \
    }                                                   \
  }                                                     \
  return 0

/*
  Check the typename
*/
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheck(const char *c, swig_type_info *ty) {
  SWIG_TypeCheck_Template(strcmp(iter->type->name, c) == 0, ty);
}

/* Same as previous function, except strcmp is replaced with a pointer comparison */
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheckStruct(swig_type_info *from, swig_type_info *into) {
  SWIG_TypeCheck_Template(iter->type == from, into);
}

/*
  Cast a pointer up an inheritance hierarchy
*/
SWIGRUNTIMEINLINE void *
SWIG_TypeCast(swig_cast_info *ty, void *ptr) {
  return ((!ty) || (!ty->converter)) ? ptr : (*ty->converter)(ptr);
}

/* 
   Dynamic pointer casting. Down an inheritance hierarchy
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {
  swig_type_info *lastty = ty;
  if (!ty || !ty->dcast) return ty;
  while (ty && (ty->dcast)) {
    ty = (*ty->dcast)(ptr);
    if (ty) lastty = ty;
  }
  return lastty;
}

/*
  Return the name associated with this type
*/
SWIGRUNTIMEINLINE const char *
SWIG_TypeName(const swig_type_info *ty) {
  return ty->name;
}

/*
  Return the pretty name associated with this type,
  that is an unmangled type name in a form presentable to the user.
*/
SWIGRUNTIME const char *
SWIG_TypePrettyName(const swig_type_info *type) {
  /* The "str" field contains the equivalent pretty names of the
     type, separated by vertical-bar characters.  We choose
     to print the last name, as it is often (?) the most
     specific. */
  if (!type) return NULL;
  if (type->str != NULL) {
    const char *last_name = type->str;
    const char *s;
    for (s = type->str; *s; s++)
      if (*s == '|') last_name = s+1;
    return last_name;
  }
  else
    return type->name;
}

/* 
   Set the clientdata field for a type
*/
SWIGRUNTIME void
SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
  swig_cast_info *cast = ti->cast;
  /* if (ti->clientdata == clientdata) return; */
  ti->clientdata = clientdata;
  
  while (cast) {
    if (!cast->converter) {
      swig_type_info *tc = cast->type;
      if (!tc->clientdata) {
	SWIG_TypeClientData(tc, clientdata);
      }
    }    
    cast = cast->next;
  }
}
SWIGRUNTIME void
SWIG_TypeNewClientData(swig_type_info *ti, void *clientdata) {
  SWIG_TypeClientData(ti, clientdata);
  ti->owndata = 1;
}
  
/*
  Search for a swig_type_info structure only by mangled name
  Search is a O(log #types)
  
  We start searching at module start, and finish searching when start == end.  
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_MangledTypeQueryModule(swig_module_info *start, 
                            swig_module_info *end, 
		            const char *name) {
  swig_module_info *iter = start;
  do {
    if (iter->size) {
      register size_t l = 0;
      register size_t r = iter->size - 1;
      do {
	/* since l+r >= 0, we can (>> 1) instead (/ 2) */
	register size_t i = (l + r) >> 1; 
	const char *iname = iter->types[i]->name;
	if (iname) {
	  register int compare = strcmp(name, iname);
	  if (compare == 0) {	    
	    return iter->types[i];
	  } else if (compare < 0) {
	    if (i) {
	      r = i - 1;
	    } else {
	      break;
	    }
	  } else if (compare > 0) {
	    l = i + 1;
	  }
	} else {
	  break; /* should never happen */
	}
      } while (l <= r);
    }
    iter = iter->next;
  } while (iter != end);
  return 0;
}

/*
  Search for a swig_type_info structure for either a mangled name or a human readable name.
  It first searches the mangled names of the types, which is a O(log #types)
  If a type is not found it then searches the human readable names, which is O(#types).
  
  We start searching at module start, and finish searching when start == end.  
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeQueryModule(swig_module_info *start, 
                     swig_module_info *end, 
		     const char *name) {
  /* STEP 1: Search the name field using binary search */
  swig_type_info *ret = SWIG_MangledTypeQueryModule(start, end, name);
  if (ret) {
    return ret;
  } else {
    /* STEP 2: If the type hasn't been found, do a complete search
       of the str field (the human readable name) */
    swig_module_info *iter = start;
    do {
      register size_t i = 0;
      for (; i < iter->size; ++i) {
	if (iter->types[i]->str && (SWIG_TypeEquiv(iter->types[i]->str, name)))
	  return iter->types[i];
      }
      iter = iter->next;
    } while (iter != end);
  }
  
  /* neither found a match */
  return 0;
}

/* 
   Pack binary data into a string
*/
SWIGRUNTIME char *
SWIG_PackData(char *c, void *ptr, size_t sz) {
  static const char hex[17] = "0123456789abcdef";
  register const unsigned char *u = (unsigned char *) ptr;
  register const unsigned char *eu =  u + sz;
  for (; u != eu; ++u) {
    register unsigned char uu = *u;
    *(c++) = hex[(uu & 0xf0) >> 4];
    *(c++) = hex[uu & 0xf];
  }
  return c;
}

/* 
   Unpack binary data from a string
*/
SWIGRUNTIME const char *
SWIG_UnpackData(const char *c, void *ptr, size_t sz) {
  register unsigned char *u = (unsigned char *) ptr;
  register const unsigned char *eu = u + sz;
  for (; u != eu; ++u) {
    register char d = *(c++);
    register unsigned char uu;
    if ((d >= '0') && (d <= '9'))
      uu = ((d - '0') << 4);
    else if ((d >= 'a') && (d <= 'f'))
      uu = ((d - ('a'-10)) << 4);
    else 
      return (char *) 0;
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu |= (d - '0');
    else if ((d >= 'a') && (d <= 'f'))
      uu |= (d - ('a'-10));
    else 
      return (char *) 0;
    *u = uu;
  }
  return c;
}

/* 
   Pack 'void *' into a string buffer.
*/
SWIGRUNTIME char *
SWIG_PackVoidPtr(char *buff, void *ptr, const char *name, size_t bsz) {
  char *r = buff;
  if ((2*sizeof(void *) + 2) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,&ptr,sizeof(void *));
  if (strlen(name) + 1 > (bsz - (r - buff))) return 0;
  strcpy(r,name);
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackVoidPtr(const char *c, void **ptr, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      *ptr = (void *) 0;
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sizeof(void *));
}

SWIGRUNTIME char *
SWIG_PackDataName(char *buff, void *ptr, size_t sz, const char *name, size_t bsz) {
  char *r = buff;
  size_t lname = (name ? strlen(name) : 0);
  if ((2*sz + 2 + lname) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,ptr,sz);
  if (lname) {
    strncpy(r,name,lname+1);
  } else {
    *r = 0;
  }
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackDataName(const char *c, void *ptr, size_t sz, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      memset(ptr,0,sz);
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sz);
}

#ifdef __cplusplus
}
#endif

/*  Errors in SWIG */
#define  SWIG_UnknownError    	   -1 
#define  SWIG_IOError        	   -2 
#define  SWIG_RuntimeError   	   -3 
#define  SWIG_IndexError     	   -4 
#define  SWIG_TypeError      	   -5 
#define  SWIG_DivisionByZero 	   -6 
#define  SWIG_OverflowError  	   -7 
#define  SWIG_SyntaxError    	   -8 
#define  SWIG_ValueError     	   -9 
#define  SWIG_SystemError    	   -10
#define  SWIG_AttributeError 	   -11
#define  SWIG_MemoryError    	   -12 
#define  SWIG_NullReferenceError   -13



#include <ruby.h>

/* Ruby 1.7 defines NUM2LL(), LL2NUM() and ULL2NUM() macros */
#ifndef NUM2LL
#define NUM2LL(x) NUM2LONG((x))
#endif
#ifndef LL2NUM
#define LL2NUM(x) INT2NUM((long) (x))
#endif
#ifndef ULL2NUM
#define ULL2NUM(x) UINT2NUM((unsigned long) (x))
#endif

/* Ruby 1.7 doesn't (yet) define NUM2ULL() */
#ifndef NUM2ULL
#ifdef HAVE_LONG_LONG
#define NUM2ULL(x) rb_num2ull((x))
#else
#define NUM2ULL(x) NUM2ULONG(x)
#endif
#endif

/* RSTRING_LEN, etc are new in Ruby 1.9, but ->ptr and ->len no longer work */
/* Define these for older versions so we can just write code the new way */
#ifndef RSTRING_LEN
# define RSTRING_LEN(x) RSTRING(x)->len
#endif
#ifndef RSTRING_PTR
# define RSTRING_PTR(x) RSTRING(x)->ptr
#endif
#ifndef RARRAY_LEN
# define RARRAY_LEN(x) RARRAY(x)->len
#endif
#ifndef RARRAY_PTR
# define RARRAY_PTR(x) RARRAY(x)->ptr
#endif

/*
 * Need to be very careful about how these macros are defined, especially
 * when compiling C++ code or C code with an ANSI C compiler.
 *
 * VALUEFUNC(f) is a macro used to typecast a C function that implements
 * a Ruby method so that it can be passed as an argument to API functions
 * like rb_define_method() and rb_define_singleton_method().
 *
 * VOIDFUNC(f) is a macro used to typecast a C function that implements
 * either the "mark" or "free" stuff for a Ruby Data object, so that it
 * can be passed as an argument to API functions like Data_Wrap_Struct()
 * and Data_Make_Struct().
 */
 
#ifdef __cplusplus
#  ifndef RUBY_METHOD_FUNC /* These definitions should work for Ruby 1.4.6 */
#    define PROTECTFUNC(f) ((VALUE (*)()) f)
#    define VALUEFUNC(f) ((VALUE (*)()) f)
#    define VOIDFUNC(f)  ((void (*)()) f)
#  else
#    ifndef ANYARGS /* These definitions should work for Ruby 1.6 */
#      define PROTECTFUNC(f) ((VALUE (*)()) f)
#      define VALUEFUNC(f) ((VALUE (*)()) f)
#      define VOIDFUNC(f)  ((RUBY_DATA_FUNC) f)
#    else /* These definitions should work for Ruby 1.7+ */
#      define PROTECTFUNC(f) ((VALUE (*)(VALUE)) f)
#      define VALUEFUNC(f) ((VALUE (*)(ANYARGS)) f)
#      define VOIDFUNC(f)  ((RUBY_DATA_FUNC) f)
#    endif
#  endif
#else
#  define VALUEFUNC(f) (f)
#  define VOIDFUNC(f) (f)
#endif

/* Don't use for expressions have side effect */
#ifndef RB_STRING_VALUE
#define RB_STRING_VALUE(s) (TYPE(s) == T_STRING ? (s) : (*(volatile VALUE *)&(s) = rb_str_to_str(s)))
#endif
#ifndef StringValue
#define StringValue(s) RB_STRING_VALUE(s)
#endif
#ifndef StringValuePtr
#define StringValuePtr(s) RSTRING_PTR(RB_STRING_VALUE(s))
#endif
#ifndef StringValueLen
#define StringValueLen(s) RSTRING_LEN(RB_STRING_VALUE(s))
#endif
#ifndef SafeStringValue
#define SafeStringValue(v) do {\
    StringValue(v);\
    rb_check_safe_str(v);\
} while (0)
#endif

#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
#define rb_define_alloc_func(klass, func) rb_define_singleton_method((klass), "new", VALUEFUNC((func)), -1)
#define rb_undef_alloc_func(klass) rb_undef_method(CLASS_OF((klass)), "new")
#endif


/* -----------------------------------------------------------------------------
 * error manipulation
 * ----------------------------------------------------------------------------- */


/* Define some additional error types */
#define SWIG_ObjectPreviouslyDeletedError  -100


/* Define custom exceptions for errors that do not map to existing Ruby
   exceptions.  Note this only works for C++ since a global cannot be
   initialized by a funtion in C.  For C, fallback to rb_eRuntimeError.*/

SWIGINTERN VALUE 
getNullReferenceError(void) {
  static int init = 0;
  static VALUE rb_eNullReferenceError ;
  if (!init) {
    init = 1;
    rb_eNullReferenceError = rb_define_class("NullReferenceError", rb_eRuntimeError);
  }
  return rb_eNullReferenceError;
} 

SWIGINTERN VALUE 
getObjectPreviouslyDeletedError(void) {
  static int init = 0;
  static VALUE rb_eObjectPreviouslyDeleted ;
  if (!init) {
    init = 1;
    rb_eObjectPreviouslyDeleted = rb_define_class("ObjectPreviouslyDeleted", rb_eRuntimeError);
  }
  return rb_eObjectPreviouslyDeleted;
} 


SWIGINTERN VALUE
SWIG_Ruby_ErrorType(int SWIG_code) {
  VALUE type;
  switch (SWIG_code) {
  case SWIG_MemoryError:
    type = rb_eNoMemError;
    break;
  case SWIG_IOError:
    type = rb_eIOError;
    break;
  case SWIG_RuntimeError:
    type = rb_eRuntimeError;
    break;
  case SWIG_IndexError:
    type = rb_eIndexError;
    break;
  case SWIG_TypeError:
    type = rb_eTypeError;
    break;
  case SWIG_DivisionByZero:
    type = rb_eZeroDivError;
    break;
  case SWIG_OverflowError:
    type = rb_eRangeError;
    break;
  case SWIG_SyntaxError:
    type = rb_eSyntaxError;
    break;
  case SWIG_ValueError:
    type = rb_eArgError;
    break;
  case SWIG_SystemError:
    type = rb_eFatal;
    break;
  case SWIG_AttributeError:
    type = rb_eRuntimeError;
    break;
  case SWIG_NullReferenceError:
    type = getNullReferenceError();
    break;
  case SWIG_ObjectPreviouslyDeletedError:
    type = getObjectPreviouslyDeletedError();
    break;
  case SWIG_UnknownError:
    type = rb_eRuntimeError;
    break;
  default:
    type = rb_eRuntimeError;
  }
  return type;
}




/* -----------------------------------------------------------------------------
 * See the LICENSE file for information on copyright, usage and redistribution
 * of SWIG, and the README file for authors - http://www.swig.org/release.html.
 *
 * rubytracking.swg
 *
 * This file contains support for tracking mappings from 
 * Ruby objects to C++ objects.  This functionality is needed
 * to implement mark functions for Ruby's mark and sweep
 * garbage collector.
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#endif


/* Global Ruby hash table to store Trackings from C/C++
   structs to Ruby Objects. */
static VALUE swig_ruby_trackings;

/* Global variable that stores a reference to the ruby
   hash table delete function. */
static ID swig_ruby_hash_delete = 0;

/* Setup a Ruby hash table to store Trackings */
SWIGRUNTIME void SWIG_RubyInitializeTrackings(void) {
  /* Create a ruby hash table to store Trackings from C++ 
     objects to Ruby objects.  Also make sure to tell
     the garabage collector about the hash table. */
  swig_ruby_trackings = rb_hash_new();
  rb_gc_register_address(&swig_ruby_trackings);
  
  /* Now store a reference to the hash table delete function
     so that we only have to look it up once.*/
  swig_ruby_hash_delete = rb_intern("delete");
}

/* Get a Ruby number to reference a pointer */
SWIGRUNTIME VALUE SWIG_RubyPtrToReference(void* ptr) {
  /* We cast the pointer to an unsigned long
     and then store a reference to it using
     a Ruby number object. */

  /* Convert the pointer to a Ruby number */
  unsigned long value = (unsigned long) ptr;
  return LONG2NUM(value);
}

/* Get a Ruby number to reference an object */
SWIGRUNTIME VALUE SWIG_RubyObjectToReference(VALUE object) {
  /* We cast the object to an unsigned long
     and then store a reference to it using
     a Ruby number object. */

  /* Convert the Object to a Ruby number */
  unsigned long value = (unsigned long) object;
  return LONG2NUM(value);
}

/* Get a Ruby object from a previously stored reference */
SWIGRUNTIME VALUE SWIG_RubyReferenceToObject(VALUE reference) {
  /* The provided Ruby number object is a reference
     to the Ruby object we want.*/

  /* First convert the Ruby number to a C number */
  unsigned long value = NUM2LONG(reference);
  return (VALUE) value;
}

/* Add a Tracking from a C/C++ struct to a Ruby object */
SWIGRUNTIME void SWIG_RubyAddTracking(void* ptr, VALUE object) {
  /* In a Ruby hash table we store the pointer and
     the associated Ruby object.  The trick here is
     that we cannot store the Ruby object directly - if
     we do then it cannot be garbage collected.  So
     instead we typecast it as a unsigned long and
     convert it to a Ruby number object.*/

  /* Get a reference to the pointer as a Ruby number */
  VALUE key = SWIG_RubyPtrToReference(ptr);

  /* Get a reference to the Ruby object as a Ruby number */
  VALUE value = SWIG_RubyObjectToReference(object);

  /* Store the mapping to the global hash table. */
  rb_hash_aset(swig_ruby_trackings, key, value);
}

/* Get the Ruby object that owns the specified C/C++ struct */
SWIGRUNTIME VALUE SWIG_RubyInstanceFor(void* ptr) {
  /* Get a reference to the pointer as a Ruby number */
  VALUE key = SWIG_RubyPtrToReference(ptr);

  /* Now lookup the value stored in the global hash table */
  VALUE value = rb_hash_aref(swig_ruby_trackings, key);
	
  if (value == Qnil) {
    /* No object exists - return nil. */
    return Qnil;
  }
  else {
    /* Convert this value to Ruby object */
    return SWIG_RubyReferenceToObject(value);
  }
}

/* Remove a Tracking from a C/C++ struct to a Ruby object.  It
   is very important to remove objects once they are destroyed
   since the same memory address may be reused later to create
   a new object. */
SWIGRUNTIME void SWIG_RubyRemoveTracking(void* ptr) {
  /* Get a reference to the pointer as a Ruby number */
  VALUE key = SWIG_RubyPtrToReference(ptr);

  /* Delete the object from the hash table by calling Ruby's
     do this we need to call the Hash.delete method.*/
  rb_funcall(swig_ruby_trackings, swig_ruby_hash_delete, 1, key);
}

/* This is a helper method that unlinks a Ruby object from its
   underlying C++ object.  This is needed if the lifetime of the
   Ruby object is longer than the C++ object */
SWIGRUNTIME void SWIG_RubyUnlinkObjects(void* ptr) {
  VALUE object = SWIG_RubyInstanceFor(ptr);

  if (object != Qnil) {
    DATA_PTR(object) = 0;
  }
}


#ifdef __cplusplus
}
#endif

/* -----------------------------------------------------------------------------
 * Ruby API portion that goes into the runtime
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#endif

SWIGINTERN VALUE
SWIG_Ruby_AppendOutput(VALUE target, VALUE o) {
  if (NIL_P(target)) {
    target = o;
  } else {
    if (TYPE(target) != T_ARRAY) {
      VALUE o2 = target;
      target = rb_ary_new();
      rb_ary_push(target, o2);
    }
    rb_ary_push(target, o);
  }
  return target;
}

#ifdef __cplusplus
}
#endif


/* -----------------------------------------------------------------------------
 * See the LICENSE file for information on copyright, usage and redistribution
 * of SWIG, and the README file for authors - http://www.swig.org/release.html.
 *
 * rubyrun.swg
 *
 * This file contains the runtime support for Ruby modules
 * and includes code for managing global variables and pointer
 * type checking.
 * ----------------------------------------------------------------------------- */

/* For backward compatibility only */
#define SWIG_POINTER_EXCEPTION  0

/* for raw pointers */
#define SWIG_ConvertPtr(obj, pptr, type, flags)         SWIG_Ruby_ConvertPtrAndOwn(obj, pptr, type, flags, 0)
#define SWIG_ConvertPtrAndOwn(obj,pptr,type,flags,own)  SWIG_Ruby_ConvertPtrAndOwn(obj, pptr, type, flags, own)
#define SWIG_NewPointerObj(ptr, type, flags)            SWIG_Ruby_NewPointerObj(ptr, type, flags)
#define SWIG_AcquirePtr(ptr, own)                       SWIG_Ruby_AcquirePtr(ptr, own)
#define swig_owntype                                    ruby_owntype

/* for raw packed data */
#define SWIG_ConvertPacked(obj, ptr, sz, ty)            SWIG_Ruby_ConvertPacked(obj, ptr, sz, ty, flags)
#define SWIG_NewPackedObj(ptr, sz, type)                SWIG_Ruby_NewPackedObj(ptr, sz, type)

/* for class or struct pointers */
#define SWIG_ConvertInstance(obj, pptr, type, flags)    SWIG_ConvertPtr(obj, pptr, type, flags)
#define SWIG_NewInstanceObj(ptr, type, flags)           SWIG_NewPointerObj(ptr, type, flags)

/* for C or C++ function pointers */
#define SWIG_ConvertFunctionPtr(obj, pptr, type)        SWIG_ConvertPtr(obj, pptr, type, 0)
#define SWIG_NewFunctionPtrObj(ptr, type)               SWIG_NewPointerObj(ptr, type, 0)

/* for C++ member pointers, ie, member methods */
#define SWIG_ConvertMember(obj, ptr, sz, ty)            SWIG_Ruby_ConvertPacked(obj, ptr, sz, ty)
#define SWIG_NewMemberObj(ptr, sz, type)                SWIG_Ruby_NewPackedObj(ptr, sz, type)


/* Runtime API */

#define SWIG_GetModule(clientdata)                      SWIG_Ruby_GetModule()	
#define SWIG_SetModule(clientdata, pointer) 		SWIG_Ruby_SetModule(pointer)


/* Error manipulation */

#define SWIG_ErrorType(code)                            SWIG_Ruby_ErrorType(code)               
#define SWIG_Error(code, msg)            		rb_raise(SWIG_Ruby_ErrorType(code), msg)
#define SWIG_fail                        		goto fail				 


/* Ruby-specific SWIG API */

#define SWIG_InitRuntime()                              SWIG_Ruby_InitRuntime()              
#define SWIG_define_class(ty)                        	SWIG_Ruby_define_class(ty)
#define SWIG_NewClassInstance(value, ty)             	SWIG_Ruby_NewClassInstance(value, ty)
#define SWIG_MangleStr(value)                        	SWIG_Ruby_MangleStr(value)		  
#define SWIG_CheckConvert(value, ty)                 	SWIG_Ruby_CheckConvert(value, ty)	  


/* -----------------------------------------------------------------------------
 * pointers/data manipulation
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#if 0
} /* cc-mode */
#endif
#endif

typedef struct {
  VALUE klass;
  VALUE mImpl;
  void  (*mark)(void *);
  void  (*destroy)(void *);
  int trackObjects;
} swig_class;


static VALUE _mSWIG = Qnil;
static VALUE _cSWIG_Pointer = Qnil;
static VALUE swig_runtime_data_type_pointer = Qnil;

SWIGRUNTIME VALUE 
getExceptionClass(void) {
  static int init = 0;
  static VALUE rubyExceptionClass ;
  if (!init) {
    init = 1;
    rubyExceptionClass = rb_const_get(_mSWIG, rb_intern("Exception"));
  }
  return rubyExceptionClass;
} 

/* This code checks to see if the Ruby object being raised as part
   of an exception inherits from the Ruby class Exception.  If so,
   the object is simply returned.  If not, then a new Ruby exception
   object is created and that will be returned to Ruby.*/
SWIGRUNTIME VALUE
SWIG_Ruby_ExceptionType(swig_type_info *desc, VALUE obj) {
  VALUE exceptionClass = getExceptionClass();
  if (rb_obj_is_kind_of(obj, exceptionClass)) {
    return obj;
  }  else {
    return rb_exc_new3(rb_eRuntimeError, rb_obj_as_string(obj));
  }
}

/* Initialize Ruby runtime support */
SWIGRUNTIME void
SWIG_Ruby_InitRuntime(void)
{
  if (_mSWIG == Qnil) {
    _mSWIG = rb_define_module("SWIG");
  }
}

/* Define Ruby class for C type */
SWIGRUNTIME void
SWIG_Ruby_define_class(swig_type_info *type)
{
  VALUE klass;
  char *klass_name = (char *) malloc(4 + strlen(type->name) + 1);
  sprintf(klass_name, "TYPE%s", type->name);
  if (NIL_P(_cSWIG_Pointer)) {
    _cSWIG_Pointer = rb_define_class_under(_mSWIG, "Pointer", rb_cObject);
    rb_undef_method(CLASS_OF(_cSWIG_Pointer), "new");
  }
  klass = rb_define_class_under(_mSWIG, klass_name, _cSWIG_Pointer);
  free((void *) klass_name);
}

/* Create a new pointer object */
SWIGRUNTIME VALUE
SWIG_Ruby_NewPointerObj(void *ptr, swig_type_info *type, int flags)
{
  int own =  flags & SWIG_POINTER_OWN; 
  
  char *klass_name;
  swig_class *sklass;
  VALUE klass;
  VALUE obj;
  
  if (!ptr)
    return Qnil;
  
  if (type->clientdata) {
    sklass = (swig_class *) type->clientdata;
		
    /* Are we tracking this class and have we already returned this Ruby object? */
    if (sklass->trackObjects) {
      obj = SWIG_RubyInstanceFor(ptr);
      
      /* Check the object's type and make sure it has the correct type.
        It might not in cases where methods do things like 
        downcast methods. */
      if (obj != Qnil) {
        VALUE value = rb_iv_get(obj, "__swigtype__");
        char* type_name = RSTRING_PTR(value);
				
        if (strcmp(type->name, type_name) == 0) {
          return obj;
        }
      }
    }

    /* Create a new Ruby object */
    obj = Data_Wrap_Struct(sklass->klass, VOIDFUNC(sklass->mark), (own ? VOIDFUNC(sklass->destroy) : 0), ptr);

    /* If tracking is on for this class then track this object. */
    if (sklass->trackObjects) {
      SWIG_RubyAddTracking(ptr, obj);
    }
  } else {
    klass_name = (char *) malloc(4 + strlen(type->name) + 1);
    sprintf(klass_name, "TYPE%s", type->name);
    klass = rb_const_get(_mSWIG, rb_intern(klass_name));
    free((void *) klass_name);
    obj = Data_Wrap_Struct(klass, 0, 0, ptr);
  }
  rb_iv_set(obj, "__swigtype__", rb_str_new2(type->name));
  
  return obj;
}

/* Create a new class instance (always owned) */
SWIGRUNTIME VALUE
SWIG_Ruby_NewClassInstance(VALUE klass, swig_type_info *type)
{
  VALUE obj;
  swig_class *sklass = (swig_class *) type->clientdata;
  obj = Data_Wrap_Struct(klass, VOIDFUNC(sklass->mark), VOIDFUNC(sklass->destroy), 0);
  rb_iv_set(obj, "__swigtype__", rb_str_new2(type->name));
  return obj;
}

/* Get type mangle from class name */
SWIGRUNTIMEINLINE char *
SWIG_Ruby_MangleStr(VALUE obj)
{
  VALUE stype = rb_iv_get(obj, "__swigtype__");
  return StringValuePtr(stype);
}

/* Acquire a pointer value */
typedef void (*ruby_owntype)(void*);

SWIGRUNTIME ruby_owntype
SWIG_Ruby_AcquirePtr(VALUE obj, ruby_owntype own) {
  if (obj) {
    ruby_owntype oldown = RDATA(obj)->dfree;
    RDATA(obj)->dfree = own;
    return oldown;
  } else {
    return 0;
  }
}

/* Convert a pointer value */
SWIGRUNTIME int
SWIG_Ruby_ConvertPtrAndOwn(VALUE obj, void **ptr, swig_type_info *ty, int flags, ruby_owntype *own)
{
  char *c;
  swig_cast_info *tc;
  void *vptr = 0;

  /* Grab the pointer */
  if (NIL_P(obj)) {
    *ptr = 0;
    return SWIG_OK;
  } else {
    if (TYPE(obj) != T_DATA) {
      return SWIG_ERROR;
    }
    Data_Get_Struct(obj, void, vptr);
  }
  
  if (own) *own = RDATA(obj)->dfree;
    
  /* Check to see if the input object is giving up ownership
     of the underlying C struct or C++ object.  If so then we
     need to reset the destructor since the Ruby object no 
     longer owns the underlying C++ object.*/ 
  if (flags & SWIG_POINTER_DISOWN) {
    /* Is tracking on for this class? */
    int track = 0;
    if (ty && ty->clientdata) {
      swig_class *sklass = (swig_class *) ty->clientdata;
      track = sklass->trackObjects;
    }
		
    if (track) {
      /* We are tracking objects for this class.  Thus we change the destructor
       * to SWIG_RubyRemoveTracking.  This allows us to
       * remove the mapping from the C++ to Ruby object
       * when the Ruby object is garbage collected.  If we don't
       * do this, then it is possible we will return a reference 
       * to a Ruby object that no longer exists thereby crashing Ruby. */
      RDATA(obj)->dfree = SWIG_RubyRemoveTracking;
    } else {    
      RDATA(obj)->dfree = 0;
    }
  }

  /* Do type-checking if type info was provided */
  if (ty) {
    if (ty->clientdata) {
      if (rb_obj_is_kind_of(obj, ((swig_class *) (ty->clientdata))->klass)) {
        if (vptr == 0) {
          /* The object has already been deleted */
          return SWIG_ObjectPreviouslyDeletedError;
        }
        *ptr = vptr;
        return SWIG_OK;
      }
    }
    if ((c = SWIG_MangleStr(obj)) == NULL) {
      return SWIG_ERROR;
    }
    tc = SWIG_TypeCheck(c, ty);
    if (!tc) {
      return SWIG_ERROR;
    }
    *ptr = SWIG_TypeCast(tc, vptr);
  } else {
    *ptr = vptr;
  }
  
  return SWIG_OK;
}

/* Check convert */
SWIGRUNTIMEINLINE int
SWIG_Ruby_CheckConvert(VALUE obj, swig_type_info *ty)
{
  char *c = SWIG_MangleStr(obj);
  if (!c) return 0;
  return SWIG_TypeCheck(c,ty) != 0;
}

SWIGRUNTIME VALUE
SWIG_Ruby_NewPackedObj(void *ptr, int sz, swig_type_info *type) {
  char result[1024];
  char *r = result;
  if ((2*sz + 1 + strlen(type->name)) > 1000) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r, ptr, sz);
  strcpy(r, type->name);
  return rb_str_new2(result);
}

/* Convert a packed value value */
SWIGRUNTIME int
SWIG_Ruby_ConvertPacked(VALUE obj, void *ptr, int sz, swig_type_info *ty) {
  swig_cast_info *tc;
  const char  *c;

  if (TYPE(obj) != T_STRING) goto type_error;
  c = StringValuePtr(obj);
  /* Pointer values must start with leading underscore */
  if (*c != '_') goto type_error;
  c++;
  c = SWIG_UnpackData(c, ptr, sz);
  if (ty) {
    tc = SWIG_TypeCheck(c, ty);
    if (!tc) goto type_error;
  }
  return SWIG_OK;

 type_error:
  return SWIG_ERROR;
}

SWIGRUNTIME swig_module_info *
SWIG_Ruby_GetModule(void)
{
  VALUE pointer;
  swig_module_info *ret = 0;
  VALUE verbose = rb_gv_get("VERBOSE");

 /* temporarily disable warnings, since the pointer check causes warnings with 'ruby -w' */
  rb_gv_set("VERBOSE", Qfalse);
  
  /* first check if pointer already created */
  pointer = rb_gv_get("$swig_runtime_data_type_pointer" SWIG_RUNTIME_VERSION SWIG_TYPE_TABLE_NAME);
  if (pointer != Qnil) {
    Data_Get_Struct(pointer, swig_module_info, ret);
  }

  /* reinstate warnings */
  rb_gv_set("VERBOSE", verbose);
  return ret;
}

SWIGRUNTIME void 
SWIG_Ruby_SetModule(swig_module_info *pointer)
{
  /* register a new class */
  VALUE cl = rb_define_class("swig_runtime_data", rb_cObject);
  /* create and store the structure pointer to a global variable */
  swig_runtime_data_type_pointer = Data_Wrap_Struct(cl, 0, 0, pointer);
  rb_define_readonly_variable("$swig_runtime_data_type_pointer" SWIG_RUNTIME_VERSION SWIG_TYPE_TABLE_NAME, &swig_runtime_data_type_pointer);
}

#ifdef __cplusplus
#if 0
{ /* cc-mode */
#endif
}
#endif



#define SWIG_exception_fail(code, msg) do { SWIG_Error(code, msg); SWIG_fail; } while(0) 

#define SWIG_contract_assert(expr, msg) if (!(expr)) { SWIG_Error(SWIG_RuntimeError, msg); SWIG_fail; } else 



/* -------- TYPES TABLE (BEGIN) -------- */

#define SWIGTYPE_p_OpenBabel__CharPtrLess swig_types[0]
#define SWIGTYPE_p_OpenBabel__DoubleType swig_types[1]
#define SWIGTYPE_p_OpenBabel__FMapType__iterator swig_types[2]
#define SWIGTYPE_p_OpenBabel__FastSearch swig_types[3]
#define SWIGTYPE_p_OpenBabel__FastSearchIndexer swig_types[4]
#define SWIGTYPE_p_OpenBabel__FptIndex swig_types[5]
#define SWIGTYPE_p_OpenBabel__FptIndexHeader swig_types[6]
#define SWIGTYPE_p_OpenBabel__OBAngle swig_types[7]
#define SWIGTYPE_p_OpenBabel__OBAngleData swig_types[8]
#define SWIGTYPE_p_OpenBabel__OBAromaticTyper swig_types[9]
#define SWIGTYPE_p_OpenBabel__OBAtom swig_types[10]
#define SWIGTYPE_p_OpenBabel__OBAtomAtomIter swig_types[11]
#define SWIGTYPE_p_OpenBabel__OBAtomBondIter swig_types[12]
#define SWIGTYPE_p_OpenBabel__OBAtomTyper swig_types[13]
#define SWIGTYPE_p_OpenBabel__OBBase swig_types[14]
#define SWIGTYPE_p_OpenBabel__OBBitVec swig_types[15]
#define SWIGTYPE_p_OpenBabel__OBBond swig_types[16]
#define SWIGTYPE_p_OpenBabel__OBChainsParser swig_types[17]
#define SWIGTYPE_p_OpenBabel__OBChiralData swig_types[18]
#define SWIGTYPE_p_OpenBabel__OBCommentData swig_types[19]
#define SWIGTYPE_p_OpenBabel__OBConformerData swig_types[20]
#define SWIGTYPE_p_OpenBabel__OBConversion swig_types[21]
#define SWIGTYPE_p_OpenBabel__OBElement swig_types[22]
#define SWIGTYPE_p_OpenBabel__OBElementTable swig_types[23]
#define SWIGTYPE_p_OpenBabel__OBError swig_types[24]
#define SWIGTYPE_p_OpenBabel__OBExternalBond swig_types[25]
#define SWIGTYPE_p_OpenBabel__OBExternalBondData swig_types[26]
#define SWIGTYPE_p_OpenBabel__OBFFCalculation swig_types[27]
#define SWIGTYPE_p_OpenBabel__OBFFParameter swig_types[28]
#define SWIGTYPE_p_OpenBabel__OBFingerprint swig_types[29]
#define SWIGTYPE_p_OpenBabel__OBForceField swig_types[30]
#define SWIGTYPE_p_OpenBabel__OBFormat swig_types[31]
#define SWIGTYPE_p_OpenBabel__OBGenericData swig_types[32]
#define SWIGTYPE_p_OpenBabel__OBGlobalDataBase swig_types[33]
#define SWIGTYPE_p_OpenBabel__OBInternalCoord swig_types[34]
#define SWIGTYPE_p_OpenBabel__OBIsotopeTable swig_types[35]
#define SWIGTYPE_p_OpenBabel__OBMessageHandler swig_types[36]
#define SWIGTYPE_p_OpenBabel__OBMol swig_types[37]
#define SWIGTYPE_p_OpenBabel__OBMolAngleIter swig_types[38]
#define SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter swig_types[39]
#define SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter swig_types[40]
#define SWIGTYPE_p_OpenBabel__OBMolAtomIter swig_types[41]
#define SWIGTYPE_p_OpenBabel__OBMolBondIter swig_types[42]
#define SWIGTYPE_p_OpenBabel__OBMolPairIter swig_types[43]
#define SWIGTYPE_p_OpenBabel__OBMolRingIter swig_types[44]
#define SWIGTYPE_p_OpenBabel__OBMolTorsionIter swig_types[45]
#define SWIGTYPE_p_OpenBabel__OBPairData swig_types[46]
#define SWIGTYPE_p_OpenBabel__OBPairTemplateTdouble_t swig_types[47]
#define SWIGTYPE_p_OpenBabel__OBPairTemplateTint_t swig_types[48]
#define SWIGTYPE_p_OpenBabel__OBRTree swig_types[49]
#define SWIGTYPE_p_OpenBabel__OBRandom swig_types[50]
#define SWIGTYPE_p_OpenBabel__OBResidue swig_types[51]
#define SWIGTYPE_p_OpenBabel__OBResidueAtomIter swig_types[52]
#define SWIGTYPE_p_OpenBabel__OBResidueData swig_types[53]
#define SWIGTYPE_p_OpenBabel__OBResidueIter swig_types[54]
#define SWIGTYPE_p_OpenBabel__OBRing swig_types[55]
#define SWIGTYPE_p_OpenBabel__OBRingData swig_types[56]
#define SWIGTYPE_p_OpenBabel__OBRingSearch swig_types[57]
#define SWIGTYPE_p_OpenBabel__OBSSMatch swig_types[58]
#define SWIGTYPE_p_OpenBabel__OBSerialNums swig_types[59]
#define SWIGTYPE_p_OpenBabel__OBSetData swig_types[60]
#define SWIGTYPE_p_OpenBabel__OBSmartsPattern swig_types[61]
#define SWIGTYPE_p_OpenBabel__OBSqrtTbl swig_types[62]
#define SWIGTYPE_p_OpenBabel__OBStopwatch swig_types[63]
#define SWIGTYPE_p_OpenBabel__OBSymmetryData swig_types[64]
#define SWIGTYPE_p_OpenBabel__OBTorsion swig_types[65]
#define SWIGTYPE_p_OpenBabel__OBTorsionData swig_types[66]
#define SWIGTYPE_p_OpenBabel__OBTypeTable swig_types[67]
#define SWIGTYPE_p_OpenBabel__OBUnitCell swig_types[68]
#define SWIGTYPE_p_OpenBabel__OBVibrationData swig_types[69]
#define SWIGTYPE_p_OpenBabel__OBVirtualBond swig_types[70]
#define SWIGTYPE_p_OpenBabel__Pattern swig_types[71]
#define SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBFingerprint_t swig_types[72]
#define SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t swig_types[73]
#define SWIGTYPE_p_OpenBabel__Template swig_types[74]
#define SWIGTYPE_p_OpenBabel__matrix3x3 swig_types[75]
#define SWIGTYPE_p_OpenBabel__obLogBuf swig_types[76]
#define SWIGTYPE_p_OpenBabel__quadTOpenBabel__OBAtom_p_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_t swig_types[77]
#define SWIGTYPE_p_OpenBabel__tripleTOpenBabel__OBAtom_p_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_t swig_types[78]
#define SWIGTYPE_p_OpenBabel__vector3 swig_types[79]
#define SWIGTYPE_p_a_3__double swig_types[80]
#define SWIGTYPE_p_a_4__char swig_types[81]
#define SWIGTYPE_p_char swig_types[82]
#define SWIGTYPE_p_double swig_types[83]
#define SWIGTYPE_p_int swig_types[84]
#define SWIGTYPE_p_p_OpenBabel__OBAngleData swig_types[85]
#define SWIGTYPE_p_p_OpenBabel__OBChiralData swig_types[86]
#define SWIGTYPE_p_p_OpenBabel__OBCommentData swig_types[87]
#define SWIGTYPE_p_p_OpenBabel__OBConformerData swig_types[88]
#define SWIGTYPE_p_p_OpenBabel__OBExternalBondData swig_types[89]
#define SWIGTYPE_p_p_OpenBabel__OBFormat swig_types[90]
#define SWIGTYPE_p_p_OpenBabel__OBGenericData swig_types[91]
#define SWIGTYPE_p_p_OpenBabel__OBPairData swig_types[92]
#define SWIGTYPE_p_p_OpenBabel__OBRingData swig_types[93]
#define SWIGTYPE_p_p_OpenBabel__OBSerialNums swig_types[94]
#define SWIGTYPE_p_p_OpenBabel__OBSetData swig_types[95]
#define SWIGTYPE_p_p_OpenBabel__OBSymmetryData swig_types[96]
#define SWIGTYPE_p_p_OpenBabel__OBTorsionData swig_types[97]
#define SWIGTYPE_p_p_OpenBabel__OBUnitCell swig_types[98]
#define SWIGTYPE_p_p_OpenBabel__OBVibrationData swig_types[99]
#define SWIGTYPE_p_p_OpenBabel__OBVirtualBond swig_types[100]
#define SWIGTYPE_p_p_double swig_types[101]
#define SWIGTYPE_p_p_int swig_types[102]
#define SWIGTYPE_p_std__dequeTint_t swig_types[103]
#define SWIGTYPE_p_std__ifstream swig_types[104]
#define SWIGTYPE_p_std__istream swig_types[105]
#define SWIGTYPE_p_std__mapTchar_const_p_OpenBabel__OBFormat_p_OpenBabel__CharPtrLess_t swig_types[106]
#define SWIGTYPE_p_std__mapTint_OpenBabel__OBAtom_p_t swig_types[107]
#define SWIGTYPE_p_std__mapTstd__string_std__string_t swig_types[108]
#define SWIGTYPE_p_std__multimapTdouble_unsigned_int_t swig_types[109]
#define SWIGTYPE_p_std__ostream swig_types[110]
#define SWIGTYPE_p_std__out_of_range swig_types[111]
#define SWIGTYPE_p_std__pairTOpenBabel__OBAtom_p_OpenBabel__OBAtom_p_t swig_types[112]
#define SWIGTYPE_p_std__streampos swig_types[113]
#define SWIGTYPE_p_std__string swig_types[114]
#define SWIGTYPE_p_std__type_info swig_types[115]
#define SWIGTYPE_p_std__vectorTOpenBabel__OBAtom_p_t swig_types[116]
#define SWIGTYPE_p_std__vectorTOpenBabel__OBAtom_p_t__iterator swig_types[117]
#define SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t swig_types[118]
#define SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator swig_types[119]
#define SWIGTYPE_p_std__vectorTOpenBabel__OBBond_t swig_types[120]
#define SWIGTYPE_p_std__vectorTOpenBabel__OBExternalBond_t swig_types[121]
#define SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t swig_types[122]
#define SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t__iterator swig_types[123]
#define SWIGTYPE_p_std__vectorTOpenBabel__OBInternalCoord_p_t swig_types[124]
#define SWIGTYPE_p_std__vectorTOpenBabel__OBInternalCoord_p_t__iterator swig_types[125]
#define SWIGTYPE_p_std__vectorTOpenBabel__OBMol_t swig_types[126]
#define SWIGTYPE_p_std__vectorTOpenBabel__OBResidue_p_t__iterator swig_types[127]
#define SWIGTYPE_p_std__vectorTOpenBabel__OBResidue_t swig_types[128]
#define SWIGTYPE_p_std__vectorTOpenBabel__OBRing_p_t swig_types[129]
#define SWIGTYPE_p_std__vectorTOpenBabel__OBRing_p_t__iterator swig_types[130]
#define SWIGTYPE_p_std__vectorTOpenBabel__OBRing_t swig_types[131]
#define SWIGTYPE_p_std__vectorTOpenBabel__OBTorsion_t swig_types[132]
#define SWIGTYPE_p_std__vectorTOpenBabel__tripleTOpenBabel__OBAtom_p_OpenBabel__OBAtom_p_double_t_t swig_types[133]
#define SWIGTYPE_p_std__vectorTOpenBabel__vector3_t swig_types[134]
#define SWIGTYPE_p_std__vectorTdouble_p_t swig_types[135]
#define SWIGTYPE_p_std__vectorTdouble_p_t__iterator swig_types[136]
#define SWIGTYPE_p_std__vectorTdouble_t swig_types[137]
#define SWIGTYPE_p_std__vectorTint_t swig_types[138]
#define SWIGTYPE_p_std__vectorTstd__pairTint_int_t_t swig_types[139]
#define SWIGTYPE_p_std__vectorTstd__pairTstd__string_std__string_t_t swig_types[140]
#define SWIGTYPE_p_std__vectorTstd__string_t swig_types[141]
#define SWIGTYPE_p_std__vectorTstd__vectorTOpenBabel__vector3_t_t swig_types[142]
#define SWIGTYPE_p_std__vectorTstd__vectorTint_t_t swig_types[143]
#define SWIGTYPE_p_std__vectorTstd__vectorTint_t_t__iterator swig_types[144]
#define SWIGTYPE_p_std__vectorTstd__vectorTunsigned_int_t_t swig_types[145]
#define SWIGTYPE_p_std__vectorTunsigned_int_t swig_types[146]
#define SWIGTYPE_p_std__vectorTunsigned_short_t swig_types[147]
#define SWIGTYPE_p_unsigned_int swig_types[148]
static swig_type_info *swig_types[150];
static swig_module_info swig_module = {swig_types, 149, 0, 0, 0, 0};
#define SWIG_TypeQuery(name) SWIG_TypeQueryModule(&swig_module, &swig_module, name)
#define SWIG_MangledTypeQuery(name) SWIG_MangledTypeQueryModule(&swig_module, &swig_module, name)

/* -------- TYPES TABLE (END) -------- */

#define SWIG_init    Init_openbabel
#define SWIG_name    "Openbabel"

static VALUE mOpenbabel;

#define SWIGVERSION 0x010331 
#define SWIG_VERSION SWIGVERSION


#define SWIG_as_voidptr(a) const_cast< void * >(static_cast< const void * >(a)) 
#define SWIG_as_voidptrptr(a) ((void)SWIG_as_voidptr(*a),reinterpret_cast< void** >(a)) 


#include <stdexcept>


// used to set import/export for Cygwin DLLs
#ifdef WIN32
#define USING_OBDLL
#endif

#include <math.h>

#include <openbabel/obutil.h>
#include <openbabel/rand.h>
#include <openbabel/math/vector3.h>
#include <openbabel/math/matrix3x3.h>
#include <openbabel/generic.h>

#include <openbabel/base.h>
#include <openbabel/mol.h>
#include <openbabel/atom.h>
#include <openbabel/bond.h>
#include <openbabel/residue.h>
#include <openbabel/internalcoord.h>

#include <openbabel/ring.h>
#include <openbabel/obconversion.h>
#include <openbabel/oberror.h>
#include <openbabel/pluginiter.h>
#include <openbabel/fingerprint.h>

#include <openbabel/forcefield.h>

#include <openbabel/data.h>
#include <openbabel/parsmart.h>


#include <stdexcept>


#include <string>

#define SWIG_FLOAT_P(x) ((TYPE(x) == T_FLOAT) || FIXNUM_P(x))

bool SWIG_BOOL_P(VALUE) {
    // dummy test, RTEST should take care of everything
    return true;
}
bool SWIG_RB2BOOL(VALUE x) {
    return RTEST(x);
}
VALUE SWIG_BOOL2RB(bool b) {
    return b ? Qtrue : Qfalse;
}
double SWIG_NUM2DBL(VALUE x) {
    return (FIXNUM_P(x) ? FIX2INT(x) : NUM2DBL(x));
}
bool SWIG_STRING_P(VALUE x) {
    return TYPE(x) == T_STRING;
}
std::string SWIG_RB2STR(VALUE x) {
    return std::string(RSTRING_PTR(x), RSTRING_LEN(x));
}
VALUE SWIG_STR2RB(const std::string& s) {
    return rb_str_new(s.data(), s.size());
}


#include <map>
#include <algorithm>
#include <stdexcept>


#include <vector>
#include <algorithm>
#include <stdexcept>


#include <string>


#include <limits.h>
#ifndef LLONG_MIN
# define LLONG_MIN	LONG_LONG_MIN
#endif
#ifndef LLONG_MAX
# define LLONG_MAX	LONG_LONG_MAX
#endif
#ifndef ULLONG_MAX
# define ULLONG_MAX	ULONG_LONG_MAX
#endif


SWIGINTERN VALUE
SWIG_ruby_failed(void)
{
  return Qnil;
} 


/*@SWIG:%ruby_aux_method@*/
SWIGINTERN VALUE SWIG_AUX_NUM2ULONG(VALUE *args)
{
  VALUE obj = args[0];
  VALUE type = TYPE(obj);
  unsigned long *res = (unsigned long *)(args[1]);
  *res = type == T_FIXNUM ? NUM2ULONG(obj) : rb_big2ulong(obj);
  return obj;
}
/*@SWIG@*/

SWIGINTERN int
SWIG_AsVal_unsigned_SS_long (VALUE obj, unsigned long *val) 
{
  VALUE type = TYPE(obj);
  if ((type == T_FIXNUM) || (type == T_BIGNUM)) {
    unsigned long v;
    VALUE a[2];
    a[0] = obj;
    a[1] = (VALUE)(&v);
    if (rb_rescue(RUBY_METHOD_FUNC(SWIG_AUX_NUM2ULONG), (VALUE)a, RUBY_METHOD_FUNC(SWIG_ruby_failed), 0) != Qnil) {
      if (val) *val = v;
      return SWIG_OK;
    }
  }
  return SWIG_TypeError;
}


SWIGINTERN int
SWIG_AsVal_unsigned_SS_int (VALUE obj, unsigned int *val)
{
  unsigned long v;
  int res = SWIG_AsVal_unsigned_SS_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v > UINT_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = static_cast< unsigned int >(v);
    }
  }  
  return res;
}


/*@SWIG:%ruby_aux_method@*/
SWIGINTERN VALUE SWIG_AUX_NUM2LONG(VALUE *args)
{
  VALUE obj = args[0];
  VALUE type = TYPE(obj);
  long *res = (long *)(args[1]);
  *res = type == T_FIXNUM ? NUM2LONG(obj) : rb_big2long(obj);
  return obj;
}
/*@SWIG@*/

SWIGINTERN int
SWIG_AsVal_long (VALUE obj, long* val)
{
  VALUE type = TYPE(obj);
  if ((type == T_FIXNUM) || (type == T_BIGNUM)) {
    long v;
    VALUE a[2];
    a[0] = obj;
    a[1] = (VALUE)(&v);
    if (rb_rescue(RUBY_METHOD_FUNC(SWIG_AUX_NUM2LONG), (VALUE)a, RUBY_METHOD_FUNC(SWIG_ruby_failed), 0) != Qnil) {
      if (val) *val = v;
      return SWIG_OK;
    }
  }
  return SWIG_TypeError;
}


SWIGINTERN int
SWIG_AsVal_int (VALUE obj, int *val)
{
  long v;
  int res = SWIG_AsVal_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v < INT_MIN || v > INT_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = static_cast< int >(v);
    }
  }  
  return res;
}


  #define SWIG_From_long   LONG2NUM 


SWIGINTERNINLINE VALUE
SWIG_From_unsigned_SS_long  (unsigned long value)
{
  return ULONG2NUM(value); 
}


SWIGINTERNINLINE VALUE
SWIG_From_unsigned_SS_int  (unsigned int value)
{    
  return SWIG_From_unsigned_SS_long  (value);
}


SWIGINTERNINLINE VALUE
SWIG_From_bool  (bool value)
{
  return value ? Qtrue : Qfalse;
}

SWIGINTERN int std_vector_Sl_int_Sg__pop(std::vector<int > *self){
                if (self->size() == 0)
                    throw std::out_of_range("pop from empty vector");
                int x = self->back();
                self->pop_back();
                return x;
            }

SWIGINTERNINLINE VALUE
SWIG_From_int  (int value)
{    
  return SWIG_From_long  (value);
}

SWIGINTERN int std_vector_Sl_int_Sg____getitem__(std::vector<int > *self,int i){
                int size = int(self->size());
                if (i<0) i += size;
                if (i>=0 && i<size)
                    return (*self)[i];
                else
                    throw std::out_of_range("vector index out of range");
            }
SWIGINTERN void std_vector_Sl_int_Sg____setitem__(std::vector<int > *self,int i,int x){
                int size = int(self->size());
                if (i<0) i+= size;
                if (i>=0 && i<size)
                    (*self)[i] = x;
                else
                    throw std::out_of_range("vector index out of range");
            }
SWIGINTERN void std_vector_Sl_int_Sg__each(std::vector<int > *self){
                for (unsigned int i=0; i<self->size(); i++)
                    rb_yield(INT2NUM((*self)[i]));
            }
SWIGINTERN unsigned int std_vector_Sl_unsigned_SS_int_Sg__pop(std::vector<unsigned int > *self){
                if (self->size() == 0)
                    throw std::out_of_range("pop from empty vector");
                unsigned int x = self->back();
                self->pop_back();
                return x;
            }
SWIGINTERN unsigned int std_vector_Sl_unsigned_SS_int_Sg____getitem__(std::vector<unsigned int > *self,int i){
                int size = int(self->size());
                if (i<0) i += size;
                if (i>=0 && i<size)
                    return (*self)[i];
                else
                    throw std::out_of_range("vector index out of range");
            }
SWIGINTERN void std_vector_Sl_unsigned_SS_int_Sg____setitem__(std::vector<unsigned int > *self,int i,unsigned int x){
                int size = int(self->size());
                if (i<0) i+= size;
                if (i>=0 && i<size)
                    (*self)[i] = x;
                else
                    throw std::out_of_range("vector index out of range");
            }
SWIGINTERN void std_vector_Sl_unsigned_SS_int_Sg__each(std::vector<unsigned int > *self){
                for (unsigned int i=0; i<self->size(); i++)
                    rb_yield(INT2NUM((*self)[i]));
            }
SWIGINTERN std::vector<int > std_vector_Sl_std_vector_Sl_int_Sg__Sg__pop(std::vector<std::vector<int > > *self){
                if (self->size() == 0)
                    throw std::out_of_range("pop from empty vector");
                std::vector<int > x = self->back();
                self->pop_back();
                return x;
            }
SWIGINTERN std::vector<int > &std_vector_Sl_std_vector_Sl_int_Sg__Sg____getitem__(std::vector<std::vector<int > > *self,int i){
                int size = int(self->size());
                if (i<0) i += size;
                if (i>=0 && i<size)
                    return (*self)[i];
                else
                    throw std::out_of_range("vector index out of range");
            }
SWIGINTERN void std_vector_Sl_std_vector_Sl_int_Sg__Sg____setitem__(std::vector<std::vector<int > > *self,int i,std::vector<int > const &x){
                int size = int(self->size());
                if (i<0) i+= size;
                if (i>=0 && i<size)
                    (*self)[i] = x;
                else
                    throw std::out_of_range("vector index out of range");
            }
SWIGINTERN void std_vector_Sl_std_vector_Sl_int_Sg__Sg__each(std::vector<std::vector<int > > *self){
                for (unsigned int i=0; i<self->size(); i++) {
                    std::vector<int >* x = &((*self)[i]);
                    rb_yield(SWIG_NewPointerObj((void *) x, 
                                                SWIGTYPE_p_std__vectorTint_t, 0));
                }
            }

/*@SWIG:%ruby_aux_method@*/
SWIGINTERN VALUE SWIG_AUX_NUM2DBL(VALUE *args)
{
  VALUE obj = args[0];
  VALUE type = TYPE(obj);
  double *res = (double *)(args[1]);
  *res = (type == T_FLOAT ? NUM2DBL(obj) : (type == T_FIXNUM ? (double) FIX2INT(obj) : rb_big2dbl(obj)));
  return obj;
}
/*@SWIG@*/

SWIGINTERN int
SWIG_AsVal_double (VALUE obj, double *val)
{
  VALUE type = TYPE(obj);
  if ((type == T_FLOAT) || (type == T_FIXNUM) || (type == T_BIGNUM)) {
    double v;
    VALUE a[2];
    a[0] = obj;
    a[1] = (VALUE)(&v);
    if (rb_rescue(RUBY_METHOD_FUNC(SWIG_AUX_NUM2DBL), (VALUE)a, RUBY_METHOD_FUNC(SWIG_ruby_failed), 0) != Qnil) {
      if (val) *val = v;
      return SWIG_OK;
    }
  }
  return SWIG_TypeError;
}

SWIGINTERN double std_vector_Sl_double_Sg__pop(std::vector<double > *self){
                if (self->size() == 0)
                    throw std::out_of_range("pop from empty vector");
                double x = self->back();
                self->pop_back();
                return x;
            }

  #define SWIG_From_double   rb_float_new 

SWIGINTERN double std_vector_Sl_double_Sg____getitem__(std::vector<double > *self,int i){
                int size = int(self->size());
                if (i<0) i += size;
                if (i>=0 && i<size)
                    return (*self)[i];
                else
                    throw std::out_of_range("vector index out of range");
            }
SWIGINTERN void std_vector_Sl_double_Sg____setitem__(std::vector<double > *self,int i,double x){
                int size = int(self->size());
                if (i<0) i+= size;
                if (i>=0 && i<size)
                    (*self)[i] = x;
                else
                    throw std::out_of_range("vector index out of range");
            }
SWIGINTERN void std_vector_Sl_double_Sg__each(std::vector<double > *self){
                for (unsigned int i=0; i<self->size(); i++)
                    rb_yield(rb_float_new((*self)[i]));
            }
SWIGINTERN OpenBabel::vector3 std_vector_Sl_OpenBabel_vector3_Sg__pop(std::vector<OpenBabel::vector3 > *self){
                if (self->size() == 0)
                    throw std::out_of_range("pop from empty vector");
                OpenBabel::vector3 x = self->back();
                self->pop_back();
                return x;
            }
SWIGINTERN OpenBabel::vector3 &std_vector_Sl_OpenBabel_vector3_Sg____getitem__(std::vector<OpenBabel::vector3 > *self,int i){
                int size = int(self->size());
                if (i<0) i += size;
                if (i>=0 && i<size)
                    return (*self)[i];
                else
                    throw std::out_of_range("vector index out of range");
            }
SWIGINTERN void std_vector_Sl_OpenBabel_vector3_Sg____setitem__(std::vector<OpenBabel::vector3 > *self,int i,OpenBabel::vector3 const &x){
                int size = int(self->size());
                if (i<0) i+= size;
                if (i>=0 && i<size)
                    (*self)[i] = x;
                else
                    throw std::out_of_range("vector index out of range");
            }
SWIGINTERN void std_vector_Sl_OpenBabel_vector3_Sg__each(std::vector<OpenBabel::vector3 > *self){
                for (unsigned int i=0; i<self->size(); i++) {
                    OpenBabel::vector3* x = &((*self)[i]);
                    rb_yield(SWIG_NewPointerObj((void *) x, 
                                                SWIGTYPE_p_OpenBabel__vector3, 0));
                }
            }
SWIGINTERN OpenBabel::OBMol std_vector_Sl_OpenBabel_OBMol_Sg__pop(std::vector<OpenBabel::OBMol > *self){
                if (self->size() == 0)
                    throw std::out_of_range("pop from empty vector");
                OpenBabel::OBMol x = self->back();
                self->pop_back();
                return x;
            }
SWIGINTERN OpenBabel::OBMol &std_vector_Sl_OpenBabel_OBMol_Sg____getitem__(std::vector<OpenBabel::OBMol > *self,int i){
                int size = int(self->size());
                if (i<0) i += size;
                if (i>=0 && i<size)
                    return (*self)[i];
                else
                    throw std::out_of_range("vector index out of range");
            }
SWIGINTERN void std_vector_Sl_OpenBabel_OBMol_Sg____setitem__(std::vector<OpenBabel::OBMol > *self,int i,OpenBabel::OBMol const &x){
                int size = int(self->size());
                if (i<0) i+= size;
                if (i>=0 && i<size)
                    (*self)[i] = x;
                else
                    throw std::out_of_range("vector index out of range");
            }
SWIGINTERN void std_vector_Sl_OpenBabel_OBMol_Sg__each(std::vector<OpenBabel::OBMol > *self){
                for (unsigned int i=0; i<self->size(); i++) {
                    OpenBabel::OBMol* x = &((*self)[i]);
                    rb_yield(SWIG_NewPointerObj((void *) x, 
                                                SWIGTYPE_p_OpenBabel__OBMol, 0));
                }
            }
SWIGINTERN OpenBabel::OBBond std_vector_Sl_OpenBabel_OBBond_Sg__pop(std::vector<OpenBabel::OBBond > *self){
                if (self->size() == 0)
                    throw std::out_of_range("pop from empty vector");
                OpenBabel::OBBond x = self->back();
                self->pop_back();
                return x;
            }
SWIGINTERN OpenBabel::OBBond &std_vector_Sl_OpenBabel_OBBond_Sg____getitem__(std::vector<OpenBabel::OBBond > *self,int i){
                int size = int(self->size());
                if (i<0) i += size;
                if (i>=0 && i<size)
                    return (*self)[i];
                else
                    throw std::out_of_range("vector index out of range");
            }
SWIGINTERN void std_vector_Sl_OpenBabel_OBBond_Sg____setitem__(std::vector<OpenBabel::OBBond > *self,int i,OpenBabel::OBBond const &x){
                int size = int(self->size());
                if (i<0) i+= size;
                if (i>=0 && i<size)
                    (*self)[i] = x;
                else
                    throw std::out_of_range("vector index out of range");
            }
SWIGINTERN void std_vector_Sl_OpenBabel_OBBond_Sg__each(std::vector<OpenBabel::OBBond > *self){
                for (unsigned int i=0; i<self->size(); i++) {
                    OpenBabel::OBBond* x = &((*self)[i]);
                    rb_yield(SWIG_NewPointerObj((void *) x, 
                                                SWIGTYPE_p_OpenBabel__OBBond, 0));
                }
            }
SWIGINTERN OpenBabel::OBResidue std_vector_Sl_OpenBabel_OBResidue_Sg__pop(std::vector<OpenBabel::OBResidue > *self){
                if (self->size() == 0)
                    throw std::out_of_range("pop from empty vector");
                OpenBabel::OBResidue x = self->back();
                self->pop_back();
                return x;
            }
SWIGINTERN OpenBabel::OBResidue &std_vector_Sl_OpenBabel_OBResidue_Sg____getitem__(std::vector<OpenBabel::OBResidue > *self,int i){
                int size = int(self->size());
                if (i<0) i += size;
                if (i>=0 && i<size)
                    return (*self)[i];
                else
                    throw std::out_of_range("vector index out of range");
            }
SWIGINTERN void std_vector_Sl_OpenBabel_OBResidue_Sg____setitem__(std::vector<OpenBabel::OBResidue > *self,int i,OpenBabel::OBResidue const &x){
                int size = int(self->size());
                if (i<0) i+= size;
                if (i>=0 && i<size)
                    (*self)[i] = x;
                else
                    throw std::out_of_range("vector index out of range");
            }
SWIGINTERN void std_vector_Sl_OpenBabel_OBResidue_Sg__each(std::vector<OpenBabel::OBResidue > *self){
                for (unsigned int i=0; i<self->size(); i++) {
                    OpenBabel::OBResidue* x = &((*self)[i]);
                    rb_yield(SWIG_NewPointerObj((void *) x, 
                                                SWIGTYPE_p_OpenBabel__OBResidue, 0));
                }
            }
SWIGINTERN OpenBabel::OBRing std_vector_Sl_OpenBabel_OBRing_Sg__pop(std::vector<OpenBabel::OBRing > *self){
                if (self->size() == 0)
                    throw std::out_of_range("pop from empty vector");
                OpenBabel::OBRing x = self->back();
                self->pop_back();
                return x;
            }
SWIGINTERN OpenBabel::OBRing &std_vector_Sl_OpenBabel_OBRing_Sg____getitem__(std::vector<OpenBabel::OBRing > *self,int i){
                int size = int(self->size());
                if (i<0) i += size;
                if (i>=0 && i<size)
                    return (*self)[i];
                else
                    throw std::out_of_range("vector index out of range");
            }
SWIGINTERN void std_vector_Sl_OpenBabel_OBRing_Sg____setitem__(std::vector<OpenBabel::OBRing > *self,int i,OpenBabel::OBRing const &x){
                int size = int(self->size());
                if (i<0) i+= size;
                if (i>=0 && i<size)
                    (*self)[i] = x;
                else
                    throw std::out_of_range("vector index out of range");
            }
SWIGINTERN void std_vector_Sl_OpenBabel_OBRing_Sg__each(std::vector<OpenBabel::OBRing > *self){
                for (unsigned int i=0; i<self->size(); i++) {
                    OpenBabel::OBRing* x = &((*self)[i]);
                    rb_yield(SWIG_NewPointerObj((void *) x, 
                                                SWIGTYPE_p_OpenBabel__OBRing, 0));
                }
            }
SWIGINTERN OpenBabel::OBGenericData *std_vector_Sl_OpenBabel_OBGenericData_Sm__Sg__pop(std::vector<OpenBabel::OBGenericData * > *self){
                if (self->size() == 0)
                    throw std::out_of_range("pop from empty vector");
                OpenBabel::OBGenericData* x = self->back();
                self->pop_back();
                return x;
            }
SWIGINTERN OpenBabel::OBGenericData *std_vector_Sl_OpenBabel_OBGenericData_Sm__Sg____getitem__(std::vector<OpenBabel::OBGenericData * > *self,int i){
                int size = int(self->size());
                if (i<0) i += size;
                if (i>=0 && i<size)
                    return (*self)[i];
                else
                    throw std::out_of_range("vector index out of range");
            }
SWIGINTERN void std_vector_Sl_OpenBabel_OBGenericData_Sm__Sg____setitem__(std::vector<OpenBabel::OBGenericData * > *self,int i,OpenBabel::OBGenericData *x){
                int size = int(self->size());
                if (i<0) i+= size;
                if (i>=0 && i<size)
                    (*self)[i] = x;
                else
                    throw std::out_of_range("vector index out of range");
            }
SWIGINTERN void std_vector_Sl_OpenBabel_OBGenericData_Sm__Sg__each(std::vector<OpenBabel::OBGenericData * > *self){
                for (unsigned int i=0; i<self->size(); i++) {
                    OpenBabel::OBGenericData* x = (*self)[i];
                    rb_yield(SWIG_NewPointerObj((void *) x, 
                                                SWIGTYPE_p_OpenBabel__OBGenericData, 0));
                }
            }

SWIGINTERN swig_type_info*
SWIG_pchar_descriptor(void)
{
  static int init = 0;
  static swig_type_info* info = 0;
  if (!init) {
    info = SWIG_TypeQuery("_p_char");
    init = 1;
  }
  return info;
}


SWIGINTERN int
SWIG_AsCharPtrAndSize(VALUE obj, char** cptr, size_t* psize, int *alloc)
{
  if (TYPE(obj) == T_STRING) {
    


    char *cstr = STR2CSTR(obj);
    
    size_t size = RSTRING_LEN(obj) + 1;
    if (cptr)  {
      if (alloc) {
	if (*alloc == SWIG_NEWOBJ) {
	  *cptr = reinterpret_cast< char* >(memcpy((new char[size]), cstr, sizeof(char)*(size)));
	} else {
	  *cptr = cstr;
	  *alloc = SWIG_OLDOBJ;
	}
      }
    }
    if (psize) *psize = size;
    return SWIG_OK;
  } else {
    swig_type_info* pchar_descriptor = SWIG_pchar_descriptor();
    if (pchar_descriptor) {
      void* vptr = 0;
      if (SWIG_ConvertPtr(obj, &vptr, pchar_descriptor, 0) == SWIG_OK) {
	if (cptr) *cptr = (char *)vptr;
	if (psize) *psize = vptr ? (strlen((char*)vptr) + 1) : 0;
	if (alloc) *alloc = SWIG_OLDOBJ;
	return SWIG_OK;
      }
    }
  }  
  return SWIG_TypeError;
}





SWIGINTERN int
SWIG_AsPtr_std_string (VALUE obj, std::string **val) 
{
  char* buf = 0 ; size_t size = 0; int alloc = SWIG_OLDOBJ;
  if (SWIG_IsOK((SWIG_AsCharPtrAndSize(obj, &buf, &size, &alloc)))) {
    if (buf) {
      if (val) *val = new std::string(buf, size - 1);
      if (alloc == SWIG_NEWOBJ) delete[] buf;
      return SWIG_NEWOBJ;
    } else {
      if (val) *val = 0;
      return SWIG_OLDOBJ;
    }
  } else {
    static int init = 0;
    static swig_type_info* descriptor = 0;
    if (!init) {
      descriptor = SWIG_TypeQuery("std::string" " *");
      init = 1;
    }
    if (descriptor) {
      std::string *vptr;
      int res = SWIG_ConvertPtr(obj, (void**)&vptr, descriptor, 0);
      if (SWIG_IsOK(res) && val) *val = vptr;
      return res;
    }
  }
  return SWIG_ERROR;
}


SWIGINTERNINLINE VALUE 
SWIG_FromCharPtrAndSize(const char* carray, size_t size)
{
  if (carray) {
    if (size > LONG_MAX) {
      swig_type_info* pchar_descriptor = SWIG_pchar_descriptor();
      return pchar_descriptor ? 
	SWIG_NewPointerObj(const_cast< char * >(carray), pchar_descriptor, 0) : Qnil;
    } else {
      return rb_str_new(carray, static_cast< long >(size));
    }
  } else {
    return Qnil;
  }
}


SWIGINTERNINLINE VALUE 
SWIG_FromCharPtr(const char *cptr)
{ 
  return SWIG_FromCharPtrAndSize(cptr, (cptr ? strlen(cptr) : 0));
}


SWIGINTERNINLINE VALUE
SWIG_From_std_string  (const std::string& s)
{
  if (s.size()) {
    return SWIG_FromCharPtrAndSize(s.data(), s.size());
  } else {
    return SWIG_FromCharPtrAndSize(s.c_str(), 0);
  }
}


SWIGINTERN int
SWIG_AsVal_bool (VALUE obj, bool *val)
{
  if (obj == Qtrue) {
    if (val) *val = true;
    return SWIG_OK;
  } else if (obj == Qfalse) {
    if (val) *val = false;
    return SWIG_OK;
  } else {
    int res = 0;
    if (SWIG_AsVal_int (obj, &res) == SWIG_OK) {    
      if (val) *val = res ? true : false;
      return SWIG_OK;
    }
  }  
  return SWIG_TypeError;
}


SWIGINTERNINLINE VALUE
SWIG_From_size_t  (size_t value)
{    
  return SWIG_From_unsigned_SS_long  (static_cast< unsigned long >(value));
}


SWIGINTERN int
SWIG_AsCharArray(VALUE obj, char *val, size_t size)
{ 
  char* cptr = 0; size_t csize = 0; int alloc = SWIG_OLDOBJ;
  int res = SWIG_AsCharPtrAndSize(obj, &cptr, &csize, &alloc);
  if (SWIG_IsOK(res)) {
    if ((csize == size + 1) && cptr && !(cptr[csize-1])) --csize;
    if (csize <= size) {
      if (val) {
	if (csize) memcpy(val, cptr, csize*sizeof(char));
	if (csize < size) memset(val + csize, 0, (size - csize)*sizeof(char));
      }
      if (alloc == SWIG_NEWOBJ) {
	delete[] cptr;
	res = SWIG_DelNewMask(res);
      }      
      return res;
    }
    if (alloc == SWIG_NEWOBJ) delete[] cptr;
  }
  return SWIG_TypeError;
}


SWIGINTERN int
SWIG_AsVal_char (VALUE obj, char *val)
{    
  int res = SWIG_AsCharArray(obj, val, 1);
  if (!SWIG_IsOK(res)) {
    long v;
    res = SWIG_AddCast(SWIG_AsVal_long (obj, &v));
    if (SWIG_IsOK(res)) {
      if ((CHAR_MIN <= v) && (v <= CHAR_MAX)) {
	if (val) *val = static_cast< char >(v);
      } else {
	res = SWIG_OverflowError;
      }
    }
  }
  return res;
}


SWIGINTERNINLINE VALUE
SWIG_From_char  (char c) 
{ 
  return SWIG_FromCharPtrAndSize(&c,1);
}


SWIGINTERN int
SWIG_AsVal_short (VALUE obj, short *val)
{
  long v;
  int res = SWIG_AsVal_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v < SHRT_MIN || v > SHRT_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = static_cast< short >(v);
    }
  }  
  return res;
}


SWIGINTERNINLINE VALUE
SWIG_From_unsigned_SS_short  (unsigned short value)
{    
  return SWIG_From_unsigned_SS_long  (value);
}


SWIGINTERN int
SWIG_AsVal_unsigned_SS_short (VALUE obj, unsigned short *val)
{
  unsigned long v;
  int res = SWIG_AsVal_unsigned_SS_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v > USHRT_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = static_cast< unsigned short >(v);
    }
  }  
  return res;
}

swig_class cVectorInt;

SWIGINTERN VALUE
_wrap_new_vectorInt__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector<int > *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (std::vector<int > *)new std::vector<int >();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_vectorInt__SWIG_1(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  std::vector<int > *result = 0 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "std::vector<(int)>" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (std::vector<int > *)new std::vector<int >(arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_vectorInt__SWIG_2(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  int *arg2 = 0 ;
  std::vector<int > *result = 0 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  int temp2 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "std::vector<(int)>" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "std::vector<(int)>" "', argument " "2"" of type '" "int""'");
  } 
  temp2 = static_cast< int >(val2);
  arg2 = &temp2;
  result = (std::vector<int > *)new std::vector<int >(arg1,(int const &)*arg2);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_vectorInt_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_vectorInt_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_std__vectorTint_t);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_vectorInt__SWIG_3(int argc, VALUE *argv, VALUE self) {
  std::vector<int > *arg1 = 0 ;
  std::vector<int > *result = 0 ;
  std::vector<int > temp1 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
      unsigned int size = RARRAY_LEN(argv[0]);
      temp1 = std::vector<int >(size);
      arg1 = &temp1;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(argv[0])[i];
        if (FIXNUM_P(o))
        temp1[i] = (int)(FIX2INT(o));
        else
        rb_raise(rb_eTypeError,
          "wrong argument type"
          " (expected vector<""int" ">)");
      }
    } else {
      SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_std__vectorTint_t, 1);
    }
  }
  result = (std::vector<int > *)new std::vector<int >((std::vector<int > const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_vectorInt(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_vectorInt__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_vectorInt__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    {
      /* native sequence? */
      if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
        unsigned int size = RARRAY_LEN(argv[0]);
        if (size == 0) {
          /* an empty sequence can be of any type */
          _v = 1;
        } else {
          /* check the first element only */
          VALUE o = RARRAY_PTR(argv[0])[0];
          if (FIXNUM_P(o))
          _v = 1;
          else
          _v = 0;
        }
      } else {
        /* wrapped vector? */
        std::vector<int >* v;
        if (SWIG_ConvertPtr(argv[0],(void **) &v, 
            SWIGTYPE_p_std__vectorTint_t,0) != -1)
        _v = 1;
        else
        _v = 0;
      }
    }
    if (_v) {
      return _wrap_new_vectorInt__SWIG_3(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_vectorInt__SWIG_2(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_vectorInt'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorInt___len__(int argc, VALUE *argv, VALUE self) {
  std::vector<int > *arg1 = (std::vector<int > *) 0 ;
  unsigned int result;
  std::vector<int > temp1 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if (rb_obj_is_kind_of(self,rb_cArray)) {
      unsigned int size = RARRAY_LEN(self);
      temp1 = std::vector<int >(size);
      arg1 = &temp1;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(self)[i];
        if (FIXNUM_P(o))
        temp1[i] = (int)(FIX2INT(o));
        else
        rb_raise(rb_eTypeError,
          "wrong argument type"
          " (expected vector<""int" ">)");
      }
    } else {
      SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTint_t, 1);
    }
  }
  result = (unsigned int)((std::vector<int > const *)arg1)->size();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorInt_emptyq___(int argc, VALUE *argv, VALUE self) {
  std::vector<int > *arg1 = (std::vector<int > *) 0 ;
  bool result;
  std::vector<int > temp1 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if (rb_obj_is_kind_of(self,rb_cArray)) {
      unsigned int size = RARRAY_LEN(self);
      temp1 = std::vector<int >(size);
      arg1 = &temp1;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(self)[i];
        if (FIXNUM_P(o))
        temp1[i] = (int)(FIX2INT(o));
        else
        rb_raise(rb_eTypeError,
          "wrong argument type"
          " (expected vector<""int" ">)");
      }
    } else {
      SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTint_t, 1);
    }
  }
  result = (bool)((std::vector<int > const *)arg1)->empty();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorInt_clear(int argc, VALUE *argv, VALUE self) {
  std::vector<int > *arg1 = (std::vector<int > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTint_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "clear" "', argument " "1"" of type '" "std::vector<int > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<int > * >(argp1);
  (arg1)->clear();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorInt_push(int argc, VALUE *argv, VALUE self) {
  std::vector<int > *arg1 = (std::vector<int > *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTint_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "push_back" "', argument " "1"" of type '" "std::vector<int > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<int > * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "push_back" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->push_back(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorInt_pop(int argc, VALUE *argv, VALUE self) {
  std::vector<int > *arg1 = (std::vector<int > *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTint_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "pop" "', argument " "1"" of type '" "std::vector<int > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<int > * >(argp1);
  try {
    result = (int)std_vector_Sl_int_Sg__pop(arg1);
  }
  catch(std::out_of_range &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_std__out_of_range, SWIG_NewPointerObj((new std::out_of_range(static_cast< const std::out_of_range& >(_e))),SWIGTYPE_p_std__out_of_range,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorInt___getitem__(int argc, VALUE *argv, VALUE self) {
  std::vector<int > *arg1 = (std::vector<int > *) 0 ;
  int arg2 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTint_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "__getitem__" "', argument " "1"" of type '" "std::vector<int > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<int > * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "__getitem__" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  try {
    result = (int)std_vector_Sl_int_Sg____getitem__(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_std__out_of_range, SWIG_NewPointerObj((new std::out_of_range(static_cast< const std::out_of_range& >(_e))),SWIGTYPE_p_std__out_of_range,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorInt___setitem__(int argc, VALUE *argv, VALUE self) {
  std::vector<int > *arg1 = (std::vector<int > *) 0 ;
  int arg2 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTint_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "__setitem__" "', argument " "1"" of type '" "std::vector<int > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<int > * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "__setitem__" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "__setitem__" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  try {
    std_vector_Sl_int_Sg____setitem__(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_std__out_of_range, SWIG_NewPointerObj((new std::out_of_range(static_cast< const std::out_of_range& >(_e))),SWIGTYPE_p_std__out_of_range,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorInt_each(int argc, VALUE *argv, VALUE self) {
  std::vector<int > *arg1 = (std::vector<int > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTint_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "each" "', argument " "1"" of type '" "std::vector<int > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<int > * >(argp1);
  std_vector_Sl_int_Sg__each(arg1);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN void
free_std_vector_Sl_int_Sg_(std::vector<int > *arg1) {
    delete arg1;
}

swig_class cVectorUnsignedInt;

SWIGINTERN VALUE
_wrap_new_vectorUnsignedInt__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector<unsigned int > *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (std::vector<unsigned int > *)new std::vector<unsigned int >();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_vectorUnsignedInt__SWIG_1(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  std::vector<unsigned int > *result = 0 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "std::vector<(unsigned int)>" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (std::vector<unsigned int > *)new std::vector<unsigned int >(arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_vectorUnsignedInt__SWIG_2(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int *arg2 = 0 ;
  std::vector<unsigned int > *result = 0 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int temp2 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "std::vector<(unsigned int)>" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "std::vector<(unsigned int)>" "', argument " "2"" of type '" "unsigned int""'");
  } 
  temp2 = static_cast< unsigned int >(val2);
  arg2 = &temp2;
  result = (std::vector<unsigned int > *)new std::vector<unsigned int >(arg1,(unsigned int const &)*arg2);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_vectorUnsignedInt_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_vectorUnsignedInt_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_std__vectorTunsigned_int_t);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_vectorUnsignedInt__SWIG_3(int argc, VALUE *argv, VALUE self) {
  std::vector<unsigned int > *arg1 = 0 ;
  std::vector<unsigned int > *result = 0 ;
  std::vector<unsigned int > temp1 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
      unsigned int size = RARRAY_LEN(argv[0]);
      temp1 = std::vector<unsigned int >(size);
      arg1 = &temp1;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(argv[0])[i];
        if (FIXNUM_P(o))
        temp1[i] = (unsigned int)(FIX2INT(o));
        else
        rb_raise(rb_eTypeError,
          "wrong argument type"
          " (expected vector<""unsigned int" ">)");
      }
    } else {
      SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_std__vectorTunsigned_int_t, 1);
    }
  }
  result = (std::vector<unsigned int > *)new std::vector<unsigned int >((std::vector<unsigned int > const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_vectorUnsignedInt(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_vectorUnsignedInt__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_vectorUnsignedInt__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    {
      /* native sequence? */
      if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
        unsigned int size = RARRAY_LEN(argv[0]);
        if (size == 0) {
          /* an empty sequence can be of any type */
          _v = 1;
        } else {
          /* check the first element only */
          VALUE o = RARRAY_PTR(argv[0])[0];
          if (FIXNUM_P(o))
          _v = 1;
          else
          _v = 0;
        }
      } else {
        /* wrapped vector? */
        std::vector<unsigned int >* v;
        if (SWIG_ConvertPtr(argv[0],(void **) &v, 
            SWIGTYPE_p_std__vectorTunsigned_int_t,0) != -1)
        _v = 1;
        else
        _v = 0;
      }
    }
    if (_v) {
      return _wrap_new_vectorUnsignedInt__SWIG_3(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_vectorUnsignedInt__SWIG_2(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_vectorUnsignedInt'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorUnsignedInt___len__(int argc, VALUE *argv, VALUE self) {
  std::vector<unsigned int > *arg1 = (std::vector<unsigned int > *) 0 ;
  unsigned int result;
  std::vector<unsigned int > temp1 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if (rb_obj_is_kind_of(self,rb_cArray)) {
      unsigned int size = RARRAY_LEN(self);
      temp1 = std::vector<unsigned int >(size);
      arg1 = &temp1;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(self)[i];
        if (FIXNUM_P(o))
        temp1[i] = (unsigned int)(FIX2INT(o));
        else
        rb_raise(rb_eTypeError,
          "wrong argument type"
          " (expected vector<""unsigned int" ">)");
      }
    } else {
      SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTunsigned_int_t, 1);
    }
  }
  result = (unsigned int)((std::vector<unsigned int > const *)arg1)->size();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorUnsignedInt_emptyq___(int argc, VALUE *argv, VALUE self) {
  std::vector<unsigned int > *arg1 = (std::vector<unsigned int > *) 0 ;
  bool result;
  std::vector<unsigned int > temp1 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if (rb_obj_is_kind_of(self,rb_cArray)) {
      unsigned int size = RARRAY_LEN(self);
      temp1 = std::vector<unsigned int >(size);
      arg1 = &temp1;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(self)[i];
        if (FIXNUM_P(o))
        temp1[i] = (unsigned int)(FIX2INT(o));
        else
        rb_raise(rb_eTypeError,
          "wrong argument type"
          " (expected vector<""unsigned int" ">)");
      }
    } else {
      SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTunsigned_int_t, 1);
    }
  }
  result = (bool)((std::vector<unsigned int > const *)arg1)->empty();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorUnsignedInt_clear(int argc, VALUE *argv, VALUE self) {
  std::vector<unsigned int > *arg1 = (std::vector<unsigned int > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTunsigned_int_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "clear" "', argument " "1"" of type '" "std::vector<unsigned int > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<unsigned int > * >(argp1);
  (arg1)->clear();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorUnsignedInt_push(int argc, VALUE *argv, VALUE self) {
  std::vector<unsigned int > *arg1 = (std::vector<unsigned int > *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTunsigned_int_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "push_back" "', argument " "1"" of type '" "std::vector<unsigned int > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<unsigned int > * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "push_back" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  (arg1)->push_back(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorUnsignedInt_pop(int argc, VALUE *argv, VALUE self) {
  std::vector<unsigned int > *arg1 = (std::vector<unsigned int > *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTunsigned_int_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "pop" "', argument " "1"" of type '" "std::vector<unsigned int > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<unsigned int > * >(argp1);
  try {
    result = (unsigned int)std_vector_Sl_unsigned_SS_int_Sg__pop(arg1);
  }
  catch(std::out_of_range &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_std__out_of_range, SWIG_NewPointerObj((new std::out_of_range(static_cast< const std::out_of_range& >(_e))),SWIGTYPE_p_std__out_of_range,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorUnsignedInt___getitem__(int argc, VALUE *argv, VALUE self) {
  std::vector<unsigned int > *arg1 = (std::vector<unsigned int > *) 0 ;
  int arg2 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTunsigned_int_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "__getitem__" "', argument " "1"" of type '" "std::vector<unsigned int > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<unsigned int > * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "__getitem__" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  try {
    result = (unsigned int)std_vector_Sl_unsigned_SS_int_Sg____getitem__(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_std__out_of_range, SWIG_NewPointerObj((new std::out_of_range(static_cast< const std::out_of_range& >(_e))),SWIGTYPE_p_std__out_of_range,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorUnsignedInt___setitem__(int argc, VALUE *argv, VALUE self) {
  std::vector<unsigned int > *arg1 = (std::vector<unsigned int > *) 0 ;
  int arg2 ;
  unsigned int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTunsigned_int_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "__setitem__" "', argument " "1"" of type '" "std::vector<unsigned int > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<unsigned int > * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "__setitem__" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "__setitem__" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  try {
    std_vector_Sl_unsigned_SS_int_Sg____setitem__(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_std__out_of_range, SWIG_NewPointerObj((new std::out_of_range(static_cast< const std::out_of_range& >(_e))),SWIGTYPE_p_std__out_of_range,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorUnsignedInt_each(int argc, VALUE *argv, VALUE self) {
  std::vector<unsigned int > *arg1 = (std::vector<unsigned int > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTunsigned_int_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "each" "', argument " "1"" of type '" "std::vector<unsigned int > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<unsigned int > * >(argp1);
  std_vector_Sl_unsigned_SS_int_Sg__each(arg1);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN void
free_std_vector_Sl_unsigned_SS_int_Sg_(std::vector<unsigned int > *arg1) {
    delete arg1;
}

swig_class cVvInt;

SWIGINTERN VALUE
_wrap_new_vvInt__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector<std::vector<int > > *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (std::vector<std::vector<int > > *)new std::vector<std::vector<int > >();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_vvInt__SWIG_1(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  std::vector<std::vector<int > > *result = 0 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "std::vector<(std::vector<(int)>)>" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (std::vector<std::vector<int > > *)new std::vector<std::vector<int > >(arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_vvInt__SWIG_2(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  std::vector<int > *arg2 = 0 ;
  std::vector<std::vector<int > > *result = 0 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  std::vector<int > temp2 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "std::vector<(std::vector<(int)>)>" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  {
    if (rb_obj_is_kind_of(argv[1],rb_cArray)) {
      unsigned int size = RARRAY_LEN(argv[1]);
      temp2 = std::vector<int >(size);
      arg2 = &temp2;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(argv[1])[i];
        if (FIXNUM_P(o))
        temp2[i] = (int)(FIX2INT(o));
        else
        rb_raise(rb_eTypeError,
          "wrong argument type"
          " (expected vector<""int" ">)");
      }
    } else {
      SWIG_ConvertPtr(argv[1], (void **) &arg2, SWIGTYPE_p_std__vectorTint_t, 1);
    }
  }
  result = (std::vector<std::vector<int > > *)new std::vector<std::vector<int > >(arg1,(std::vector<int > const &)*arg2);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_vvInt_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_vvInt_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_std__vectorTstd__vectorTint_t_t);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_vvInt__SWIG_3(int argc, VALUE *argv, VALUE self) {
  std::vector<std::vector<int > > *arg1 = 0 ;
  std::vector<std::vector<int > > *result = 0 ;
  std::vector<std::vector<int > > temp1 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
      unsigned int size = RARRAY_LEN(argv[0]);
      arg1 = &temp1;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(argv[0])[i];
        std::vector<int >* x;
        SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_std__vectorTint_t, 1);
        temp1.push_back(*x);
      }
    } else {
      SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_std__vectorTstd__vectorTint_t_t, 1);
    }
  }
  result = (std::vector<std::vector<int > > *)new std::vector<std::vector<int > >((std::vector<std::vector<int > > const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_vvInt(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_vvInt__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_vvInt__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    {
      /* native sequence? */
      if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
        unsigned int size = RARRAY_LEN(argv[0]);
        if (size == 0) {
          /* an empty sequence can be of any type */
          _v = 1;
        } else {
          /* check the first element only */
          std::vector<int >* x;
          VALUE o = RARRAY_PTR(argv[0])[0];
          if ((SWIG_ConvertPtr(o,(void **) &x, 
                SWIGTYPE_p_std__vectorTint_t,0)) != -1)
          _v = 1;
          else
          _v = 0;
        }
      } else {
        /* wrapped vector? */
        std::vector<std::vector<int > >* v;
        if (SWIG_ConvertPtr(argv[0],(void **) &v, 
            SWIGTYPE_p_std__vectorTstd__vectorTint_t_t,0) != -1)
        _v = 1;
        else
        _v = 0;
      }
    }
    if (_v) {
      return _wrap_new_vvInt__SWIG_3(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        /* native sequence? */
        if (rb_obj_is_kind_of(argv[1],rb_cArray)) {
          unsigned int size = RARRAY_LEN(argv[1]);
          if (size == 0) {
            /* an empty sequence can be of any type */
            _v = 1;
          } else {
            /* check the first element only */
            VALUE o = RARRAY_PTR(argv[1])[0];
            if (FIXNUM_P(o))
            _v = 1;
            else
            _v = 0;
          }
        } else {
          /* wrapped vector? */
          std::vector<int >* v;
          if (SWIG_ConvertPtr(argv[1],(void **) &v, 
              SWIGTYPE_p_std__vectorTint_t,0) != -1)
          _v = 1;
          else
          _v = 0;
        }
      }
      if (_v) {
        return _wrap_new_vvInt__SWIG_2(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_vvInt'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vvInt_size(int argc, VALUE *argv, VALUE self) {
  std::vector<std::vector<int > > *arg1 = (std::vector<std::vector<int > > *) 0 ;
  unsigned int result;
  std::vector<std::vector<int > > temp1 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if (rb_obj_is_kind_of(self,rb_cArray)) {
      unsigned int size = RARRAY_LEN(self);
      arg1 = &temp1;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(self)[i];
        std::vector<int >* x;
        SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_std__vectorTint_t, 1);
        temp1.push_back(*x);
      }
    } else {
      SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTstd__vectorTint_t_t, 1);
    }
  }
  result = (unsigned int)((std::vector<std::vector<int > > const *)arg1)->size();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vvInt_empty(int argc, VALUE *argv, VALUE self) {
  std::vector<std::vector<int > > *arg1 = (std::vector<std::vector<int > > *) 0 ;
  bool result;
  std::vector<std::vector<int > > temp1 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if (rb_obj_is_kind_of(self,rb_cArray)) {
      unsigned int size = RARRAY_LEN(self);
      arg1 = &temp1;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(self)[i];
        std::vector<int >* x;
        SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_std__vectorTint_t, 1);
        temp1.push_back(*x);
      }
    } else {
      SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTstd__vectorTint_t_t, 1);
    }
  }
  result = (bool)((std::vector<std::vector<int > > const *)arg1)->empty();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vvInt_clear(int argc, VALUE *argv, VALUE self) {
  std::vector<std::vector<int > > *arg1 = (std::vector<std::vector<int > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTstd__vectorTint_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "clear" "', argument " "1"" of type '" "std::vector<std::vector<int > > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<std::vector<int > > * >(argp1);
  (arg1)->clear();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vvInt_push_back(int argc, VALUE *argv, VALUE self) {
  std::vector<std::vector<int > > *arg1 = (std::vector<std::vector<int > > *) 0 ;
  std::vector<int > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector<int > temp2 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTstd__vectorTint_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "push_back" "', argument " "1"" of type '" "std::vector<std::vector<int > > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<std::vector<int > > * >(argp1);
  {
    if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
      unsigned int size = RARRAY_LEN(argv[0]);
      temp2 = std::vector<int >(size);
      arg2 = &temp2;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(argv[0])[i];
        if (FIXNUM_P(o))
        temp2[i] = (int)(FIX2INT(o));
        else
        rb_raise(rb_eTypeError,
          "wrong argument type"
          " (expected vector<""int" ">)");
      }
    } else {
      SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_std__vectorTint_t, 1);
    }
  }
  (arg1)->push_back((std::vector<int > const &)*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vvInt_pop(int argc, VALUE *argv, VALUE self) {
  std::vector<std::vector<int > > *arg1 = (std::vector<std::vector<int > > *) 0 ;
  std::vector<int > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTstd__vectorTint_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "pop" "', argument " "1"" of type '" "std::vector<std::vector<int > > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<std::vector<int > > * >(argp1);
  try {
    result = std_vector_Sl_std_vector_Sl_int_Sg__Sg__pop(arg1);
  }
  catch(std::out_of_range &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_std__out_of_range, SWIG_NewPointerObj((new std::out_of_range(static_cast< const std::out_of_range& >(_e))),SWIGTYPE_p_std__out_of_range,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  {
    vresult = rb_ary_new2((&result)->size());
    for (unsigned int i=0; i<(&result)->size(); i++)
    rb_ary_store(vresult,i,INT2NUM(((std::vector<int > &)result)[i]));
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vvInt___getitem__(int argc, VALUE *argv, VALUE self) {
  std::vector<std::vector<int > > *arg1 = (std::vector<std::vector<int > > *) 0 ;
  int arg2 ;
  std::vector<int > *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTstd__vectorTint_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "__getitem__" "', argument " "1"" of type '" "std::vector<std::vector<int > > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<std::vector<int > > * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "__getitem__" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  try {
    {
      std::vector<int > &_result_ref = std_vector_Sl_std_vector_Sl_int_Sg__Sg____getitem__(arg1,arg2);
      result = (std::vector<int > *) &_result_ref;
    }
  }
  catch(std::out_of_range &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_std__out_of_range, SWIG_NewPointerObj((new std::out_of_range(static_cast< const std::out_of_range& >(_e))),SWIGTYPE_p_std__out_of_range,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorTint_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vvInt___setitem__(int argc, VALUE *argv, VALUE self) {
  std::vector<std::vector<int > > *arg1 = (std::vector<std::vector<int > > *) 0 ;
  int arg2 ;
  std::vector<int > *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  std::vector<int > temp3 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTstd__vectorTint_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "__setitem__" "', argument " "1"" of type '" "std::vector<std::vector<int > > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<std::vector<int > > * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "__setitem__" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  {
    if (rb_obj_is_kind_of(argv[1],rb_cArray)) {
      unsigned int size = RARRAY_LEN(argv[1]);
      temp3 = std::vector<int >(size);
      arg3 = &temp3;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(argv[1])[i];
        if (FIXNUM_P(o))
        temp3[i] = (int)(FIX2INT(o));
        else
        rb_raise(rb_eTypeError,
          "wrong argument type"
          " (expected vector<""int" ">)");
      }
    } else {
      SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_std__vectorTint_t, 1);
    }
  }
  try {
    std_vector_Sl_std_vector_Sl_int_Sg__Sg____setitem__(arg1,arg2,(std::vector<int > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_std__out_of_range, SWIG_NewPointerObj((new std::out_of_range(static_cast< const std::out_of_range& >(_e))),SWIGTYPE_p_std__out_of_range,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vvInt_each(int argc, VALUE *argv, VALUE self) {
  std::vector<std::vector<int > > *arg1 = (std::vector<std::vector<int > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTstd__vectorTint_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "each" "', argument " "1"" of type '" "std::vector<std::vector<int > > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<std::vector<int > > * >(argp1);
  std_vector_Sl_std_vector_Sl_int_Sg__Sg__each(arg1);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN void
free_std_vector_Sl_std_vector_Sl_int_Sg__Sg_(std::vector<std::vector<int > > *arg1) {
    delete arg1;
}

swig_class cVectorDouble;

SWIGINTERN VALUE
_wrap_new_vectorDouble__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector<double > *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (std::vector<double > *)new std::vector<double >();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_vectorDouble__SWIG_1(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  std::vector<double > *result = 0 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "std::vector<(double)>" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (std::vector<double > *)new std::vector<double >(arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_vectorDouble__SWIG_2(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  double *arg2 = 0 ;
  std::vector<double > *result = 0 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  double temp2 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "std::vector<(double)>" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_double(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "std::vector<(double)>" "', argument " "2"" of type '" "double""'");
  } 
  temp2 = static_cast< double >(val2);
  arg2 = &temp2;
  result = (std::vector<double > *)new std::vector<double >(arg1,(double const &)*arg2);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_vectorDouble_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_vectorDouble_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_std__vectorTdouble_t);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_vectorDouble__SWIG_3(int argc, VALUE *argv, VALUE self) {
  std::vector<double > *arg1 = 0 ;
  std::vector<double > *result = 0 ;
  std::vector<double > temp1 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
      unsigned int size = RARRAY_LEN(argv[0]);
      temp1 = std::vector<double >(size);
      arg1 = &temp1;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(argv[0])[i];
        if (SWIG_FLOAT_P(o))
        temp1[i] = (double)(SWIG_NUM2DBL(o));
        else
        rb_raise(rb_eTypeError,
          "wrong argument type"
          " (expected vector<""double" ">)");
      }
    } else {
      SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_std__vectorTdouble_t, 1);
    }
  }
  result = (std::vector<double > *)new std::vector<double >((std::vector<double > const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_vectorDouble(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_vectorDouble__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_vectorDouble__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    {
      /* native sequence? */
      if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
        unsigned int size = RARRAY_LEN(argv[0]);
        if (size == 0) {
          /* an empty sequence can be of any type */
          _v = 1;
        } else {
          /* check the first element only */
          VALUE o = RARRAY_PTR(argv[0])[0];
          if (SWIG_FLOAT_P(o))
          _v = 1;
          else
          _v = 0;
        }
      } else {
        /* wrapped vector? */
        std::vector<double >* v;
        if (SWIG_ConvertPtr(argv[0],(void **) &v, 
            SWIGTYPE_p_std__vectorTdouble_t,0) != -1)
        _v = 1;
        else
        _v = 0;
      }
    }
    if (_v) {
      return _wrap_new_vectorDouble__SWIG_3(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_vectorDouble__SWIG_2(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_vectorDouble'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorDouble___len__(int argc, VALUE *argv, VALUE self) {
  std::vector<double > *arg1 = (std::vector<double > *) 0 ;
  unsigned int result;
  std::vector<double > temp1 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if (rb_obj_is_kind_of(self,rb_cArray)) {
      unsigned int size = RARRAY_LEN(self);
      temp1 = std::vector<double >(size);
      arg1 = &temp1;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(self)[i];
        if (SWIG_FLOAT_P(o))
        temp1[i] = (double)(SWIG_NUM2DBL(o));
        else
        rb_raise(rb_eTypeError,
          "wrong argument type"
          " (expected vector<""double" ">)");
      }
    } else {
      SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTdouble_t, 1);
    }
  }
  result = (unsigned int)((std::vector<double > const *)arg1)->size();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorDouble_emptyq___(int argc, VALUE *argv, VALUE self) {
  std::vector<double > *arg1 = (std::vector<double > *) 0 ;
  bool result;
  std::vector<double > temp1 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if (rb_obj_is_kind_of(self,rb_cArray)) {
      unsigned int size = RARRAY_LEN(self);
      temp1 = std::vector<double >(size);
      arg1 = &temp1;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(self)[i];
        if (SWIG_FLOAT_P(o))
        temp1[i] = (double)(SWIG_NUM2DBL(o));
        else
        rb_raise(rb_eTypeError,
          "wrong argument type"
          " (expected vector<""double" ">)");
      }
    } else {
      SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTdouble_t, 1);
    }
  }
  result = (bool)((std::vector<double > const *)arg1)->empty();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorDouble_clear(int argc, VALUE *argv, VALUE self) {
  std::vector<double > *arg1 = (std::vector<double > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTdouble_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "clear" "', argument " "1"" of type '" "std::vector<double > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<double > * >(argp1);
  (arg1)->clear();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorDouble_push(int argc, VALUE *argv, VALUE self) {
  std::vector<double > *arg1 = (std::vector<double > *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTdouble_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "push_back" "', argument " "1"" of type '" "std::vector<double > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<double > * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "push_back" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  (arg1)->push_back(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorDouble_pop(int argc, VALUE *argv, VALUE self) {
  std::vector<double > *arg1 = (std::vector<double > *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTdouble_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "pop" "', argument " "1"" of type '" "std::vector<double > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<double > * >(argp1);
  try {
    result = (double)std_vector_Sl_double_Sg__pop(arg1);
  }
  catch(std::out_of_range &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_std__out_of_range, SWIG_NewPointerObj((new std::out_of_range(static_cast< const std::out_of_range& >(_e))),SWIGTYPE_p_std__out_of_range,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorDouble___getitem__(int argc, VALUE *argv, VALUE self) {
  std::vector<double > *arg1 = (std::vector<double > *) 0 ;
  int arg2 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTdouble_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "__getitem__" "', argument " "1"" of type '" "std::vector<double > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<double > * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "__getitem__" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  try {
    result = (double)std_vector_Sl_double_Sg____getitem__(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_std__out_of_range, SWIG_NewPointerObj((new std::out_of_range(static_cast< const std::out_of_range& >(_e))),SWIGTYPE_p_std__out_of_range,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorDouble___setitem__(int argc, VALUE *argv, VALUE self) {
  std::vector<double > *arg1 = (std::vector<double > *) 0 ;
  int arg2 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTdouble_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "__setitem__" "', argument " "1"" of type '" "std::vector<double > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<double > * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "__setitem__" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_double(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "__setitem__" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  try {
    std_vector_Sl_double_Sg____setitem__(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_std__out_of_range, SWIG_NewPointerObj((new std::out_of_range(static_cast< const std::out_of_range& >(_e))),SWIGTYPE_p_std__out_of_range,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorDouble_each(int argc, VALUE *argv, VALUE self) {
  std::vector<double > *arg1 = (std::vector<double > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTdouble_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "each" "', argument " "1"" of type '" "std::vector<double > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<double > * >(argp1);
  std_vector_Sl_double_Sg__each(arg1);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN void
free_std_vector_Sl_double_Sg_(std::vector<double > *arg1) {
    delete arg1;
}

swig_class cVVector3;

SWIGINTERN VALUE
_wrap_new_vVector3__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::vector3 > *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (std::vector<OpenBabel::vector3 > *)new std::vector<OpenBabel::vector3 >();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_vVector3__SWIG_1(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  std::vector<OpenBabel::vector3 > *result = 0 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "std::vector<(OpenBabel::vector3)>" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (std::vector<OpenBabel::vector3 > *)new std::vector<OpenBabel::vector3 >(arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_vVector3__SWIG_2(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  OpenBabel::vector3 *arg2 = 0 ;
  std::vector<OpenBabel::vector3 > *result = 0 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "std::vector<(OpenBabel::vector3)>" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "std::vector<(OpenBabel::vector3)>" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "std::vector<(OpenBabel::vector3)>" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  result = (std::vector<OpenBabel::vector3 > *)new std::vector<OpenBabel::vector3 >(arg1,(OpenBabel::vector3 const &)*arg2);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_vVector3_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_vVector3_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_std__vectorTOpenBabel__vector3_t);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_vVector3__SWIG_3(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::vector3 > *arg1 = 0 ;
  std::vector<OpenBabel::vector3 > *result = 0 ;
  std::vector<OpenBabel::vector3 > temp1 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
      unsigned int size = RARRAY_LEN(argv[0]);
      arg1 = &temp1;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(argv[0])[i];
        OpenBabel::vector3* x;
        SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_OpenBabel__vector3, 1);
        temp1.push_back(*x);
      }
    } else {
      SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_std__vectorTOpenBabel__vector3_t, 1);
    }
  }
  result = (std::vector<OpenBabel::vector3 > *)new std::vector<OpenBabel::vector3 >((std::vector<OpenBabel::vector3 > const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_vVector3(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_vVector3__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_vVector3__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    {
      /* native sequence? */
      if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
        unsigned int size = RARRAY_LEN(argv[0]);
        if (size == 0) {
          /* an empty sequence can be of any type */
          _v = 1;
        } else {
          /* check the first element only */
          OpenBabel::vector3* x;
          VALUE o = RARRAY_PTR(argv[0])[0];
          if ((SWIG_ConvertPtr(o,(void **) &x, 
                SWIGTYPE_p_OpenBabel__vector3,0)) != -1)
          _v = 1;
          else
          _v = 0;
        }
      } else {
        /* wrapped vector? */
        std::vector<OpenBabel::vector3 >* v;
        if (SWIG_ConvertPtr(argv[0],(void **) &v, 
            SWIGTYPE_p_std__vectorTOpenBabel__vector3_t,0) != -1)
        _v = 1;
        else
        _v = 0;
      }
    }
    if (_v) {
      return _wrap_new_vVector3__SWIG_3(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__vector3, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_vVector3__SWIG_2(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_vVector3'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vVector3_size(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::vector3 > *arg1 = (std::vector<OpenBabel::vector3 > *) 0 ;
  unsigned int result;
  std::vector<OpenBabel::vector3 > temp1 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if (rb_obj_is_kind_of(self,rb_cArray)) {
      unsigned int size = RARRAY_LEN(self);
      arg1 = &temp1;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(self)[i];
        OpenBabel::vector3* x;
        SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_OpenBabel__vector3, 1);
        temp1.push_back(*x);
      }
    } else {
      SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTOpenBabel__vector3_t, 1);
    }
  }
  result = (unsigned int)((std::vector<OpenBabel::vector3 > const *)arg1)->size();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vVector3_empty(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::vector3 > *arg1 = (std::vector<OpenBabel::vector3 > *) 0 ;
  bool result;
  std::vector<OpenBabel::vector3 > temp1 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if (rb_obj_is_kind_of(self,rb_cArray)) {
      unsigned int size = RARRAY_LEN(self);
      arg1 = &temp1;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(self)[i];
        OpenBabel::vector3* x;
        SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_OpenBabel__vector3, 1);
        temp1.push_back(*x);
      }
    } else {
      SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTOpenBabel__vector3_t, 1);
    }
  }
  result = (bool)((std::vector<OpenBabel::vector3 > const *)arg1)->empty();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vVector3_clear(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::vector3 > *arg1 = (std::vector<OpenBabel::vector3 > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTOpenBabel__vector3_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "clear" "', argument " "1"" of type '" "std::vector<OpenBabel::vector3 > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<OpenBabel::vector3 > * >(argp1);
  (arg1)->clear();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vVector3_push_back(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::vector3 > *arg1 = (std::vector<OpenBabel::vector3 > *) 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTOpenBabel__vector3_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "push_back" "', argument " "1"" of type '" "std::vector<OpenBabel::vector3 > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<OpenBabel::vector3 > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "push_back" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "push_back" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  (arg1)->push_back((OpenBabel::vector3 const &)*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vVector3_pop(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::vector3 > *arg1 = (std::vector<OpenBabel::vector3 > *) 0 ;
  OpenBabel::vector3 result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTOpenBabel__vector3_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "pop" "', argument " "1"" of type '" "std::vector<OpenBabel::vector3 > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<OpenBabel::vector3 > * >(argp1);
  try {
    result = std_vector_Sl_OpenBabel_vector3_Sg__pop(arg1);
  }
  catch(std::out_of_range &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_std__out_of_range, SWIG_NewPointerObj((new std::out_of_range(static_cast< const std::out_of_range& >(_e))),SWIGTYPE_p_std__out_of_range,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_NewPointerObj((new OpenBabel::vector3(static_cast< const OpenBabel::vector3& >(result))), SWIGTYPE_p_OpenBabel__vector3, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vVector3___getitem__(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::vector3 > *arg1 = (std::vector<OpenBabel::vector3 > *) 0 ;
  int arg2 ;
  OpenBabel::vector3 *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTOpenBabel__vector3_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "__getitem__" "', argument " "1"" of type '" "std::vector<OpenBabel::vector3 > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<OpenBabel::vector3 > * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "__getitem__" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  try {
    {
      OpenBabel::vector3 &_result_ref = std_vector_Sl_OpenBabel_vector3_Sg____getitem__(arg1,arg2);
      result = (OpenBabel::vector3 *) &_result_ref;
    }
  }
  catch(std::out_of_range &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_std__out_of_range, SWIG_NewPointerObj((new std::out_of_range(static_cast< const std::out_of_range& >(_e))),SWIGTYPE_p_std__out_of_range,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vVector3___setitem__(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::vector3 > *arg1 = (std::vector<OpenBabel::vector3 > *) 0 ;
  int arg2 ;
  OpenBabel::vector3 *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTOpenBabel__vector3_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "__setitem__" "', argument " "1"" of type '" "std::vector<OpenBabel::vector3 > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<OpenBabel::vector3 > * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "__setitem__" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "__setitem__" "', argument " "3"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "__setitem__" "', argument " "3"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::vector3 * >(argp3);
  try {
    std_vector_Sl_OpenBabel_vector3_Sg____setitem__(arg1,arg2,(OpenBabel::vector3 const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_std__out_of_range, SWIG_NewPointerObj((new std::out_of_range(static_cast< const std::out_of_range& >(_e))),SWIGTYPE_p_std__out_of_range,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vVector3_each(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::vector3 > *arg1 = (std::vector<OpenBabel::vector3 > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTOpenBabel__vector3_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "each" "', argument " "1"" of type '" "std::vector<OpenBabel::vector3 > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<OpenBabel::vector3 > * >(argp1);
  std_vector_Sl_OpenBabel_vector3_Sg__each(arg1);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN void
free_std_vector_Sl_OpenBabel_vector3_Sg_(std::vector<OpenBabel::vector3 > *arg1) {
    delete arg1;
}

swig_class cVectorMol;

SWIGINTERN VALUE
_wrap_new_vectorMol__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBMol > *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (std::vector<OpenBabel::OBMol > *)new std::vector<OpenBabel::OBMol >();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_vectorMol__SWIG_1(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  std::vector<OpenBabel::OBMol > *result = 0 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "std::vector<(OpenBabel::OBMol)>" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (std::vector<OpenBabel::OBMol > *)new std::vector<OpenBabel::OBMol >(arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_vectorMol__SWIG_2(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  OpenBabel::OBMol *arg2 = 0 ;
  std::vector<OpenBabel::OBMol > *result = 0 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "std::vector<(OpenBabel::OBMol)>" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_OpenBabel__OBMol,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "std::vector<(OpenBabel::OBMol)>" "', argument " "2"" of type '" "OpenBabel::OBMol const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "std::vector<(OpenBabel::OBMol)>" "', argument " "2"" of type '" "OpenBabel::OBMol const &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2);
  result = (std::vector<OpenBabel::OBMol > *)new std::vector<OpenBabel::OBMol >(arg1,(OpenBabel::OBMol const &)*arg2);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_vectorMol_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_vectorMol_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_std__vectorTOpenBabel__OBMol_t);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_vectorMol__SWIG_3(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBMol > *arg1 = 0 ;
  std::vector<OpenBabel::OBMol > *result = 0 ;
  std::vector<OpenBabel::OBMol > temp1 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
      unsigned int size = RARRAY_LEN(argv[0]);
      arg1 = &temp1;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(argv[0])[i];
        OpenBabel::OBMol* x;
        SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_OpenBabel__OBMol, 1);
        temp1.push_back(*x);
      }
    } else {
      SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_std__vectorTOpenBabel__OBMol_t, 1);
    }
  }
  result = (std::vector<OpenBabel::OBMol > *)new std::vector<OpenBabel::OBMol >((std::vector<OpenBabel::OBMol > const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_vectorMol(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_vectorMol__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_vectorMol__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    {
      /* native sequence? */
      if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
        unsigned int size = RARRAY_LEN(argv[0]);
        if (size == 0) {
          /* an empty sequence can be of any type */
          _v = 1;
        } else {
          /* check the first element only */
          OpenBabel::OBMol* x;
          VALUE o = RARRAY_PTR(argv[0])[0];
          if ((SWIG_ConvertPtr(o,(void **) &x, 
                SWIGTYPE_p_OpenBabel__OBMol,0)) != -1)
          _v = 1;
          else
          _v = 0;
        }
      } else {
        /* wrapped vector? */
        std::vector<OpenBabel::OBMol >* v;
        if (SWIG_ConvertPtr(argv[0],(void **) &v, 
            SWIGTYPE_p_std__vectorTOpenBabel__OBMol_t,0) != -1)
        _v = 1;
        else
        _v = 0;
      }
    }
    if (_v) {
      return _wrap_new_vectorMol__SWIG_3(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_vectorMol__SWIG_2(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_vectorMol'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorMol_size(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBMol > *arg1 = (std::vector<OpenBabel::OBMol > *) 0 ;
  unsigned int result;
  std::vector<OpenBabel::OBMol > temp1 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if (rb_obj_is_kind_of(self,rb_cArray)) {
      unsigned int size = RARRAY_LEN(self);
      arg1 = &temp1;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(self)[i];
        OpenBabel::OBMol* x;
        SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_OpenBabel__OBMol, 1);
        temp1.push_back(*x);
      }
    } else {
      SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTOpenBabel__OBMol_t, 1);
    }
  }
  result = (unsigned int)((std::vector<OpenBabel::OBMol > const *)arg1)->size();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorMol_empty(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBMol > *arg1 = (std::vector<OpenBabel::OBMol > *) 0 ;
  bool result;
  std::vector<OpenBabel::OBMol > temp1 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if (rb_obj_is_kind_of(self,rb_cArray)) {
      unsigned int size = RARRAY_LEN(self);
      arg1 = &temp1;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(self)[i];
        OpenBabel::OBMol* x;
        SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_OpenBabel__OBMol, 1);
        temp1.push_back(*x);
      }
    } else {
      SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTOpenBabel__OBMol_t, 1);
    }
  }
  result = (bool)((std::vector<OpenBabel::OBMol > const *)arg1)->empty();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorMol_clear(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBMol > *arg1 = (std::vector<OpenBabel::OBMol > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTOpenBabel__OBMol_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "clear" "', argument " "1"" of type '" "std::vector<OpenBabel::OBMol > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<OpenBabel::OBMol > * >(argp1);
  (arg1)->clear();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorMol_push_back(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBMol > *arg1 = (std::vector<OpenBabel::OBMol > *) 0 ;
  OpenBabel::OBMol *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTOpenBabel__OBMol_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "push_back" "', argument " "1"" of type '" "std::vector<OpenBabel::OBMol > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<OpenBabel::OBMol > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBMol,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "push_back" "', argument " "2"" of type '" "OpenBabel::OBMol const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "push_back" "', argument " "2"" of type '" "OpenBabel::OBMol const &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2);
  (arg1)->push_back((OpenBabel::OBMol const &)*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorMol_pop(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBMol > *arg1 = (std::vector<OpenBabel::OBMol > *) 0 ;
  OpenBabel::OBMol result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTOpenBabel__OBMol_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "pop" "', argument " "1"" of type '" "std::vector<OpenBabel::OBMol > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<OpenBabel::OBMol > * >(argp1);
  try {
    result = std_vector_Sl_OpenBabel_OBMol_Sg__pop(arg1);
  }
  catch(std::out_of_range &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_std__out_of_range, SWIG_NewPointerObj((new std::out_of_range(static_cast< const std::out_of_range& >(_e))),SWIGTYPE_p_std__out_of_range,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_NewPointerObj((new OpenBabel::OBMol(static_cast< const OpenBabel::OBMol& >(result))), SWIGTYPE_p_OpenBabel__OBMol, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorMol___getitem__(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBMol > *arg1 = (std::vector<OpenBabel::OBMol > *) 0 ;
  int arg2 ;
  OpenBabel::OBMol *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTOpenBabel__OBMol_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "__getitem__" "', argument " "1"" of type '" "std::vector<OpenBabel::OBMol > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<OpenBabel::OBMol > * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "__getitem__" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  try {
    {
      OpenBabel::OBMol &_result_ref = std_vector_Sl_OpenBabel_OBMol_Sg____getitem__(arg1,arg2);
      result = (OpenBabel::OBMol *) &_result_ref;
    }
  }
  catch(std::out_of_range &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_std__out_of_range, SWIG_NewPointerObj((new std::out_of_range(static_cast< const std::out_of_range& >(_e))),SWIGTYPE_p_std__out_of_range,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorMol___setitem__(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBMol > *arg1 = (std::vector<OpenBabel::OBMol > *) 0 ;
  int arg2 ;
  OpenBabel::OBMol *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTOpenBabel__OBMol_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "__setitem__" "', argument " "1"" of type '" "std::vector<OpenBabel::OBMol > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<OpenBabel::OBMol > * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "__setitem__" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_OpenBabel__OBMol,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "__setitem__" "', argument " "3"" of type '" "OpenBabel::OBMol const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "__setitem__" "', argument " "3"" of type '" "OpenBabel::OBMol const &""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBMol * >(argp3);
  try {
    std_vector_Sl_OpenBabel_OBMol_Sg____setitem__(arg1,arg2,(OpenBabel::OBMol const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_std__out_of_range, SWIG_NewPointerObj((new std::out_of_range(static_cast< const std::out_of_range& >(_e))),SWIGTYPE_p_std__out_of_range,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorMol_each(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBMol > *arg1 = (std::vector<OpenBabel::OBMol > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTOpenBabel__OBMol_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "each" "', argument " "1"" of type '" "std::vector<OpenBabel::OBMol > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<OpenBabel::OBMol > * >(argp1);
  std_vector_Sl_OpenBabel_OBMol_Sg__each(arg1);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN void
free_std_vector_Sl_OpenBabel_OBMol_Sg_(std::vector<OpenBabel::OBMol > *arg1) {
    delete arg1;
}

swig_class cVectorBond;

SWIGINTERN VALUE
_wrap_new_vectorBond__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBBond > *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (std::vector<OpenBabel::OBBond > *)new std::vector<OpenBabel::OBBond >();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_vectorBond__SWIG_1(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  std::vector<OpenBabel::OBBond > *result = 0 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "std::vector<(OpenBabel::OBBond)>" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (std::vector<OpenBabel::OBBond > *)new std::vector<OpenBabel::OBBond >(arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_vectorBond__SWIG_2(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  OpenBabel::OBBond *arg2 = 0 ;
  std::vector<OpenBabel::OBBond > *result = 0 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "std::vector<(OpenBabel::OBBond)>" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_OpenBabel__OBBond,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "std::vector<(OpenBabel::OBBond)>" "', argument " "2"" of type '" "OpenBabel::OBBond const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "std::vector<(OpenBabel::OBBond)>" "', argument " "2"" of type '" "OpenBabel::OBBond const &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBond * >(argp2);
  result = (std::vector<OpenBabel::OBBond > *)new std::vector<OpenBabel::OBBond >(arg1,(OpenBabel::OBBond const &)*arg2);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_vectorBond_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_vectorBond_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_std__vectorTOpenBabel__OBBond_t);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_vectorBond__SWIG_3(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBBond > *arg1 = 0 ;
  std::vector<OpenBabel::OBBond > *result = 0 ;
  std::vector<OpenBabel::OBBond > temp1 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
      unsigned int size = RARRAY_LEN(argv[0]);
      arg1 = &temp1;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(argv[0])[i];
        OpenBabel::OBBond* x;
        SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_OpenBabel__OBBond, 1);
        temp1.push_back(*x);
      }
    } else {
      SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_std__vectorTOpenBabel__OBBond_t, 1);
    }
  }
  result = (std::vector<OpenBabel::OBBond > *)new std::vector<OpenBabel::OBBond >((std::vector<OpenBabel::OBBond > const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_vectorBond(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_vectorBond__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_vectorBond__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    {
      /* native sequence? */
      if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
        unsigned int size = RARRAY_LEN(argv[0]);
        if (size == 0) {
          /* an empty sequence can be of any type */
          _v = 1;
        } else {
          /* check the first element only */
          OpenBabel::OBBond* x;
          VALUE o = RARRAY_PTR(argv[0])[0];
          if ((SWIG_ConvertPtr(o,(void **) &x, 
                SWIGTYPE_p_OpenBabel__OBBond,0)) != -1)
          _v = 1;
          else
          _v = 0;
        }
      } else {
        /* wrapped vector? */
        std::vector<OpenBabel::OBBond >* v;
        if (SWIG_ConvertPtr(argv[0],(void **) &v, 
            SWIGTYPE_p_std__vectorTOpenBabel__OBBond_t,0) != -1)
        _v = 1;
        else
        _v = 0;
      }
    }
    if (_v) {
      return _wrap_new_vectorBond__SWIG_3(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBBond, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_vectorBond__SWIG_2(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_vectorBond'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorBond_size(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBBond > *arg1 = (std::vector<OpenBabel::OBBond > *) 0 ;
  unsigned int result;
  std::vector<OpenBabel::OBBond > temp1 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if (rb_obj_is_kind_of(self,rb_cArray)) {
      unsigned int size = RARRAY_LEN(self);
      arg1 = &temp1;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(self)[i];
        OpenBabel::OBBond* x;
        SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_OpenBabel__OBBond, 1);
        temp1.push_back(*x);
      }
    } else {
      SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTOpenBabel__OBBond_t, 1);
    }
  }
  result = (unsigned int)((std::vector<OpenBabel::OBBond > const *)arg1)->size();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorBond_empty(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBBond > *arg1 = (std::vector<OpenBabel::OBBond > *) 0 ;
  bool result;
  std::vector<OpenBabel::OBBond > temp1 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if (rb_obj_is_kind_of(self,rb_cArray)) {
      unsigned int size = RARRAY_LEN(self);
      arg1 = &temp1;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(self)[i];
        OpenBabel::OBBond* x;
        SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_OpenBabel__OBBond, 1);
        temp1.push_back(*x);
      }
    } else {
      SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTOpenBabel__OBBond_t, 1);
    }
  }
  result = (bool)((std::vector<OpenBabel::OBBond > const *)arg1)->empty();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorBond_clear(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBBond > *arg1 = (std::vector<OpenBabel::OBBond > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTOpenBabel__OBBond_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "clear" "', argument " "1"" of type '" "std::vector<OpenBabel::OBBond > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<OpenBabel::OBBond > * >(argp1);
  (arg1)->clear();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorBond_push_back(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBBond > *arg1 = (std::vector<OpenBabel::OBBond > *) 0 ;
  OpenBabel::OBBond *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTOpenBabel__OBBond_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "push_back" "', argument " "1"" of type '" "std::vector<OpenBabel::OBBond > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<OpenBabel::OBBond > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBBond,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "push_back" "', argument " "2"" of type '" "OpenBabel::OBBond const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "push_back" "', argument " "2"" of type '" "OpenBabel::OBBond const &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBond * >(argp2);
  (arg1)->push_back((OpenBabel::OBBond const &)*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorBond_pop(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBBond > *arg1 = (std::vector<OpenBabel::OBBond > *) 0 ;
  OpenBabel::OBBond result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTOpenBabel__OBBond_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "pop" "', argument " "1"" of type '" "std::vector<OpenBabel::OBBond > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<OpenBabel::OBBond > * >(argp1);
  try {
    result = std_vector_Sl_OpenBabel_OBBond_Sg__pop(arg1);
  }
  catch(std::out_of_range &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_std__out_of_range, SWIG_NewPointerObj((new std::out_of_range(static_cast< const std::out_of_range& >(_e))),SWIGTYPE_p_std__out_of_range,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_NewPointerObj((new OpenBabel::OBBond(static_cast< const OpenBabel::OBBond& >(result))), SWIGTYPE_p_OpenBabel__OBBond, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorBond___getitem__(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBBond > *arg1 = (std::vector<OpenBabel::OBBond > *) 0 ;
  int arg2 ;
  OpenBabel::OBBond *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTOpenBabel__OBBond_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "__getitem__" "', argument " "1"" of type '" "std::vector<OpenBabel::OBBond > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<OpenBabel::OBBond > * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "__getitem__" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  try {
    {
      OpenBabel::OBBond &_result_ref = std_vector_Sl_OpenBabel_OBBond_Sg____getitem__(arg1,arg2);
      result = (OpenBabel::OBBond *) &_result_ref;
    }
  }
  catch(std::out_of_range &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_std__out_of_range, SWIG_NewPointerObj((new std::out_of_range(static_cast< const std::out_of_range& >(_e))),SWIGTYPE_p_std__out_of_range,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorBond___setitem__(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBBond > *arg1 = (std::vector<OpenBabel::OBBond > *) 0 ;
  int arg2 ;
  OpenBabel::OBBond *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTOpenBabel__OBBond_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "__setitem__" "', argument " "1"" of type '" "std::vector<OpenBabel::OBBond > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<OpenBabel::OBBond > * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "__setitem__" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_OpenBabel__OBBond,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "__setitem__" "', argument " "3"" of type '" "OpenBabel::OBBond const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "__setitem__" "', argument " "3"" of type '" "OpenBabel::OBBond const &""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBBond * >(argp3);
  try {
    std_vector_Sl_OpenBabel_OBBond_Sg____setitem__(arg1,arg2,(OpenBabel::OBBond const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_std__out_of_range, SWIG_NewPointerObj((new std::out_of_range(static_cast< const std::out_of_range& >(_e))),SWIGTYPE_p_std__out_of_range,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorBond_each(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBBond > *arg1 = (std::vector<OpenBabel::OBBond > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTOpenBabel__OBBond_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "each" "', argument " "1"" of type '" "std::vector<OpenBabel::OBBond > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<OpenBabel::OBBond > * >(argp1);
  std_vector_Sl_OpenBabel_OBBond_Sg__each(arg1);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN void
free_std_vector_Sl_OpenBabel_OBBond_Sg_(std::vector<OpenBabel::OBBond > *arg1) {
    delete arg1;
}

swig_class cVectorResidue;

SWIGINTERN VALUE
_wrap_new_vectorResidue__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBResidue > *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (std::vector<OpenBabel::OBResidue > *)new std::vector<OpenBabel::OBResidue >();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_vectorResidue__SWIG_1(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  std::vector<OpenBabel::OBResidue > *result = 0 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "std::vector<(OpenBabel::OBResidue)>" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (std::vector<OpenBabel::OBResidue > *)new std::vector<OpenBabel::OBResidue >(arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_vectorResidue__SWIG_2(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  OpenBabel::OBResidue *arg2 = 0 ;
  std::vector<OpenBabel::OBResidue > *result = 0 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "std::vector<(OpenBabel::OBResidue)>" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_OpenBabel__OBResidue,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "std::vector<(OpenBabel::OBResidue)>" "', argument " "2"" of type '" "OpenBabel::OBResidue const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "std::vector<(OpenBabel::OBResidue)>" "', argument " "2"" of type '" "OpenBabel::OBResidue const &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBResidue * >(argp2);
  result = (std::vector<OpenBabel::OBResidue > *)new std::vector<OpenBabel::OBResidue >(arg1,(OpenBabel::OBResidue const &)*arg2);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_vectorResidue_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_vectorResidue_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_std__vectorTOpenBabel__OBResidue_t);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_vectorResidue__SWIG_3(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBResidue > *arg1 = 0 ;
  std::vector<OpenBabel::OBResidue > *result = 0 ;
  std::vector<OpenBabel::OBResidue > temp1 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
      unsigned int size = RARRAY_LEN(argv[0]);
      arg1 = &temp1;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(argv[0])[i];
        OpenBabel::OBResidue* x;
        SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_OpenBabel__OBResidue, 1);
        temp1.push_back(*x);
      }
    } else {
      SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_std__vectorTOpenBabel__OBResidue_t, 1);
    }
  }
  result = (std::vector<OpenBabel::OBResidue > *)new std::vector<OpenBabel::OBResidue >((std::vector<OpenBabel::OBResidue > const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_vectorResidue(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_vectorResidue__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_vectorResidue__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    {
      /* native sequence? */
      if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
        unsigned int size = RARRAY_LEN(argv[0]);
        if (size == 0) {
          /* an empty sequence can be of any type */
          _v = 1;
        } else {
          /* check the first element only */
          OpenBabel::OBResidue* x;
          VALUE o = RARRAY_PTR(argv[0])[0];
          if ((SWIG_ConvertPtr(o,(void **) &x, 
                SWIGTYPE_p_OpenBabel__OBResidue,0)) != -1)
          _v = 1;
          else
          _v = 0;
        }
      } else {
        /* wrapped vector? */
        std::vector<OpenBabel::OBResidue >* v;
        if (SWIG_ConvertPtr(argv[0],(void **) &v, 
            SWIGTYPE_p_std__vectorTOpenBabel__OBResidue_t,0) != -1)
        _v = 1;
        else
        _v = 0;
      }
    }
    if (_v) {
      return _wrap_new_vectorResidue__SWIG_3(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBResidue, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_vectorResidue__SWIG_2(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_vectorResidue'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorResidue_size(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBResidue > *arg1 = (std::vector<OpenBabel::OBResidue > *) 0 ;
  unsigned int result;
  std::vector<OpenBabel::OBResidue > temp1 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if (rb_obj_is_kind_of(self,rb_cArray)) {
      unsigned int size = RARRAY_LEN(self);
      arg1 = &temp1;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(self)[i];
        OpenBabel::OBResidue* x;
        SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_OpenBabel__OBResidue, 1);
        temp1.push_back(*x);
      }
    } else {
      SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTOpenBabel__OBResidue_t, 1);
    }
  }
  result = (unsigned int)((std::vector<OpenBabel::OBResidue > const *)arg1)->size();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorResidue_empty(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBResidue > *arg1 = (std::vector<OpenBabel::OBResidue > *) 0 ;
  bool result;
  std::vector<OpenBabel::OBResidue > temp1 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if (rb_obj_is_kind_of(self,rb_cArray)) {
      unsigned int size = RARRAY_LEN(self);
      arg1 = &temp1;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(self)[i];
        OpenBabel::OBResidue* x;
        SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_OpenBabel__OBResidue, 1);
        temp1.push_back(*x);
      }
    } else {
      SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTOpenBabel__OBResidue_t, 1);
    }
  }
  result = (bool)((std::vector<OpenBabel::OBResidue > const *)arg1)->empty();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorResidue_clear(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBResidue > *arg1 = (std::vector<OpenBabel::OBResidue > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTOpenBabel__OBResidue_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "clear" "', argument " "1"" of type '" "std::vector<OpenBabel::OBResidue > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<OpenBabel::OBResidue > * >(argp1);
  (arg1)->clear();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorResidue_push_back(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBResidue > *arg1 = (std::vector<OpenBabel::OBResidue > *) 0 ;
  OpenBabel::OBResidue *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTOpenBabel__OBResidue_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "push_back" "', argument " "1"" of type '" "std::vector<OpenBabel::OBResidue > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<OpenBabel::OBResidue > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBResidue,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "push_back" "', argument " "2"" of type '" "OpenBabel::OBResidue const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "push_back" "', argument " "2"" of type '" "OpenBabel::OBResidue const &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBResidue * >(argp2);
  (arg1)->push_back((OpenBabel::OBResidue const &)*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorResidue_pop(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBResidue > *arg1 = (std::vector<OpenBabel::OBResidue > *) 0 ;
  OpenBabel::OBResidue result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTOpenBabel__OBResidue_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "pop" "', argument " "1"" of type '" "std::vector<OpenBabel::OBResidue > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<OpenBabel::OBResidue > * >(argp1);
  try {
    result = std_vector_Sl_OpenBabel_OBResidue_Sg__pop(arg1);
  }
  catch(std::out_of_range &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_std__out_of_range, SWIG_NewPointerObj((new std::out_of_range(static_cast< const std::out_of_range& >(_e))),SWIGTYPE_p_std__out_of_range,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_NewPointerObj((new OpenBabel::OBResidue(static_cast< const OpenBabel::OBResidue& >(result))), SWIGTYPE_p_OpenBabel__OBResidue, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorResidue___getitem__(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBResidue > *arg1 = (std::vector<OpenBabel::OBResidue > *) 0 ;
  int arg2 ;
  OpenBabel::OBResidue *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTOpenBabel__OBResidue_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "__getitem__" "', argument " "1"" of type '" "std::vector<OpenBabel::OBResidue > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<OpenBabel::OBResidue > * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "__getitem__" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  try {
    {
      OpenBabel::OBResidue &_result_ref = std_vector_Sl_OpenBabel_OBResidue_Sg____getitem__(arg1,arg2);
      result = (OpenBabel::OBResidue *) &_result_ref;
    }
  }
  catch(std::out_of_range &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_std__out_of_range, SWIG_NewPointerObj((new std::out_of_range(static_cast< const std::out_of_range& >(_e))),SWIGTYPE_p_std__out_of_range,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorResidue___setitem__(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBResidue > *arg1 = (std::vector<OpenBabel::OBResidue > *) 0 ;
  int arg2 ;
  OpenBabel::OBResidue *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTOpenBabel__OBResidue_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "__setitem__" "', argument " "1"" of type '" "std::vector<OpenBabel::OBResidue > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<OpenBabel::OBResidue > * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "__setitem__" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_OpenBabel__OBResidue,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "__setitem__" "', argument " "3"" of type '" "OpenBabel::OBResidue const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "__setitem__" "', argument " "3"" of type '" "OpenBabel::OBResidue const &""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBResidue * >(argp3);
  try {
    std_vector_Sl_OpenBabel_OBResidue_Sg____setitem__(arg1,arg2,(OpenBabel::OBResidue const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_std__out_of_range, SWIG_NewPointerObj((new std::out_of_range(static_cast< const std::out_of_range& >(_e))),SWIGTYPE_p_std__out_of_range,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorResidue_each(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBResidue > *arg1 = (std::vector<OpenBabel::OBResidue > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTOpenBabel__OBResidue_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "each" "', argument " "1"" of type '" "std::vector<OpenBabel::OBResidue > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<OpenBabel::OBResidue > * >(argp1);
  std_vector_Sl_OpenBabel_OBResidue_Sg__each(arg1);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN void
free_std_vector_Sl_OpenBabel_OBResidue_Sg_(std::vector<OpenBabel::OBResidue > *arg1) {
    delete arg1;
}

swig_class cVectorRing;

SWIGINTERN VALUE
_wrap_new_vectorRing__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBRing > *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (std::vector<OpenBabel::OBRing > *)new std::vector<OpenBabel::OBRing >();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_vectorRing__SWIG_1(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  std::vector<OpenBabel::OBRing > *result = 0 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "std::vector<(OpenBabel::OBRing)>" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (std::vector<OpenBabel::OBRing > *)new std::vector<OpenBabel::OBRing >(arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_vectorRing__SWIG_2(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  OpenBabel::OBRing *arg2 = 0 ;
  std::vector<OpenBabel::OBRing > *result = 0 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "std::vector<(OpenBabel::OBRing)>" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_OpenBabel__OBRing,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "std::vector<(OpenBabel::OBRing)>" "', argument " "2"" of type '" "OpenBabel::OBRing const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "std::vector<(OpenBabel::OBRing)>" "', argument " "2"" of type '" "OpenBabel::OBRing const &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBRing * >(argp2);
  result = (std::vector<OpenBabel::OBRing > *)new std::vector<OpenBabel::OBRing >(arg1,(OpenBabel::OBRing const &)*arg2);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_vectorRing_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_vectorRing_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_std__vectorTOpenBabel__OBRing_t);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_vectorRing__SWIG_3(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBRing > *arg1 = 0 ;
  std::vector<OpenBabel::OBRing > *result = 0 ;
  std::vector<OpenBabel::OBRing > temp1 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
      unsigned int size = RARRAY_LEN(argv[0]);
      arg1 = &temp1;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(argv[0])[i];
        OpenBabel::OBRing* x;
        SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_OpenBabel__OBRing, 1);
        temp1.push_back(*x);
      }
    } else {
      SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_std__vectorTOpenBabel__OBRing_t, 1);
    }
  }
  result = (std::vector<OpenBabel::OBRing > *)new std::vector<OpenBabel::OBRing >((std::vector<OpenBabel::OBRing > const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_vectorRing(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_vectorRing__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_vectorRing__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    {
      /* native sequence? */
      if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
        unsigned int size = RARRAY_LEN(argv[0]);
        if (size == 0) {
          /* an empty sequence can be of any type */
          _v = 1;
        } else {
          /* check the first element only */
          OpenBabel::OBRing* x;
          VALUE o = RARRAY_PTR(argv[0])[0];
          if ((SWIG_ConvertPtr(o,(void **) &x, 
                SWIGTYPE_p_OpenBabel__OBRing,0)) != -1)
          _v = 1;
          else
          _v = 0;
        }
      } else {
        /* wrapped vector? */
        std::vector<OpenBabel::OBRing >* v;
        if (SWIG_ConvertPtr(argv[0],(void **) &v, 
            SWIGTYPE_p_std__vectorTOpenBabel__OBRing_t,0) != -1)
        _v = 1;
        else
        _v = 0;
      }
    }
    if (_v) {
      return _wrap_new_vectorRing__SWIG_3(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBRing, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_vectorRing__SWIG_2(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_vectorRing'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorRing_size(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBRing > *arg1 = (std::vector<OpenBabel::OBRing > *) 0 ;
  unsigned int result;
  std::vector<OpenBabel::OBRing > temp1 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if (rb_obj_is_kind_of(self,rb_cArray)) {
      unsigned int size = RARRAY_LEN(self);
      arg1 = &temp1;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(self)[i];
        OpenBabel::OBRing* x;
        SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_OpenBabel__OBRing, 1);
        temp1.push_back(*x);
      }
    } else {
      SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTOpenBabel__OBRing_t, 1);
    }
  }
  result = (unsigned int)((std::vector<OpenBabel::OBRing > const *)arg1)->size();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorRing_empty(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBRing > *arg1 = (std::vector<OpenBabel::OBRing > *) 0 ;
  bool result;
  std::vector<OpenBabel::OBRing > temp1 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if (rb_obj_is_kind_of(self,rb_cArray)) {
      unsigned int size = RARRAY_LEN(self);
      arg1 = &temp1;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(self)[i];
        OpenBabel::OBRing* x;
        SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_OpenBabel__OBRing, 1);
        temp1.push_back(*x);
      }
    } else {
      SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTOpenBabel__OBRing_t, 1);
    }
  }
  result = (bool)((std::vector<OpenBabel::OBRing > const *)arg1)->empty();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorRing_clear(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBRing > *arg1 = (std::vector<OpenBabel::OBRing > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTOpenBabel__OBRing_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "clear" "', argument " "1"" of type '" "std::vector<OpenBabel::OBRing > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<OpenBabel::OBRing > * >(argp1);
  (arg1)->clear();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorRing_push_back(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBRing > *arg1 = (std::vector<OpenBabel::OBRing > *) 0 ;
  OpenBabel::OBRing *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTOpenBabel__OBRing_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "push_back" "', argument " "1"" of type '" "std::vector<OpenBabel::OBRing > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<OpenBabel::OBRing > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBRing,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "push_back" "', argument " "2"" of type '" "OpenBabel::OBRing const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "push_back" "', argument " "2"" of type '" "OpenBabel::OBRing const &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBRing * >(argp2);
  (arg1)->push_back((OpenBabel::OBRing const &)*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorRing_pop(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBRing > *arg1 = (std::vector<OpenBabel::OBRing > *) 0 ;
  OpenBabel::OBRing result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTOpenBabel__OBRing_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "pop" "', argument " "1"" of type '" "std::vector<OpenBabel::OBRing > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<OpenBabel::OBRing > * >(argp1);
  try {
    result = std_vector_Sl_OpenBabel_OBRing_Sg__pop(arg1);
  }
  catch(std::out_of_range &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_std__out_of_range, SWIG_NewPointerObj((new std::out_of_range(static_cast< const std::out_of_range& >(_e))),SWIGTYPE_p_std__out_of_range,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_NewPointerObj((new OpenBabel::OBRing(static_cast< const OpenBabel::OBRing& >(result))), SWIGTYPE_p_OpenBabel__OBRing, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorRing___getitem__(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBRing > *arg1 = (std::vector<OpenBabel::OBRing > *) 0 ;
  int arg2 ;
  OpenBabel::OBRing *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTOpenBabel__OBRing_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "__getitem__" "', argument " "1"" of type '" "std::vector<OpenBabel::OBRing > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<OpenBabel::OBRing > * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "__getitem__" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  try {
    {
      OpenBabel::OBRing &_result_ref = std_vector_Sl_OpenBabel_OBRing_Sg____getitem__(arg1,arg2);
      result = (OpenBabel::OBRing *) &_result_ref;
    }
  }
  catch(std::out_of_range &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_std__out_of_range, SWIG_NewPointerObj((new std::out_of_range(static_cast< const std::out_of_range& >(_e))),SWIGTYPE_p_std__out_of_range,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBRing, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorRing___setitem__(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBRing > *arg1 = (std::vector<OpenBabel::OBRing > *) 0 ;
  int arg2 ;
  OpenBabel::OBRing *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTOpenBabel__OBRing_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "__setitem__" "', argument " "1"" of type '" "std::vector<OpenBabel::OBRing > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<OpenBabel::OBRing > * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "__setitem__" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_OpenBabel__OBRing,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "__setitem__" "', argument " "3"" of type '" "OpenBabel::OBRing const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "__setitem__" "', argument " "3"" of type '" "OpenBabel::OBRing const &""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBRing * >(argp3);
  try {
    std_vector_Sl_OpenBabel_OBRing_Sg____setitem__(arg1,arg2,(OpenBabel::OBRing const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_std__out_of_range, SWIG_NewPointerObj((new std::out_of_range(static_cast< const std::out_of_range& >(_e))),SWIGTYPE_p_std__out_of_range,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorRing_each(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBRing > *arg1 = (std::vector<OpenBabel::OBRing > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTOpenBabel__OBRing_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "each" "', argument " "1"" of type '" "std::vector<OpenBabel::OBRing > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<OpenBabel::OBRing > * >(argp1);
  std_vector_Sl_OpenBabel_OBRing_Sg__each(arg1);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN void
free_std_vector_Sl_OpenBabel_OBRing_Sg_(std::vector<OpenBabel::OBRing > *arg1) {
    delete arg1;
}

swig_class cVectorData;

SWIGINTERN VALUE
_wrap_new_vectorData__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBGenericData * > *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (std::vector<OpenBabel::OBGenericData * > *)new std::vector<OpenBabel::OBGenericData * >();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_vectorData__SWIG_1(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  std::vector<OpenBabel::OBGenericData * > *result = 0 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "std::vector<(p.OpenBabel::OBGenericData)>" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (std::vector<OpenBabel::OBGenericData * > *)new std::vector<OpenBabel::OBGenericData * >(arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_vectorData__SWIG_2(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  OpenBabel::OBGenericData **arg2 = 0 ;
  std::vector<OpenBabel::OBGenericData * > *result = 0 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "std::vector<(p.OpenBabel::OBGenericData)>" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_p_OpenBabel__OBGenericData,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "std::vector<(p.OpenBabel::OBGenericData)>" "', argument " "2"" of type '" "OpenBabel::OBGenericData *&""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "std::vector<(p.OpenBabel::OBGenericData)>" "', argument " "2"" of type '" "OpenBabel::OBGenericData *&""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBGenericData ** >(argp2);
  result = (std::vector<OpenBabel::OBGenericData * > *)new std::vector<OpenBabel::OBGenericData * >(arg1,*arg2);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_vectorData_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_vectorData_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_vectorData__SWIG_3(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBGenericData * > *arg1 = 0 ;
  std::vector<OpenBabel::OBGenericData * > *result = 0 ;
  std::vector<OpenBabel::OBGenericData * > temp1 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
      unsigned int size = RARRAY_LEN(argv[0]);
      temp1 = std::vector<OpenBabel::OBGenericData* >(size);
      arg1 = &temp1;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(argv[0])[i];
        OpenBabel::OBGenericData* x;
        SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_OpenBabel__OBGenericData, 1);
        temp1[i] = x;
      }
    } else {
      SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t, 1);
    }
  }
  result = (std::vector<OpenBabel::OBGenericData * > *)new std::vector<OpenBabel::OBGenericData * >((std::vector<OpenBabel::OBGenericData * > const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_vectorData(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_vectorData__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_vectorData__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    {
      /* native sequence? */
      if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
        unsigned int size = RARRAY_LEN(argv[0]);
        if (size == 0) {
          /* an empty sequence can be of any type */
          _v = 1;
        } else {
          /* check the first element only */
          OpenBabel::OBGenericData* x;
          VALUE o = RARRAY_PTR(argv[0])[0];
          if ((SWIG_ConvertPtr(o,(void **) &x, 
                SWIGTYPE_p_OpenBabel__OBGenericData,0)) != -1)
          _v = 1;
          else
          _v = 0;
        }
      } else {
        /* wrapped vector? */
        std::vector<OpenBabel::OBGenericData* >* v;
        if (SWIG_ConvertPtr(argv[0],(void **) &v, 
            SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t,0) != -1)
        _v = 1;
        else
        _v = 0;
      }
    }
    if (_v) {
      return _wrap_new_vectorData__SWIG_3(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_p_OpenBabel__OBGenericData, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_vectorData__SWIG_2(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_vectorData'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorData_size(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBGenericData * > *arg1 = (std::vector<OpenBabel::OBGenericData * > *) 0 ;
  unsigned int result;
  std::vector<OpenBabel::OBGenericData * > temp1 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if (rb_obj_is_kind_of(self,rb_cArray)) {
      unsigned int size = RARRAY_LEN(self);
      temp1 = std::vector<OpenBabel::OBGenericData* >(size);
      arg1 = &temp1;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(self)[i];
        OpenBabel::OBGenericData* x;
        SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_OpenBabel__OBGenericData, 1);
        temp1[i] = x;
      }
    } else {
      SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t, 1);
    }
  }
  result = (unsigned int)((std::vector<OpenBabel::OBGenericData * > const *)arg1)->size();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorData_empty(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBGenericData * > *arg1 = (std::vector<OpenBabel::OBGenericData * > *) 0 ;
  bool result;
  std::vector<OpenBabel::OBGenericData * > temp1 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    if (rb_obj_is_kind_of(self,rb_cArray)) {
      unsigned int size = RARRAY_LEN(self);
      temp1 = std::vector<OpenBabel::OBGenericData* >(size);
      arg1 = &temp1;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(self)[i];
        OpenBabel::OBGenericData* x;
        SWIG_ConvertPtr(o, (void **) &x, SWIGTYPE_p_OpenBabel__OBGenericData, 1);
        temp1[i] = x;
      }
    } else {
      SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t, 1);
    }
  }
  result = (bool)((std::vector<OpenBabel::OBGenericData * > const *)arg1)->empty();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorData_clear(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBGenericData * > *arg1 = (std::vector<OpenBabel::OBGenericData * > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "clear" "', argument " "1"" of type '" "std::vector<OpenBabel::OBGenericData * > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<OpenBabel::OBGenericData * > * >(argp1);
  (arg1)->clear();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorData_push_back(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBGenericData * > *arg1 = (std::vector<OpenBabel::OBGenericData * > *) 0 ;
  OpenBabel::OBGenericData *arg2 = (OpenBabel::OBGenericData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "push_back" "', argument " "1"" of type '" "std::vector<OpenBabel::OBGenericData * > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<OpenBabel::OBGenericData * > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "push_back" "', argument " "2"" of type '" "OpenBabel::OBGenericData *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBGenericData * >(argp2);
  (arg1)->push_back(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorData_pop(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBGenericData * > *arg1 = (std::vector<OpenBabel::OBGenericData * > *) 0 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "pop" "', argument " "1"" of type '" "std::vector<OpenBabel::OBGenericData * > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<OpenBabel::OBGenericData * > * >(argp1);
  try {
    result = (OpenBabel::OBGenericData *)std_vector_Sl_OpenBabel_OBGenericData_Sm__Sg__pop(arg1);
  }
  catch(std::out_of_range &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_std__out_of_range, SWIG_NewPointerObj((new std::out_of_range(static_cast< const std::out_of_range& >(_e))),SWIGTYPE_p_std__out_of_range,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorData___getitem__(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBGenericData * > *arg1 = (std::vector<OpenBabel::OBGenericData * > *) 0 ;
  int arg2 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "__getitem__" "', argument " "1"" of type '" "std::vector<OpenBabel::OBGenericData * > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<OpenBabel::OBGenericData * > * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "__getitem__" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  try {
    result = (OpenBabel::OBGenericData *)std_vector_Sl_OpenBabel_OBGenericData_Sm__Sg____getitem__(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_std__out_of_range, SWIG_NewPointerObj((new std::out_of_range(static_cast< const std::out_of_range& >(_e))),SWIGTYPE_p_std__out_of_range,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorData___setitem__(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBGenericData * > *arg1 = (std::vector<OpenBabel::OBGenericData * > *) 0 ;
  int arg2 ;
  OpenBabel::OBGenericData *arg3 = (OpenBabel::OBGenericData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "__setitem__" "', argument " "1"" of type '" "std::vector<OpenBabel::OBGenericData * > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<OpenBabel::OBGenericData * > * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "__setitem__" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "__setitem__" "', argument " "3"" of type '" "OpenBabel::OBGenericData *""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBGenericData * >(argp3);
  try {
    std_vector_Sl_OpenBabel_OBGenericData_Sm__Sg____setitem__(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    rb_exc_raise(SWIG_Ruby_ExceptionType(SWIGTYPE_p_std__out_of_range, SWIG_NewPointerObj((new std::out_of_range(static_cast< const std::out_of_range& >(_e))),SWIGTYPE_p_std__out_of_range,SWIG_POINTER_OWN))); SWIG_fail;
  }
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vectorData_each(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBGenericData * > *arg1 = (std::vector<OpenBabel::OBGenericData * > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "each" "', argument " "1"" of type '" "std::vector<OpenBabel::OBGenericData * > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector<OpenBabel::OBGenericData * > * >(argp1);
  std_vector_Sl_OpenBabel_OBGenericData_Sm__Sg__each(arg1);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN void
free_std_vector_Sl_OpenBabel_OBGenericData_Sm__Sg_(std::vector<OpenBabel::OBGenericData * > *arg1) {
    delete arg1;
}

swig_class cOBGlobalDataBase;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBGlobalDataBase_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBGlobalDataBase_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBGlobalDataBase);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBGlobalDataBase(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBGlobalDataBase *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBGlobalDataBase *)new OpenBabel::OBGlobalDataBase();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBGlobalDataBase(OpenBabel::OBGlobalDataBase *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_OBGlobalDataBase_init(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBGlobalDataBase *arg1 = (OpenBabel::OBGlobalDataBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBGlobalDataBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Init" "', argument " "1"" of type '" "OpenBabel::OBGlobalDataBase *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBGlobalDataBase * >(argp1);
  (arg1)->Init();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBGlobalDataBase_get_size(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBGlobalDataBase *arg1 = (OpenBabel::OBGlobalDataBase *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBGlobalDataBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetSize" "', argument " "1"" of type '" "OpenBabel::OBGlobalDataBase *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBGlobalDataBase * >(argp1);
  result = (unsigned int)(arg1)->GetSize();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBGlobalDataBase_set_read_directory(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBGlobalDataBase *arg1 = (OpenBabel::OBGlobalDataBase *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBGlobalDataBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetReadDirectory" "', argument " "1"" of type '" "OpenBabel::OBGlobalDataBase *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBGlobalDataBase * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetReadDirectory" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  (arg1)->SetReadDirectory(arg2);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBGlobalDataBase_set_environment_variable(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBGlobalDataBase *arg1 = (OpenBabel::OBGlobalDataBase *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBGlobalDataBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetEnvironmentVariable" "', argument " "1"" of type '" "OpenBabel::OBGlobalDataBase *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBGlobalDataBase * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetEnvironmentVariable" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  (arg1)->SetEnvironmentVariable(arg2);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBGlobalDataBase_parse_line(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBGlobalDataBase *arg1 = (OpenBabel::OBGlobalDataBase *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBGlobalDataBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ParseLine" "', argument " "1"" of type '" "OpenBabel::OBGlobalDataBase *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBGlobalDataBase * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ParseLine" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  (arg1)->ParseLine((char const *)arg2);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


swig_class cOBElement;

SWIGINTERN VALUE
_wrap_new_OBElement__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElement *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBElement *)new OpenBabel::OBElement();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBElement_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBElement_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBElement);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBElement__SWIG_1(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  char *arg2 = (char *) 0 ;
  double arg3 ;
  double arg4 ;
  int arg5 ;
  double arg6 ;
  double arg7 ;
  double arg8 ;
  double arg9 ;
  double arg10 ;
  double arg11 ;
  double arg12 ;
  std::string arg13 ;
  OpenBabel::OBElement *result = 0 ;
  int val1 ;
  int ecode1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  double val6 ;
  int ecode6 = 0 ;
  double val7 ;
  int ecode7 = 0 ;
  double val8 ;
  int ecode8 = 0 ;
  double val9 ;
  int ecode9 = 0 ;
  double val10 ;
  int ecode10 = 0 ;
  double val11 ;
  int ecode11 = 0 ;
  double val12 ;
  int ecode12 = 0 ;
  
  if ((argc < 13) || (argc > 13)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 13)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "OpenBabel::OBElement" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = static_cast< int >(val1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::OBElement" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_double(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "OpenBabel::OBElement" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  ecode4 = SWIG_AsVal_double(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "OpenBabel::OBElement" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = static_cast< double >(val4);
  ecode5 = SWIG_AsVal_int(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "OpenBabel::OBElement" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = static_cast< int >(val5);
  ecode6 = SWIG_AsVal_double(argv[5], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "OpenBabel::OBElement" "', argument " "6"" of type '" "double""'");
  } 
  arg6 = static_cast< double >(val6);
  ecode7 = SWIG_AsVal_double(argv[6], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "OpenBabel::OBElement" "', argument " "7"" of type '" "double""'");
  } 
  arg7 = static_cast< double >(val7);
  ecode8 = SWIG_AsVal_double(argv[7], &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "OpenBabel::OBElement" "', argument " "8"" of type '" "double""'");
  } 
  arg8 = static_cast< double >(val8);
  ecode9 = SWIG_AsVal_double(argv[8], &val9);
  if (!SWIG_IsOK(ecode9)) {
    SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "OpenBabel::OBElement" "', argument " "9"" of type '" "double""'");
  } 
  arg9 = static_cast< double >(val9);
  ecode10 = SWIG_AsVal_double(argv[9], &val10);
  if (!SWIG_IsOK(ecode10)) {
    SWIG_exception_fail(SWIG_ArgError(ecode10), "in method '" "OpenBabel::OBElement" "', argument " "10"" of type '" "double""'");
  } 
  arg10 = static_cast< double >(val10);
  ecode11 = SWIG_AsVal_double(argv[10], &val11);
  if (!SWIG_IsOK(ecode11)) {
    SWIG_exception_fail(SWIG_ArgError(ecode11), "in method '" "OpenBabel::OBElement" "', argument " "11"" of type '" "double""'");
  } 
  arg11 = static_cast< double >(val11);
  ecode12 = SWIG_AsVal_double(argv[11], &val12);
  if (!SWIG_IsOK(ecode12)) {
    SWIG_exception_fail(SWIG_ArgError(ecode12), "in method '" "OpenBabel::OBElement" "', argument " "12"" of type '" "double""'");
  } 
  arg12 = static_cast< double >(val12);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(argv[12], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "OpenBabel::OBElement" "', argument " "13"" of type '" "std::string""'"); 
    }
    arg13 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = (OpenBabel::OBElement *)new OpenBabel::OBElement(arg1,(char const *)arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12,arg13);DATA_PTR(self) = result;
  
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return self;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_OBElement(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[13];
  int ii;
  
  argc = nargs;
  if (argc > 13) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_OBElement__SWIG_0(nargs, args, self);
  }
  if (argc == 13) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_double(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            {
              int res = SWIG_AsVal_int(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              {
                int res = SWIG_AsVal_double(argv[5], NULL);
                _v = SWIG_CheckState(res);
              }
              if (_v) {
                {
                  int res = SWIG_AsVal_double(argv[6], NULL);
                  _v = SWIG_CheckState(res);
                }
                if (_v) {
                  {
                    int res = SWIG_AsVal_double(argv[7], NULL);
                    _v = SWIG_CheckState(res);
                  }
                  if (_v) {
                    {
                      int res = SWIG_AsVal_double(argv[8], NULL);
                      _v = SWIG_CheckState(res);
                    }
                    if (_v) {
                      {
                        int res = SWIG_AsVal_double(argv[9], NULL);
                        _v = SWIG_CheckState(res);
                      }
                      if (_v) {
                        {
                          int res = SWIG_AsVal_double(argv[10], NULL);
                          _v = SWIG_CheckState(res);
                        }
                        if (_v) {
                          {
                            int res = SWIG_AsVal_double(argv[11], NULL);
                            _v = SWIG_CheckState(res);
                          }
                          if (_v) {
                            int res = SWIG_AsPtr_std_string(argv[12], (std::string**)(0));
                            _v = SWIG_CheckState(res);
                            if (_v) {
                              return _wrap_new_OBElement__SWIG_1(nargs, args, self);
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_OBElement'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBElement_get_atomic_num(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElement *arg1 = (OpenBabel::OBElement *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElement, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAtomicNum" "', argument " "1"" of type '" "OpenBabel::OBElement *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBElement * >(argp1);
  result = (int)(arg1)->GetAtomicNum();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBElement_get_symbol(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElement *arg1 = (OpenBabel::OBElement *) 0 ;
  char *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElement, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetSymbol" "', argument " "1"" of type '" "OpenBabel::OBElement *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBElement * >(argp1);
  result = (char *)(arg1)->GetSymbol();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBElement_get_covalent_rad(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElement *arg1 = (OpenBabel::OBElement *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElement, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetCovalentRad" "', argument " "1"" of type '" "OpenBabel::OBElement *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBElement * >(argp1);
  result = (double)(arg1)->GetCovalentRad();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBElement_get_vdw_rad(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElement *arg1 = (OpenBabel::OBElement *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElement, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetVdwRad" "', argument " "1"" of type '" "OpenBabel::OBElement *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBElement * >(argp1);
  result = (double)(arg1)->GetVdwRad();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBElement_get_mass(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElement *arg1 = (OpenBabel::OBElement *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElement, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetMass" "', argument " "1"" of type '" "OpenBabel::OBElement *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBElement * >(argp1);
  result = (double)(arg1)->GetMass();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBElement_get_max_bonds(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElement *arg1 = (OpenBabel::OBElement *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElement, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetMaxBonds" "', argument " "1"" of type '" "OpenBabel::OBElement *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBElement * >(argp1);
  result = (int)(arg1)->GetMaxBonds();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBElement_get_electro_neg(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElement *arg1 = (OpenBabel::OBElement *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElement, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetElectroNeg" "', argument " "1"" of type '" "OpenBabel::OBElement *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBElement * >(argp1);
  result = (double)(arg1)->GetElectroNeg();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBElement_get_ionization(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElement *arg1 = (OpenBabel::OBElement *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElement, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetIonization" "', argument " "1"" of type '" "OpenBabel::OBElement *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBElement * >(argp1);
  result = (double)(arg1)->GetIonization();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBElement_get_electron_affinity(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElement *arg1 = (OpenBabel::OBElement *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElement, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetElectronAffinity" "', argument " "1"" of type '" "OpenBabel::OBElement *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBElement * >(argp1);
  result = (double)(arg1)->GetElectronAffinity();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBElement_get_name(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElement *arg1 = (OpenBabel::OBElement *) 0 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElement, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetName" "', argument " "1"" of type '" "OpenBabel::OBElement *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBElement * >(argp1);
  result = (arg1)->GetName();
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBElement_get_red(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElement *arg1 = (OpenBabel::OBElement *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElement, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetRed" "', argument " "1"" of type '" "OpenBabel::OBElement *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBElement * >(argp1);
  result = (double)(arg1)->GetRed();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBElement_get_green(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElement *arg1 = (OpenBabel::OBElement *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElement, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetGreen" "', argument " "1"" of type '" "OpenBabel::OBElement *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBElement * >(argp1);
  result = (double)(arg1)->GetGreen();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBElement_get_blue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElement *arg1 = (OpenBabel::OBElement *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElement, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetBlue" "', argument " "1"" of type '" "OpenBabel::OBElement *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBElement * >(argp1);
  result = (double)(arg1)->GetBlue();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBElement(OpenBabel::OBElement *arg1) {
    delete arg1;
}

swig_class cOBElementTable;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBElementTable_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBElementTable_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBElementTable);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBElementTable(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElementTable *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBElementTable *)new OpenBabel::OBElementTable();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBElementTable(OpenBabel::OBElementTable *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_OBElementTable_parse_line(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElementTable *arg1 = (OpenBabel::OBElementTable *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElementTable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ParseLine" "', argument " "1"" of type '" "OpenBabel::OBElementTable *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBElementTable * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ParseLine" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  (arg1)->ParseLine((char const *)arg2);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBElementTable_get_number_of_elements(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElementTable *arg1 = (OpenBabel::OBElementTable *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElementTable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetNumberOfElements" "', argument " "1"" of type '" "OpenBabel::OBElementTable *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBElementTable * >(argp1);
  result = (unsigned int)(arg1)->GetNumberOfElements();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBElementTable_get_size(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElementTable *arg1 = (OpenBabel::OBElementTable *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElementTable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetSize" "', argument " "1"" of type '" "OpenBabel::OBElementTable *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBElementTable * >(argp1);
  result = (unsigned int)(arg1)->GetSize();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBElementTable_get_atomic_num__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElementTable *arg1 = (OpenBabel::OBElementTable *) 0 ;
  char *arg2 = (char *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElementTable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAtomicNum" "', argument " "1"" of type '" "OpenBabel::OBElementTable *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBElementTable * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetAtomicNum" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (int)(arg1)->GetAtomicNum((char const *)arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBElementTable_get_atomic_num__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElementTable *arg1 = (OpenBabel::OBElementTable *) 0 ;
  char *arg2 = (char *) 0 ;
  int *arg3 = 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElementTable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAtomicNum" "', argument " "1"" of type '" "OpenBabel::OBElementTable *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBElementTable * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetAtomicNum" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_int,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "GetAtomicNum" "', argument " "3"" of type '" "int &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GetAtomicNum" "', argument " "3"" of type '" "int &""'"); 
  }
  arg3 = reinterpret_cast< int * >(argp3);
  result = (int)(arg1)->GetAtomicNum((char const *)arg2,*arg3);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBElementTable_get_atomic_num(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBElementTable, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBElementTable_get_atomic_num__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBElementTable, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_int, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_OBElementTable_get_atomic_num__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBElementTable_get_atomic_num'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBElementTable_get_symbol(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElementTable *arg1 = (OpenBabel::OBElementTable *) 0 ;
  int arg2 ;
  char *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElementTable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetSymbol" "', argument " "1"" of type '" "OpenBabel::OBElementTable *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBElementTable * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetSymbol" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (char *)(arg1)->GetSymbol(arg2);
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBElementTable_get_vdw_rad(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElementTable *arg1 = (OpenBabel::OBElementTable *) 0 ;
  int arg2 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElementTable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetVdwRad" "', argument " "1"" of type '" "OpenBabel::OBElementTable *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBElementTable * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetVdwRad" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (double)(arg1)->GetVdwRad(arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBElementTable_get_covalent_rad(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElementTable *arg1 = (OpenBabel::OBElementTable *) 0 ;
  int arg2 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElementTable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetCovalentRad" "', argument " "1"" of type '" "OpenBabel::OBElementTable *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBElementTable * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetCovalentRad" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (double)(arg1)->GetCovalentRad(arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBElementTable_get_mass(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElementTable *arg1 = (OpenBabel::OBElementTable *) 0 ;
  int arg2 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElementTable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetMass" "', argument " "1"" of type '" "OpenBabel::OBElementTable *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBElementTable * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetMass" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (double)(arg1)->GetMass(arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBElementTable_corrected_bond_rad__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElementTable *arg1 = (OpenBabel::OBElementTable *) 0 ;
  int arg2 ;
  int arg3 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElementTable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CorrectedBondRad" "', argument " "1"" of type '" "OpenBabel::OBElementTable *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBElementTable * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CorrectedBondRad" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "CorrectedBondRad" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  result = (double)(arg1)->CorrectedBondRad(arg2,arg3);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBElementTable_corrected_bond_rad__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElementTable *arg1 = (OpenBabel::OBElementTable *) 0 ;
  int arg2 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElementTable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CorrectedBondRad" "', argument " "1"" of type '" "OpenBabel::OBElementTable *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBElementTable * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CorrectedBondRad" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (double)(arg1)->CorrectedBondRad(arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBElementTable_corrected_bond_rad(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBElementTable, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBElementTable_corrected_bond_rad__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBElementTable, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_OBElementTable_corrected_bond_rad__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBElementTable_corrected_bond_rad'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBElementTable_corrected_vdw_rad__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElementTable *arg1 = (OpenBabel::OBElementTable *) 0 ;
  int arg2 ;
  int arg3 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElementTable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CorrectedVdwRad" "', argument " "1"" of type '" "OpenBabel::OBElementTable *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBElementTable * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CorrectedVdwRad" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "CorrectedVdwRad" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  result = (double)(arg1)->CorrectedVdwRad(arg2,arg3);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBElementTable_corrected_vdw_rad__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElementTable *arg1 = (OpenBabel::OBElementTable *) 0 ;
  int arg2 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElementTable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CorrectedVdwRad" "', argument " "1"" of type '" "OpenBabel::OBElementTable *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBElementTable * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CorrectedVdwRad" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (double)(arg1)->CorrectedVdwRad(arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBElementTable_corrected_vdw_rad(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBElementTable, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBElementTable_corrected_vdw_rad__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBElementTable, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_OBElementTable_corrected_vdw_rad__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBElementTable_corrected_vdw_rad'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBElementTable_get_max_bonds(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElementTable *arg1 = (OpenBabel::OBElementTable *) 0 ;
  int arg2 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElementTable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetMaxBonds" "', argument " "1"" of type '" "OpenBabel::OBElementTable *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBElementTable * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetMaxBonds" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (int)(arg1)->GetMaxBonds(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBElementTable_get_electro_neg(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElementTable *arg1 = (OpenBabel::OBElementTable *) 0 ;
  int arg2 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElementTable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetElectroNeg" "', argument " "1"" of type '" "OpenBabel::OBElementTable *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBElementTable * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetElectroNeg" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (double)(arg1)->GetElectroNeg(arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBElementTable_get_ionization(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElementTable *arg1 = (OpenBabel::OBElementTable *) 0 ;
  int arg2 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElementTable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetIonization" "', argument " "1"" of type '" "OpenBabel::OBElementTable *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBElementTable * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetIonization" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (double)(arg1)->GetIonization(arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBElementTable_get_electron_affinity(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElementTable *arg1 = (OpenBabel::OBElementTable *) 0 ;
  int arg2 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElementTable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetElectronAffinity" "', argument " "1"" of type '" "OpenBabel::OBElementTable *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBElementTable * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetElectronAffinity" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (double)(arg1)->GetElectronAffinity(arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBElementTable_get_rgb(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElementTable *arg1 = (OpenBabel::OBElementTable *) 0 ;
  int arg2 ;
  std::vector<double > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElementTable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetRGB" "', argument " "1"" of type '" "OpenBabel::OBElementTable *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBElementTable * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetRGB" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (arg1)->GetRGB(arg2);
  {
    vresult = rb_ary_new2((&result)->size());
    for (unsigned int i=0; i<(&result)->size(); i++)
    rb_ary_store(vresult,i,rb_float_new(((std::vector<double > &)result)[i]));
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBElementTable_get_name(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElementTable *arg1 = (OpenBabel::OBElementTable *) 0 ;
  int arg2 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElementTable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetName" "', argument " "1"" of type '" "OpenBabel::OBElementTable *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBElementTable * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetName" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (arg1)->GetName(arg2);
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


swig_class cOBIsotopeTable;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBIsotopeTable_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBIsotopeTable_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBIsotopeTable);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBIsotopeTable(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBIsotopeTable *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBIsotopeTable *)new OpenBabel::OBIsotopeTable();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBIsotopeTable(OpenBabel::OBIsotopeTable *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_OBIsotopeTable_get_size(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBIsotopeTable *arg1 = (OpenBabel::OBIsotopeTable *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBIsotopeTable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetSize" "', argument " "1"" of type '" "OpenBabel::OBIsotopeTable *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBIsotopeTable * >(argp1);
  result = (unsigned int)(arg1)->GetSize();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBIsotopeTable_parse_line(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBIsotopeTable *arg1 = (OpenBabel::OBIsotopeTable *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBIsotopeTable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ParseLine" "', argument " "1"" of type '" "OpenBabel::OBIsotopeTable *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBIsotopeTable * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ParseLine" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  (arg1)->ParseLine((char const *)arg2);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBIsotopeTable_get_exact_mass__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBIsotopeTable *arg1 = (OpenBabel::OBIsotopeTable *) 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBIsotopeTable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetExactMass" "', argument " "1"" of type '" "OpenBabel::OBIsotopeTable *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBIsotopeTable * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetExactMass" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "GetExactMass" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  result = (double)(arg1)->GetExactMass(arg2,arg3);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBIsotopeTable_get_exact_mass__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBIsotopeTable *arg1 = (OpenBabel::OBIsotopeTable *) 0 ;
  unsigned int arg2 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBIsotopeTable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetExactMass" "', argument " "1"" of type '" "OpenBabel::OBIsotopeTable *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBIsotopeTable * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetExactMass" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (double)(arg1)->GetExactMass(arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBIsotopeTable_get_exact_mass(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBIsotopeTable, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBIsotopeTable_get_exact_mass__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBIsotopeTable, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_OBIsotopeTable_get_exact_mass__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBIsotopeTable_get_exact_mass'");
  return Qnil;
}


swig_class cOBTypeTable;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBTypeTable_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBTypeTable_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBTypeTable);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBTypeTable(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTypeTable *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBTypeTable *)new OpenBabel::OBTypeTable();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBTypeTable(OpenBabel::OBTypeTable *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_OBTypeTable_parse_line(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTypeTable *arg1 = (OpenBabel::OBTypeTable *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTypeTable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ParseLine" "', argument " "1"" of type '" "OpenBabel::OBTypeTable *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBTypeTable * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ParseLine" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  (arg1)->ParseLine((char const *)arg2);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBTypeTable_get_size(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTypeTable *arg1 = (OpenBabel::OBTypeTable *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTypeTable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetSize" "', argument " "1"" of type '" "OpenBabel::OBTypeTable *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBTypeTable * >(argp1);
  result = (unsigned int)(arg1)->GetSize();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBTypeTable_set_from_type(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTypeTable *arg1 = (OpenBabel::OBTypeTable *) 0 ;
  char *arg2 = (char *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTypeTable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetFromType" "', argument " "1"" of type '" "OpenBabel::OBTypeTable *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBTypeTable * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetFromType" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (bool)(arg1)->SetFromType((char const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBTypeTable_set_to_type(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTypeTable *arg1 = (OpenBabel::OBTypeTable *) 0 ;
  char *arg2 = (char *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTypeTable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetToType" "', argument " "1"" of type '" "OpenBabel::OBTypeTable *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBTypeTable * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetToType" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (bool)(arg1)->SetToType((char const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBTypeTable_translate__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTypeTable *arg1 = (OpenBabel::OBTypeTable *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTypeTable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Translate" "', argument " "1"" of type '" "OpenBabel::OBTypeTable *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBTypeTable * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Translate" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[1], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Translate" "', argument " "3"" of type '" "char const *""'");
  }
  arg3 = reinterpret_cast< char * >(buf3);
  result = (bool)(arg1)->Translate(arg2,(char const *)arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBTypeTable_translate__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTypeTable *arg1 = (OpenBabel::OBTypeTable *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int res3 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTypeTable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Translate" "', argument " "1"" of type '" "OpenBabel::OBTypeTable *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBTypeTable * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__string,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Translate" "', argument " "2"" of type '" "std::string &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Translate" "', argument " "2"" of type '" "std::string &""'"); 
  }
  arg2 = reinterpret_cast< std::string * >(argp2);
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Translate" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Translate" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  result = (bool)(arg1)->Translate(*arg2,(std::string const &)*arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res3)) delete arg3;
  return vresult;
fail:
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBTypeTable_translate__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTypeTable *arg1 = (OpenBabel::OBTypeTable *) 0 ;
  std::string *arg2 = 0 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTypeTable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Translate" "', argument " "1"" of type '" "OpenBabel::OBTypeTable *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBTypeTable * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Translate" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Translate" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (arg1)->Translate((std::string const &)*arg2);
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBTypeTable_translate(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBTypeTable, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBTypeTable_translate__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBTypeTable, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__string, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_OBTypeTable_translate__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBTypeTable, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_OBTypeTable_translate__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBTypeTable_translate'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBTypeTable_get_from_type(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTypeTable *arg1 = (OpenBabel::OBTypeTable *) 0 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTypeTable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetFromType" "', argument " "1"" of type '" "OpenBabel::OBTypeTable *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBTypeTable * >(argp1);
  result = (arg1)->GetFromType();
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBTypeTable_get_to_type(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTypeTable *arg1 = (OpenBabel::OBTypeTable *) 0 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTypeTable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetToType" "', argument " "1"" of type '" "OpenBabel::OBTypeTable *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBTypeTable * >(argp1);
  result = (arg1)->GetToType();
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


swig_class cOBResidueData;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBResidueData_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBResidueData_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBResidueData);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBResidueData(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueData *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBResidueData *)new OpenBabel::OBResidueData();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueData_parse_line(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueData *arg1 = (OpenBabel::OBResidueData *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ParseLine" "', argument " "1"" of type '" "OpenBabel::OBResidueData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueData * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ParseLine" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  (arg1)->ParseLine((char const *)arg2);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueData_get_size(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueData *arg1 = (OpenBabel::OBResidueData *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetSize" "', argument " "1"" of type '" "OpenBabel::OBResidueData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueData * >(argp1);
  result = (unsigned int)(arg1)->GetSize();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueData_set_res_name(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueData *arg1 = (OpenBabel::OBResidueData *) 0 ;
  std::string *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetResName" "', argument " "1"" of type '" "OpenBabel::OBResidueData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueData * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetResName" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetResName" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (bool)(arg1)->SetResName((std::string const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueData_lookup_bo__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueData *arg1 = (OpenBabel::OBResidueData *) 0 ;
  std::string *arg2 = 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LookupBO" "', argument " "1"" of type '" "OpenBabel::OBResidueData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueData * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "LookupBO" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "LookupBO" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->LookupBO((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueData_lookup_bo__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueData *arg1 = (OpenBabel::OBResidueData *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LookupBO" "', argument " "1"" of type '" "OpenBabel::OBResidueData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueData * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "LookupBO" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "LookupBO" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "LookupBO" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "LookupBO" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  result = (int)(arg1)->LookupBO((std::string const &)*arg2,(std::string const &)*arg3);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBResidueData_lookup_bo(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueData, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBResidueData_lookup_bo__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueData, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_OBResidueData_lookup_bo__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBResidueData_lookup_bo'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueData_lookup_type(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueData *arg1 = (OpenBabel::OBResidueData *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  int *arg4 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LookupType" "', argument " "1"" of type '" "OpenBabel::OBResidueData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueData * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "LookupType" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "LookupType" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_std__string,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "LookupType" "', argument " "3"" of type '" "std::string &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "LookupType" "', argument " "3"" of type '" "std::string &""'"); 
  }
  arg3 = reinterpret_cast< std::string * >(argp3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4, SWIGTYPE_p_int,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "LookupType" "', argument " "4"" of type '" "int &""'"); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "LookupType" "', argument " "4"" of type '" "int &""'"); 
  }
  arg4 = reinterpret_cast< int * >(argp4);
  result = (bool)(arg1)->LookupType((std::string const &)*arg2,*arg3,*arg4);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueData_assign_bonds(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueData *arg1 = (OpenBabel::OBResidueData *) 0 ;
  OpenBabel::OBMol *arg2 = 0 ;
  OpenBabel::OBBitVec *arg3 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AssignBonds" "', argument " "1"" of type '" "OpenBabel::OBResidueData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBMol,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AssignBonds" "', argument " "2"" of type '" "OpenBabel::OBMol &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "AssignBonds" "', argument " "2"" of type '" "OpenBabel::OBMol &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_OpenBabel__OBBitVec,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "AssignBonds" "', argument " "3"" of type '" "OpenBabel::OBBitVec &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "AssignBonds" "', argument " "3"" of type '" "OpenBabel::OBBitVec &""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBBitVec * >(argp3);
  result = (bool)(arg1)->AssignBonds(*arg2,*arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBResidueData(OpenBabel::OBResidueData *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_open_datafile__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::ifstream *arg1 = 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_std__ifstream,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OpenDatafile" "', argument " "1"" of type '" "std::ifstream &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OpenDatafile" "', argument " "1"" of type '" "std::ifstream &""'"); 
  }
  arg1 = reinterpret_cast< std::ifstream * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::OpenDatafile" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OpenDatafile" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(argv[2], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "OpenBabel::OpenDatafile" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OpenDatafile" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  result = OpenBabel::OpenDatafile(*arg1,(std::string const &)*arg2,(std::string const &)*arg3);
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_open_datafile__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::ifstream *arg1 = 0 ;
  std::string *arg2 = 0 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_std__ifstream,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OpenDatafile" "', argument " "1"" of type '" "std::ifstream &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OpenDatafile" "', argument " "1"" of type '" "std::ifstream &""'"); 
  }
  arg1 = reinterpret_cast< std::ifstream * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::OpenDatafile" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OpenDatafile" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = OpenBabel::OpenDatafile(*arg1,(std::string const &)*arg2);
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_open_datafile(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs;
  if (argc > 3) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__ifstream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_open_datafile__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__ifstream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_open_datafile__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'open_datafile'");
  return Qnil;
}


swig_class cDoubleType;

SWIGINTERN VALUE
_wrap_DoubleType_hi_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::DoubleType *arg1 = (OpenBabel::DoubleType *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__DoubleType, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "hi" "', argument " "1"" of type '" "OpenBabel::DoubleType *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::DoubleType * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "hi" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  if (arg1) (arg1)->hi = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DoubleType_hi_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::DoubleType *arg1 = (OpenBabel::DoubleType *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__DoubleType, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "hi" "', argument " "1"" of type '" "OpenBabel::DoubleType *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::DoubleType * >(argp1);
  result = (unsigned int) ((arg1)->hi);
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DoubleType_lo_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::DoubleType *arg1 = (OpenBabel::DoubleType *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__DoubleType, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lo" "', argument " "1"" of type '" "OpenBabel::DoubleType *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::DoubleType * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "lo" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  if (arg1) (arg1)->lo = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DoubleType_lo_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::DoubleType *arg1 = (OpenBabel::DoubleType *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__DoubleType, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lo" "', argument " "1"" of type '" "OpenBabel::DoubleType *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::DoubleType * >(argp1);
  result = (unsigned int) ((arg1)->lo);
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_DoubleType_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_DoubleType_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__DoubleType);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_DoubleType(int argc, VALUE *argv, VALUE self) {
  OpenBabel::DoubleType *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::DoubleType *)new OpenBabel::DoubleType();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_DoubleType(OpenBabel::DoubleType *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_double_multiply(int argc, VALUE *argv, VALUE self) {
  unsigned int arg1 ;
  unsigned int arg2 ;
  OpenBabel::DoubleType *arg3 = (OpenBabel::DoubleType *) 0 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "OpenBabel::DoubleMultiply" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "OpenBabel::DoubleMultiply" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_OpenBabel__DoubleType, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "OpenBabel::DoubleMultiply" "', argument " "3"" of type '" "OpenBabel::DoubleType *""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::DoubleType * >(argp3);
  OpenBabel::DoubleMultiply(arg1,arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_double_add(int argc, VALUE *argv, VALUE self) {
  OpenBabel::DoubleType *arg1 = (OpenBabel::DoubleType *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_OpenBabel__DoubleType, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::DoubleAdd" "', argument " "1"" of type '" "OpenBabel::DoubleType *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::DoubleType * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "OpenBabel::DoubleAdd" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  OpenBabel::DoubleAdd(arg1,arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_double_modulus(int argc, VALUE *argv, VALUE self) {
  OpenBabel::DoubleType *arg1 = (OpenBabel::DoubleType *) 0 ;
  unsigned int arg2 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_OpenBabel__DoubleType, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::DoubleModulus" "', argument " "1"" of type '" "OpenBabel::DoubleType *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::DoubleType * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "OpenBabel::DoubleModulus" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (unsigned int)OpenBabel::DoubleModulus(arg1,arg2);
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


swig_class cOBRandom;

SWIGINTERN VALUE
_wrap_new_OBRandom__SWIG_0(int argc, VALUE *argv, VALUE self) {
  bool arg1 ;
  OpenBabel::OBRandom *result = 0 ;
  bool val1 ;
  int ecode1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_bool(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "OpenBabel::OBRandom" "', argument " "1"" of type '" "bool""'");
  } 
  arg1 = static_cast< bool >(val1);
  result = (OpenBabel::OBRandom *)new OpenBabel::OBRandom(arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBRandom_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBRandom_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBRandom);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBRandom__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRandom *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBRandom *)new OpenBabel::OBRandom();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_OBRandom(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_OBRandom__SWIG_1(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_bool(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_OBRandom__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_OBRandom'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBRandom_seed(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRandom *arg1 = (OpenBabel::OBRandom *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRandom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Seed" "', argument " "1"" of type '" "OpenBabel::OBRandom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBRandom * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Seed" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->Seed(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBRandom_time_seed(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRandom *arg1 = (OpenBabel::OBRandom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRandom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TimeSeed" "', argument " "1"" of type '" "OpenBabel::OBRandom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBRandom * >(argp1);
  (arg1)->TimeSeed();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBRandom_next_int(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRandom *arg1 = (OpenBabel::OBRandom *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRandom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NextInt" "', argument " "1"" of type '" "OpenBabel::OBRandom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBRandom * >(argp1);
  result = (int)(arg1)->NextInt();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBRandom_next_float(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRandom *arg1 = (OpenBabel::OBRandom *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRandom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NextFloat" "', argument " "1"" of type '" "OpenBabel::OBRandom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBRandom * >(argp1);
  result = (double)(arg1)->NextFloat();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBRandom(OpenBabel::OBRandom *arg1) {
    delete arg1;
}

swig_class cOBStopwatch;

SWIGINTERN VALUE
_wrap_OBStopwatch_start(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBStopwatch *arg1 = (OpenBabel::OBStopwatch *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBStopwatch, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Start" "', argument " "1"" of type '" "OpenBabel::OBStopwatch *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBStopwatch * >(argp1);
  (arg1)->Start();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBStopwatch_lap(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBStopwatch *arg1 = (OpenBabel::OBStopwatch *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBStopwatch, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Lap" "', argument " "1"" of type '" "OpenBabel::OBStopwatch *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBStopwatch * >(argp1);
  result = (double)(arg1)->Lap();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBStopwatch_elapsed(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBStopwatch *arg1 = (OpenBabel::OBStopwatch *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBStopwatch, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Elapsed" "', argument " "1"" of type '" "OpenBabel::OBStopwatch *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBStopwatch * >(argp1);
  result = (double)(arg1)->Elapsed();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBStopwatch_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBStopwatch_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBStopwatch);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBStopwatch(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBStopwatch *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBStopwatch *)new OpenBabel::OBStopwatch();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBStopwatch(OpenBabel::OBStopwatch *arg1) {
    delete arg1;
}

swig_class cOBSqrtTbl;

SWIGINTERN VALUE
_wrap_new_OBSqrtTbl__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSqrtTbl *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBSqrtTbl *)new OpenBabel::OBSqrtTbl();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBSqrtTbl_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBSqrtTbl_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBSqrtTbl);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBSqrtTbl__SWIG_1(int argc, VALUE *argv, VALUE self) {
  double arg1 ;
  double arg2 ;
  OpenBabel::OBSqrtTbl *result = 0 ;
  double val1 ;
  int ecode1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_double(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "OpenBabel::OBSqrtTbl" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  ecode2 = SWIG_AsVal_double(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "OpenBabel::OBSqrtTbl" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  result = (OpenBabel::OBSqrtTbl *)new OpenBabel::OBSqrtTbl(arg1,arg2);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_OBSqrtTbl(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_OBSqrtTbl__SWIG_0(nargs, args, self);
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_double(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_OBSqrtTbl__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_OBSqrtTbl'");
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBSqrtTbl(OpenBabel::OBSqrtTbl *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_OBSqrtTbl_sqrt(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSqrtTbl *arg1 = (OpenBabel::OBSqrtTbl *) 0 ;
  double arg2 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSqrtTbl, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sqrt" "', argument " "1"" of type '" "OpenBabel::OBSqrtTbl const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSqrtTbl * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Sqrt" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  result = (double)((OpenBabel::OBSqrtTbl const *)arg1)->Sqrt(arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSqrtTbl_init(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSqrtTbl *arg1 = (OpenBabel::OBSqrtTbl *) 0 ;
  double arg2 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSqrtTbl, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Init" "', argument " "1"" of type '" "OpenBabel::OBSqrtTbl *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSqrtTbl * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Init" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Init" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  (arg1)->Init(arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


swig_class cVector3;

SWIGINTERN VALUE
_wrap_new_Vector3__SWIG_0(int argc, VALUE *argv, VALUE self) {
  double arg1 ;
  double arg2 ;
  double arg3 ;
  OpenBabel::vector3 *result = 0 ;
  double val1 ;
  int ecode1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_double(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "OpenBabel::vector3" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  ecode2 = SWIG_AsVal_double(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "OpenBabel::vector3" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "OpenBabel::vector3" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  result = (OpenBabel::vector3 *)new OpenBabel::vector3(arg1,arg2,arg3);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_Vector3__SWIG_1(int argc, VALUE *argv, VALUE self) {
  double arg1 ;
  double arg2 ;
  OpenBabel::vector3 *result = 0 ;
  double val1 ;
  int ecode1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_double(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "OpenBabel::vector3" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  ecode2 = SWIG_AsVal_double(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "OpenBabel::vector3" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  result = (OpenBabel::vector3 *)new OpenBabel::vector3(arg1,arg2);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_Vector3__SWIG_2(int argc, VALUE *argv, VALUE self) {
  double arg1 ;
  OpenBabel::vector3 *result = 0 ;
  double val1 ;
  int ecode1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_double(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "OpenBabel::vector3" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  result = (OpenBabel::vector3 *)new OpenBabel::vector3(arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_Vector3__SWIG_3(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::vector3 *)new OpenBabel::vector3();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_Vector3_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_Vector3_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__vector3);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_Vector3__SWIG_4(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = 0 ;
  OpenBabel::vector3 *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::vector3" "', argument " "1"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::vector3" "', argument " "1"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  result = (OpenBabel::vector3 *)new OpenBabel::vector3((OpenBabel::vector3 const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_Vector3(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs;
  if (argc > 3) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_Vector3__SWIG_3(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__vector3, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Vector3__SWIG_4(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_double(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_Vector3__SWIG_2(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_double(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_Vector3__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      int res = SWIG_AsVal_double(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_Vector3__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_Vector3'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Vector3_set__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = (OpenBabel::vector3 *) 0 ;
  double arg2 ;
  double arg3 ;
  double arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Set" "', argument " "1"" of type '" "OpenBabel::vector3 *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Set" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Set" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  ecode4 = SWIG_AsVal_double(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Set" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = static_cast< double >(val4);
  (arg1)->Set(arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Vector3_set__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = (OpenBabel::vector3 *) 0 ;
  double *arg2 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Set" "', argument " "1"" of type '" "OpenBabel::vector3 *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Set" "', argument " "2"" of type '" "double const *""'"); 
  }
  arg2 = reinterpret_cast< double * >(argp2);
  (arg1)->Set((double const *)arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Vector3_set(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__vector3, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_double, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Vector3_set__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__vector3, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_double(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_Vector3_set__SWIG_0(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'Vector3_set'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Vector3_set_x(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = (OpenBabel::vector3 *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetX" "', argument " "1"" of type '" "OpenBabel::vector3 *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetX" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  (arg1)->SetX(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Vector3_set_y(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = (OpenBabel::vector3 *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetY" "', argument " "1"" of type '" "OpenBabel::vector3 *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetY" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  (arg1)->SetY(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Vector3_set_z(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = (OpenBabel::vector3 *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetZ" "', argument " "1"" of type '" "OpenBabel::vector3 *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetZ" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  (arg1)->SetZ(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Vector3_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = (OpenBabel::vector3 *) 0 ;
  double *arg2 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Get" "', argument " "1"" of type '" "OpenBabel::vector3 *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Get" "', argument " "2"" of type '" "double *""'"); 
  }
  arg2 = reinterpret_cast< double * >(argp2);
  (arg1)->Get(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Vector3_as_array(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = (OpenBabel::vector3 *) 0 ;
  double *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AsArray" "', argument " "1"" of type '" "OpenBabel::vector3 const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  result = (double *)((OpenBabel::vector3 const *)arg1)->AsArray();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Vector3_random_unit_vector__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = (OpenBabel::vector3 *) 0 ;
  OpenBabel::OBRandom *arg2 = (OpenBabel::OBRandom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "randomUnitVector" "', argument " "1"" of type '" "OpenBabel::vector3 *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBRandom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "randomUnitVector" "', argument " "2"" of type '" "OpenBabel::OBRandom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBRandom * >(argp2);
  (arg1)->randomUnitVector(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Vector3_random_unit_vector__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = (OpenBabel::vector3 *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "randomUnitVector" "', argument " "1"" of type '" "OpenBabel::vector3 *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  (arg1)->randomUnitVector();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Vector3_random_unit_vector(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__vector3, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Vector3_random_unit_vector__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__vector3, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBRandom, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Vector3_random_unit_vector__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'Vector3_random_unit_vector'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Vector3_normalize(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = (OpenBabel::vector3 *) 0 ;
  OpenBabel::vector3 *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "normalize" "', argument " "1"" of type '" "OpenBabel::vector3 *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  {
    OpenBabel::vector3 &_result_ref = (arg1)->normalize();
    result = (OpenBabel::vector3 *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Vector3_can_be_normalized(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = (OpenBabel::vector3 *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CanBeNormalized" "', argument " "1"" of type '" "OpenBabel::vector3 const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  result = (bool)((OpenBabel::vector3 const *)arg1)->CanBeNormalized();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Vector3_length_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = (OpenBabel::vector3 *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "length_2" "', argument " "1"" of type '" "OpenBabel::vector3 const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  result = (double)((OpenBabel::vector3 const *)arg1)->length_2();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Vector3_length(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = (OpenBabel::vector3 *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "length" "', argument " "1"" of type '" "OpenBabel::vector3 const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  result = (double)((OpenBabel::vector3 const *)arg1)->length();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Vector3_x__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = (OpenBabel::vector3 *) 0 ;
  double *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "x" "', argument " "1"" of type '" "OpenBabel::vector3 const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  {
    double const &_result_ref = ((OpenBabel::vector3 const *)arg1)->x();
    result = (double *) &_result_ref;
  }
  vresult = SWIG_From_double(static_cast< double >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Vector3_y__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = (OpenBabel::vector3 *) 0 ;
  double *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "y" "', argument " "1"" of type '" "OpenBabel::vector3 const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  {
    double const &_result_ref = ((OpenBabel::vector3 const *)arg1)->y();
    result = (double *) &_result_ref;
  }
  vresult = SWIG_From_double(static_cast< double >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Vector3_z__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = (OpenBabel::vector3 *) 0 ;
  double *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "z" "', argument " "1"" of type '" "OpenBabel::vector3 const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  {
    double const &_result_ref = ((OpenBabel::vector3 const *)arg1)->z();
    result = (double *) &_result_ref;
  }
  vresult = SWIG_From_double(static_cast< double >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Vector3_x__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = (OpenBabel::vector3 *) 0 ;
  double *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "x" "', argument " "1"" of type '" "OpenBabel::vector3 *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  {
    double &_result_ref = (arg1)->x();
    result = (double *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Vector3_x(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__vector3, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Vector3_x__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__vector3, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Vector3_x__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'Vector3_x'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Vector3_y__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = (OpenBabel::vector3 *) 0 ;
  double *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "y" "', argument " "1"" of type '" "OpenBabel::vector3 *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  {
    double &_result_ref = (arg1)->y();
    result = (double *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Vector3_y(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__vector3, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Vector3_y__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__vector3, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Vector3_y__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'Vector3_y'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Vector3_z__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = (OpenBabel::vector3 *) 0 ;
  double *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "z" "', argument " "1"" of type '" "OpenBabel::vector3 *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  {
    double &_result_ref = (arg1)->z();
    result = (double *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Vector3_z(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__vector3, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Vector3_z__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__vector3, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Vector3_z__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'Vector3_z'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Vector3___eq__(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = (OpenBabel::vector3 *) 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator ==" "', argument " "1"" of type '" "OpenBabel::vector3 const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "operator ==" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "operator ==" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  result = (int)((OpenBabel::vector3 const *)arg1)->operator ==((OpenBabel::vector3 const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Vector3_is_approx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = (OpenBabel::vector3 *) 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  double *arg3 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  double temp3 ;
  double val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsApprox" "', argument " "1"" of type '" "OpenBabel::vector3 const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "IsApprox" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "IsApprox" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  ecode3 = SWIG_AsVal_double(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "IsApprox" "', argument " "3"" of type '" "double""'");
  } 
  temp3 = static_cast< double >(val3);
  arg3 = &temp3;
  result = (bool)((OpenBabel::vector3 const *)arg1)->IsApprox((OpenBabel::vector3 const &)*arg2,(double const &)*arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Vector3_dist_sq(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = (OpenBabel::vector3 *) 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "distSq" "', argument " "1"" of type '" "OpenBabel::vector3 const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "distSq" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "distSq" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  result = (double)((OpenBabel::vector3 const *)arg1)->distSq((OpenBabel::vector3 const &)*arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Vector3_create_ortho_vector(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = (OpenBabel::vector3 *) 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "createOrthoVector" "', argument " "1"" of type '" "OpenBabel::vector3 const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "createOrthoVector" "', argument " "2"" of type '" "OpenBabel::vector3 &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "createOrthoVector" "', argument " "2"" of type '" "OpenBabel::vector3 &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  result = (bool)((OpenBabel::vector3 const *)arg1)->createOrthoVector(*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_vector3(OpenBabel::vector3 *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap___lshift__(int argc, VALUE *argv, VALUE self) {
  std::ostream *arg1 = 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  std::ostream *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_std__ostream,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::operator <<" "', argument " "1"" of type '" "std::ostream &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::operator <<" "', argument " "1"" of type '" "std::ostream &""'"); 
  }
  arg1 = reinterpret_cast< std::ostream * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::operator <<" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::operator <<" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  {
    std::ostream &_result_ref = OpenBabel::operator <<(*arg1,(OpenBabel::vector3 const &)*arg2);
    result = (std::ostream *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__ostream, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap___add__(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  OpenBabel::vector3 result;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::operator +" "', argument " "1"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::operator +" "', argument " "1"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::operator +" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::operator +" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  result = OpenBabel::operator +((OpenBabel::vector3 const &)*arg1,(OpenBabel::vector3 const &)*arg2);
  vresult = SWIG_NewPointerObj((new OpenBabel::vector3(static_cast< const OpenBabel::vector3& >(result))), SWIGTYPE_p_OpenBabel__vector3, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap___sub____SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  OpenBabel::vector3 result;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::operator -" "', argument " "1"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::operator -" "', argument " "1"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::operator -" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::operator -" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  result = OpenBabel::operator -((OpenBabel::vector3 const &)*arg1,(OpenBabel::vector3 const &)*arg2);
  vresult = SWIG_NewPointerObj((new OpenBabel::vector3(static_cast< const OpenBabel::vector3& >(result))), SWIGTYPE_p_OpenBabel__vector3, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap___sub____SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = 0 ;
  OpenBabel::vector3 result;
  void *argp1 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::operator -" "', argument " "1"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::operator -" "', argument " "1"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  result = OpenBabel::operator -((OpenBabel::vector3 const &)*arg1);
  vresult = SWIG_NewPointerObj((new OpenBabel::vector3(static_cast< const OpenBabel::vector3& >(result))), SWIGTYPE_p_OpenBabel__vector3, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap___sub__(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__vector3, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap___sub____SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__vector3, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__vector3, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap___sub____SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded '__sub__'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap___mul____SWIG_0(int argc, VALUE *argv, VALUE self) {
  double *arg1 = 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  OpenBabel::vector3 result;
  double temp1 ;
  double val1 ;
  int ecode1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_double(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "OpenBabel::operator *" "', argument " "1"" of type '" "double""'");
  } 
  temp1 = static_cast< double >(val1);
  arg1 = &temp1;
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::operator *" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::operator *" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  result = OpenBabel::operator *((double const &)*arg1,(OpenBabel::vector3 const &)*arg2);
  vresult = SWIG_NewPointerObj((new OpenBabel::vector3(static_cast< const OpenBabel::vector3& >(result))), SWIGTYPE_p_OpenBabel__vector3, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap___mul____SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = 0 ;
  double *arg2 = 0 ;
  OpenBabel::vector3 result;
  void *argp1 ;
  int res1 = 0 ;
  double temp2 ;
  double val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::operator *" "', argument " "1"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::operator *" "', argument " "1"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "OpenBabel::operator *" "', argument " "2"" of type '" "double""'");
  } 
  temp2 = static_cast< double >(val2);
  arg2 = &temp2;
  result = OpenBabel::operator *((OpenBabel::vector3 const &)*arg1,(double const &)*arg2);
  vresult = SWIG_NewPointerObj((new OpenBabel::vector3(static_cast< const OpenBabel::vector3& >(result))), SWIGTYPE_p_OpenBabel__vector3, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap___div__(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = 0 ;
  double *arg2 = 0 ;
  OpenBabel::vector3 result;
  void *argp1 ;
  int res1 = 0 ;
  double temp2 ;
  double val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::operator /" "', argument " "1"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::operator /" "', argument " "1"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "OpenBabel::operator /" "', argument " "2"" of type '" "double""'");
  } 
  temp2 = static_cast< double >(val2);
  arg2 = &temp2;
  result = OpenBabel::operator /((OpenBabel::vector3 const &)*arg1,(double const &)*arg2);
  vresult = SWIG_NewPointerObj((new OpenBabel::vector3(static_cast< const OpenBabel::vector3& >(result))), SWIGTYPE_p_OpenBabel__vector3, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap___mul____SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::matrix3x3 *arg1 = 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  OpenBabel::vector3 result;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__matrix3x3,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::operator *" "', argument " "1"" of type '" "OpenBabel::matrix3x3 const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::operator *" "', argument " "1"" of type '" "OpenBabel::matrix3x3 const &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::matrix3x3 * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::operator *" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::operator *" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  result = OpenBabel::operator *((OpenBabel::matrix3x3 const &)*arg1,(OpenBabel::vector3 const &)*arg2);
  vresult = SWIG_NewPointerObj((new OpenBabel::vector3(static_cast< const OpenBabel::vector3& >(result))), SWIGTYPE_p_OpenBabel__vector3, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap___mul__(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__vector3, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap___mul____SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__matrix3x3, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__vector3, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap___mul____SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_double(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__vector3, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap___mul____SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded '__mul__'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_dot(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  double result;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::dot" "', argument " "1"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::dot" "', argument " "1"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::dot" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::dot" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  result = (double)OpenBabel::dot((OpenBabel::vector3 const &)*arg1,(OpenBabel::vector3 const &)*arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_cross(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  OpenBabel::vector3 result;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::cross" "', argument " "1"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::cross" "', argument " "1"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::cross" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::cross" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  result = OpenBabel::cross((OpenBabel::vector3 const &)*arg1,(OpenBabel::vector3 const &)*arg2);
  vresult = SWIG_NewPointerObj((new OpenBabel::vector3(static_cast< const OpenBabel::vector3& >(result))), SWIGTYPE_p_OpenBabel__vector3, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_vector_angle(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  double result;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::vectorAngle" "', argument " "1"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::vectorAngle" "', argument " "1"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::vectorAngle" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::vectorAngle" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  result = (double)OpenBabel::vectorAngle((OpenBabel::vector3 const &)*arg1,(OpenBabel::vector3 const &)*arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_calc_torsion_angle(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  OpenBabel::vector3 *arg3 = 0 ;
  OpenBabel::vector3 *arg4 = 0 ;
  double result;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  void *argp4 ;
  int res4 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::CalcTorsionAngle" "', argument " "1"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::CalcTorsionAngle" "', argument " "1"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::CalcTorsionAngle" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::CalcTorsionAngle" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "OpenBabel::CalcTorsionAngle" "', argument " "3"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::CalcTorsionAngle" "', argument " "3"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::vector3 * >(argp3);
  res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "OpenBabel::CalcTorsionAngle" "', argument " "4"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::CalcTorsionAngle" "', argument " "4"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  arg4 = reinterpret_cast< OpenBabel::vector3 * >(argp4);
  result = (double)OpenBabel::CalcTorsionAngle((OpenBabel::vector3 const &)*arg1,(OpenBabel::vector3 const &)*arg2,(OpenBabel::vector3 const &)*arg3,(OpenBabel::vector3 const &)*arg4);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_point_2plane(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 arg1 ;
  OpenBabel::vector3 arg2 ;
  OpenBabel::vector3 arg3 ;
  OpenBabel::vector3 arg4 ;
  double result;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  void *argp4 ;
  int res4 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  {
    res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__vector3,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::Point2Plane" "', argument " "1"" of type '" "OpenBabel::vector3""'"); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::Point2Plane" "', argument " "1"" of type '" "OpenBabel::vector3""'");
    } else {
      arg1 = *(reinterpret_cast< OpenBabel::vector3 * >(argp1));
    }
  }
  {
    res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::Point2Plane" "', argument " "2"" of type '" "OpenBabel::vector3""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::Point2Plane" "', argument " "2"" of type '" "OpenBabel::vector3""'");
    } else {
      arg2 = *(reinterpret_cast< OpenBabel::vector3 * >(argp2));
    }
  }
  {
    res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_OpenBabel__vector3,  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "OpenBabel::Point2Plane" "', argument " "3"" of type '" "OpenBabel::vector3""'"); 
    }  
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::Point2Plane" "', argument " "3"" of type '" "OpenBabel::vector3""'");
    } else {
      arg3 = *(reinterpret_cast< OpenBabel::vector3 * >(argp3));
    }
  }
  {
    res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_OpenBabel__vector3,  0 );
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "OpenBabel::Point2Plane" "', argument " "4"" of type '" "OpenBabel::vector3""'"); 
    }  
    if (!argp4) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::Point2Plane" "', argument " "4"" of type '" "OpenBabel::vector3""'");
    } else {
      arg4 = *(reinterpret_cast< OpenBabel::vector3 * >(argp4));
    }
  }
  result = (double)OpenBabel::Point2Plane(arg1,arg2,arg3,arg4);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_point_2plane_angle(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 arg1 ;
  OpenBabel::vector3 arg2 ;
  OpenBabel::vector3 arg3 ;
  OpenBabel::vector3 arg4 ;
  double result;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  void *argp4 ;
  int res4 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  {
    res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__vector3,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::Point2PlaneAngle" "', argument " "1"" of type '" "OpenBabel::vector3 const""'"); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::Point2PlaneAngle" "', argument " "1"" of type '" "OpenBabel::vector3 const""'");
    } else {
      arg1 = *(reinterpret_cast< OpenBabel::vector3 * >(argp1));
    }
  }
  {
    res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::Point2PlaneAngle" "', argument " "2"" of type '" "OpenBabel::vector3 const""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::Point2PlaneAngle" "', argument " "2"" of type '" "OpenBabel::vector3 const""'");
    } else {
      arg2 = *(reinterpret_cast< OpenBabel::vector3 * >(argp2));
    }
  }
  {
    res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_OpenBabel__vector3,  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "OpenBabel::Point2PlaneAngle" "', argument " "3"" of type '" "OpenBabel::vector3 const""'"); 
    }  
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::Point2PlaneAngle" "', argument " "3"" of type '" "OpenBabel::vector3 const""'");
    } else {
      arg3 = *(reinterpret_cast< OpenBabel::vector3 * >(argp3));
    }
  }
  {
    res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_OpenBabel__vector3,  0 );
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "OpenBabel::Point2PlaneAngle" "', argument " "4"" of type '" "OpenBabel::vector3 const""'"); 
    }  
    if (!argp4) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::Point2PlaneAngle" "', argument " "4"" of type '" "OpenBabel::vector3 const""'");
    } else {
      arg4 = *(reinterpret_cast< OpenBabel::vector3 * >(argp4));
    }
  }
  result = (double)OpenBabel::Point2PlaneAngle(arg1,arg2,arg3,arg4);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
VZero_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_NewPointerObj(SWIG_as_voidptr(&OpenBabel::VZero), SWIGTYPE_p_OpenBabel__vector3,  0 );
  return _val;
}


SWIGINTERN VALUE
VX_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_NewPointerObj(SWIG_as_voidptr(&OpenBabel::VX), SWIGTYPE_p_OpenBabel__vector3,  0 );
  return _val;
}


SWIGINTERN VALUE
VY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_NewPointerObj(SWIG_as_voidptr(&OpenBabel::VY), SWIGTYPE_p_OpenBabel__vector3,  0 );
  return _val;
}


SWIGINTERN VALUE
VZ_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_NewPointerObj(SWIG_as_voidptr(&OpenBabel::VZ), SWIGTYPE_p_OpenBabel__vector3,  0 );
  return _val;
}


SWIGINTERN VALUE
_wrap_trim(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  std::string *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_std__string,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::Trim" "', argument " "1"" of type '" "std::string &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::Trim" "', argument " "1"" of type '" "std::string &""'"); 
  }
  arg1 = reinterpret_cast< std::string * >(argp1);
  {
    std::string &_result_ref = OpenBabel::Trim(*arg1);
    result = (std::string *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__string, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


swig_class cOBGenericData;

SWIGINTERN VALUE
_wrap_new_OBGenericData__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::string arg1 ;
  unsigned int arg2 ;
  OpenBabel::DataOrigin arg3 ;
  OpenBabel::OBGenericData *result = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "OpenBabel::OBGenericData" "', argument " "1"" of type '" "std::string const""'"); 
    }
    arg1 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "OpenBabel::OBGenericData" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "OpenBabel::OBGenericData" "', argument " "3"" of type '" "OpenBabel::DataOrigin""'");
  } 
  arg3 = static_cast< OpenBabel::DataOrigin >(val3);
  result = (OpenBabel::OBGenericData *)new OpenBabel::OBGenericData(arg1,arg2,arg3);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_OBGenericData__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::string arg1 ;
  unsigned int arg2 ;
  OpenBabel::OBGenericData *result = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "OpenBabel::OBGenericData" "', argument " "1"" of type '" "std::string const""'"); 
    }
    arg1 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "OpenBabel::OBGenericData" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (OpenBabel::OBGenericData *)new OpenBabel::OBGenericData(arg1,arg2);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_OBGenericData__SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::string arg1 ;
  OpenBabel::OBGenericData *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "OpenBabel::OBGenericData" "', argument " "1"" of type '" "std::string const""'"); 
    }
    arg1 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = (OpenBabel::OBGenericData *)new OpenBabel::OBGenericData(arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBGenericData_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBGenericData_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBGenericData);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBGenericData__SWIG_3(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBGenericData *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBGenericData *)new OpenBabel::OBGenericData();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_OBGenericData(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs;
  if (argc > 3) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_OBGenericData__SWIG_3(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBGenericData__SWIG_2(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_OBGenericData__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_OBGenericData__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_OBGenericData'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBGenericData_clone(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBGenericData *arg1 = (OpenBabel::OBGenericData *) 0 ;
  OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Clone" "', argument " "1"" of type '" "OpenBabel::OBGenericData const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBGenericData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Clone" "', argument " "2"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  result = (OpenBabel::OBGenericData *)((OpenBabel::OBGenericData const *)arg1)->Clone(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBGenericData(OpenBabel::OBGenericData *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_OBGenericData_set_attribute(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBGenericData *arg1 = (OpenBabel::OBGenericData *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetAttribute" "', argument " "1"" of type '" "OpenBabel::OBGenericData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBGenericData * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetAttribute" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetAttribute" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  (arg1)->SetAttribute((std::string const &)*arg2);
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBGenericData_set_origin(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBGenericData *arg1 = (OpenBabel::OBGenericData *) 0 ;
  OpenBabel::DataOrigin arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetOrigin" "', argument " "1"" of type '" "OpenBabel::OBGenericData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBGenericData * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetOrigin" "', argument " "2"" of type '" "OpenBabel::DataOrigin""'");
  } 
  arg2 = static_cast< OpenBabel::DataOrigin >(val2);
  (arg1)->SetOrigin(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBGenericData_get_attribute(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBGenericData *arg1 = (OpenBabel::OBGenericData *) 0 ;
  std::string *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAttribute" "', argument " "1"" of type '" "OpenBabel::OBGenericData const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBGenericData * >(argp1);
  {
    std::string const &_result_ref = ((OpenBabel::OBGenericData const *)arg1)->GetAttribute();
    result = (std::string *) &_result_ref;
  }
  vresult = SWIG_From_std_string(static_cast< std::string >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBGenericData_get_data_type(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBGenericData *arg1 = (OpenBabel::OBGenericData *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetDataType" "', argument " "1"" of type '" "OpenBabel::OBGenericData const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBGenericData * >(argp1);
  result = (unsigned int)((OpenBabel::OBGenericData const *)arg1)->GetDataType();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBGenericData_get_value(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBGenericData *arg1 = (OpenBabel::OBGenericData *) 0 ;
  std::string *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetValue" "', argument " "1"" of type '" "OpenBabel::OBGenericData const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBGenericData * >(argp1);
  {
    std::string const &_result_ref = ((OpenBabel::OBGenericData const *)arg1)->GetValue();
    result = (std::string *) &_result_ref;
  }
  vresult = SWIG_From_std_string(static_cast< std::string >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBGenericData_get_origin(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBGenericData *arg1 = (OpenBabel::OBGenericData *) 0 ;
  OpenBabel::DataOrigin result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetOrigin" "', argument " "1"" of type '" "OpenBabel::OBGenericData const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBGenericData * >(argp1);
  result = (OpenBabel::DataOrigin)((OpenBabel::OBGenericData const *)arg1)->GetOrigin();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


swig_class cOBCommentData;

SWIGINTERN VALUE
_wrap_new_OBCommentData__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBCommentData *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBCommentData *)new OpenBabel::OBCommentData();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBCommentData_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBCommentData_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBCommentData);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBCommentData__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBCommentData *arg1 = 0 ;
  OpenBabel::OBCommentData *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBCommentData,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBCommentData" "', argument " "1"" of type '" "OpenBabel::OBCommentData const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBCommentData" "', argument " "1"" of type '" "OpenBabel::OBCommentData const &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBCommentData * >(argp1);
  result = (OpenBabel::OBCommentData *)new OpenBabel::OBCommentData((OpenBabel::OBCommentData const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_OBCommentData(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_OBCommentData__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBCommentData, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBCommentData__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_OBCommentData'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBCommentData_clone(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBCommentData *arg1 = (OpenBabel::OBCommentData *) 0 ;
  OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBCommentData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Clone" "', argument " "1"" of type '" "OpenBabel::OBCommentData const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBCommentData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Clone" "', argument " "2"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  result = (OpenBabel::OBGenericData *)((OpenBabel::OBCommentData const *)arg1)->Clone(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBCommentData_set_data__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBCommentData *arg1 = (OpenBabel::OBCommentData *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBCommentData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetData" "', argument " "1"" of type '" "OpenBabel::OBCommentData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBCommentData * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetData" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetData" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  (arg1)->SetData((std::string const &)*arg2);
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBCommentData_set_data__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBCommentData *arg1 = (OpenBabel::OBCommentData *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBCommentData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetData" "', argument " "1"" of type '" "OpenBabel::OBCommentData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBCommentData * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetData" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  (arg1)->SetData((char const *)arg2);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBCommentData_set_data(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBCommentData, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBCommentData_set_data__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBCommentData, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBCommentData_set_data__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBCommentData_set_data'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBCommentData_get_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBCommentData *arg1 = (OpenBabel::OBCommentData *) 0 ;
  std::string *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBCommentData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBCommentData const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBCommentData * >(argp1);
  {
    std::string const &_result_ref = ((OpenBabel::OBCommentData const *)arg1)->GetData();
    result = (std::string *) &_result_ref;
  }
  vresult = SWIG_From_std_string(static_cast< std::string >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBCommentData_get_value(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBCommentData *arg1 = (OpenBabel::OBCommentData *) 0 ;
  std::string *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBCommentData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetValue" "', argument " "1"" of type '" "OpenBabel::OBCommentData const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBCommentData * >(argp1);
  {
    std::string const &_result_ref = ((OpenBabel::OBCommentData const *)arg1)->GetValue();
    result = (std::string *) &_result_ref;
  }
  vresult = SWIG_From_std_string(static_cast< std::string >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBCommentData(OpenBabel::OBCommentData *arg1) {
    delete arg1;
}

swig_class cOBExternalBond;

SWIGINTERN VALUE
_wrap_new_OBExternalBond__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBExternalBond *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBExternalBond *)new OpenBabel::OBExternalBond();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_OBExternalBond__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBBond *arg2 = (OpenBabel::OBBond *) 0 ;
  int arg3 ;
  OpenBabel::OBExternalBond *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBExternalBond" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::OBExternalBond" "', argument " "2"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBond * >(argp2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "OpenBabel::OBExternalBond" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  result = (OpenBabel::OBExternalBond *)new OpenBabel::OBExternalBond(arg1,arg2,arg3);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBExternalBond_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBExternalBond_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBExternalBond);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBExternalBond__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBExternalBond *arg1 = 0 ;
  OpenBabel::OBExternalBond *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBExternalBond,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBExternalBond" "', argument " "1"" of type '" "OpenBabel::OBExternalBond const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBExternalBond" "', argument " "1"" of type '" "OpenBabel::OBExternalBond const &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBExternalBond * >(argp1);
  result = (OpenBabel::OBExternalBond *)new OpenBabel::OBExternalBond((OpenBabel::OBExternalBond const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_OBExternalBond(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs;
  if (argc > 3) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_OBExternalBond__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBExternalBond, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBExternalBond__SWIG_2(nargs, args, self);
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBBond, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_OBExternalBond__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_OBExternalBond'");
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBExternalBond(OpenBabel::OBExternalBond *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_OBExternalBond_get_idx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBExternalBond *arg1 = (OpenBabel::OBExternalBond *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBExternalBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetIdx" "', argument " "1"" of type '" "OpenBabel::OBExternalBond const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBExternalBond * >(argp1);
  result = (int)((OpenBabel::OBExternalBond const *)arg1)->GetIdx();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBExternalBond_get_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBExternalBond *arg1 = (OpenBabel::OBExternalBond *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBExternalBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAtom" "', argument " "1"" of type '" "OpenBabel::OBExternalBond const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBExternalBond * >(argp1);
  result = (OpenBabel::OBAtom *)((OpenBabel::OBExternalBond const *)arg1)->GetAtom();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBExternalBond_get_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBExternalBond *arg1 = (OpenBabel::OBExternalBond *) 0 ;
  OpenBabel::OBBond *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBExternalBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetBond" "', argument " "1"" of type '" "OpenBabel::OBExternalBond const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBExternalBond * >(argp1);
  result = (OpenBabel::OBBond *)((OpenBabel::OBExternalBond const *)arg1)->GetBond();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBExternalBond_set_idx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBExternalBond *arg1 = (OpenBabel::OBExternalBond *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBExternalBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetIdx" "', argument " "1"" of type '" "OpenBabel::OBExternalBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBExternalBond * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetIdx" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->SetIdx(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBExternalBond_set_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBExternalBond *arg1 = (OpenBabel::OBExternalBond *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBExternalBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetAtom" "', argument " "1"" of type '" "OpenBabel::OBExternalBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBExternalBond * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetAtom" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  (arg1)->SetAtom(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBExternalBond_set_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBExternalBond *arg1 = (OpenBabel::OBExternalBond *) 0 ;
  OpenBabel::OBBond *arg2 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBExternalBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetBond" "', argument " "1"" of type '" "OpenBabel::OBExternalBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBExternalBond * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetBond" "', argument " "2"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBond * >(argp2);
  (arg1)->SetBond(arg2);
  return Qnil;
fail:
  return Qnil;
}


swig_class cOBExternalBondData;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBExternalBondData_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBExternalBondData_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBExternalBondData);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBExternalBondData(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBExternalBondData *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBExternalBondData *)new OpenBabel::OBExternalBondData();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBExternalBondData_clone(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBExternalBondData *arg1 = (OpenBabel::OBExternalBondData *) 0 ;
  OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBExternalBondData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Clone" "', argument " "1"" of type '" "OpenBabel::OBExternalBondData const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBExternalBondData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Clone" "', argument " "2"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  result = (OpenBabel::OBGenericData *)((OpenBabel::OBExternalBondData const *)arg1)->Clone(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBExternalBondData_set_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBExternalBondData *arg1 = (OpenBabel::OBExternalBondData *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBBond *arg3 = (OpenBabel::OBBond *) 0 ;
  int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBExternalBondData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetData" "', argument " "1"" of type '" "OpenBabel::OBExternalBondData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBExternalBondData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetData" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SetData" "', argument " "3"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBBond * >(argp3);
  ecode4 = SWIG_AsVal_int(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "SetData" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = static_cast< int >(val4);
  (arg1)->SetData(arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBExternalBondData_get_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBExternalBondData *arg1 = (OpenBabel::OBExternalBondData *) 0 ;
  std::vector<OpenBabel::OBExternalBond > *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBExternalBondData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBExternalBondData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBExternalBondData * >(argp1);
  result = (std::vector<OpenBabel::OBExternalBond > *)(arg1)->GetData();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorTOpenBabel__OBExternalBond_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBExternalBondData(OpenBabel::OBExternalBondData *arg1) {
    delete arg1;
}

swig_class cOBPairData;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBPairData_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBPairData_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBPairData);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBPairData(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBPairData *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBPairData *)new OpenBabel::OBPairData();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBPairData_clone(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBPairData *arg1 = (OpenBabel::OBPairData *) 0 ;
  OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBPairData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Clone" "', argument " "1"" of type '" "OpenBabel::OBPairData const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBPairData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Clone" "', argument " "2"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  result = (OpenBabel::OBGenericData *)((OpenBabel::OBPairData const *)arg1)->Clone(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBPairData_set_value__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBPairData *arg1 = (OpenBabel::OBPairData *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBPairData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetValue" "', argument " "1"" of type '" "OpenBabel::OBPairData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBPairData * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetValue" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  (arg1)->SetValue((char const *)arg2);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBPairData_set_value__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBPairData *arg1 = (OpenBabel::OBPairData *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBPairData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetValue" "', argument " "1"" of type '" "OpenBabel::OBPairData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBPairData * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetValue" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetValue" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  (arg1)->SetValue((std::string const &)*arg2);
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBPairData_set_value(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBPairData, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBPairData_set_value__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBPairData, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBPairData_set_value__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBPairData_set_value'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBPairData_get_value(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBPairData *arg1 = (OpenBabel::OBPairData *) 0 ;
  std::string *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBPairData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetValue" "', argument " "1"" of type '" "OpenBabel::OBPairData const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBPairData * >(argp1);
  {
    std::string const &_result_ref = ((OpenBabel::OBPairData const *)arg1)->GetValue();
    result = (std::string *) &_result_ref;
  }
  vresult = SWIG_From_std_string(static_cast< std::string >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBPairData(OpenBabel::OBPairData *arg1) {
    delete arg1;
}

swig_class cOBSetData;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBSetData_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBSetData_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBSetData);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBSetData(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSetData *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBSetData *)new OpenBabel::OBSetData();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSetData_clone(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSetData *arg1 = (OpenBabel::OBSetData *) 0 ;
  OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSetData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Clone" "', argument " "1"" of type '" "OpenBabel::OBSetData const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSetData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Clone" "', argument " "2"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  result = (OpenBabel::OBGenericData *)((OpenBabel::OBSetData const *)arg1)->Clone(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSetData_add_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSetData *arg1 = (OpenBabel::OBSetData *) 0 ;
  OpenBabel::OBGenericData *arg2 = (OpenBabel::OBGenericData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSetData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AddData" "', argument " "1"" of type '" "OpenBabel::OBSetData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSetData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AddData" "', argument " "2"" of type '" "OpenBabel::OBGenericData *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBGenericData * >(argp2);
  (arg1)->AddData(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSetData_set_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSetData *arg1 = (OpenBabel::OBSetData *) 0 ;
  std::vector<OpenBabel::OBGenericData * > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSetData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetData" "', argument " "1"" of type '" "OpenBabel::OBSetData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSetData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetData" "', argument " "2"" of type '" "std::vector<OpenBabel::OBGenericData * > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetData" "', argument " "2"" of type '" "std::vector<OpenBabel::OBGenericData * > &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<OpenBabel::OBGenericData * > * >(argp2);
  (arg1)->SetData(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSetData_get_data__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSetData *arg1 = (OpenBabel::OBSetData *) 0 ;
  char *arg2 = (char *) 0 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSetData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBSetData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSetData * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetData" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (OpenBabel::OBGenericData *)(arg1)->GetData((char const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSetData_get_data__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSetData *arg1 = (OpenBabel::OBSetData *) 0 ;
  std::string *arg2 = 0 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSetData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBSetData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSetData * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetData" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GetData" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (OpenBabel::OBGenericData *)(arg1)->GetData((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSetData_get_data__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSetData *arg1 = (OpenBabel::OBSetData *) 0 ;
  std::vector<OpenBabel::OBGenericData * > *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSetData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBSetData const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSetData * >(argp1);
  {
    std::vector<OpenBabel::OBGenericData * > const &_result_ref = ((OpenBabel::OBSetData const *)arg1)->GetData();
    result = (std::vector<OpenBabel::OBGenericData * > *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBSetData_get_data(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBSetData, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBSetData_get_data__SWIG_2(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBSetData, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBSetData_get_data__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBSetData, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBSetData_get_data__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBSetData_get_data'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSetData_get_begin(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSetData *arg1 = (OpenBabel::OBSetData *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBGenericData * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSetData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetBegin" "', argument " "1"" of type '" "OpenBabel::OBSetData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSetData * >(argp1);
  result = (arg1)->GetBegin();
  vresult = SWIG_NewPointerObj((new std::vector<OpenBabel::OBGenericData * >::iterator(static_cast< const std::vector<OpenBabel::OBGenericData * >::iterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSetData_get_end(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSetData *arg1 = (OpenBabel::OBSetData *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBGenericData * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSetData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetEnd" "', argument " "1"" of type '" "OpenBabel::OBSetData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSetData * >(argp1);
  result = (arg1)->GetEnd();
  vresult = SWIG_NewPointerObj((new std::vector<OpenBabel::OBGenericData * >::iterator(static_cast< const std::vector<OpenBabel::OBGenericData * >::iterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSetData_delete_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSetData *arg1 = (OpenBabel::OBSetData *) 0 ;
  OpenBabel::OBGenericData *arg2 = (OpenBabel::OBGenericData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSetData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteData" "', argument " "1"" of type '" "OpenBabel::OBSetData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSetData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DeleteData" "', argument " "2"" of type '" "OpenBabel::OBGenericData *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBGenericData * >(argp2);
  (arg1)->DeleteData(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBSetData(OpenBabel::OBSetData *arg1) {
    delete arg1;
}

swig_class cOBVirtualBond;

SWIGINTERN VALUE
_wrap_new_OBVirtualBond__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBVirtualBond *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBVirtualBond *)new OpenBabel::OBVirtualBond();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBVirtualBond_clone(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBVirtualBond *arg1 = (OpenBabel::OBVirtualBond *) 0 ;
  OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBVirtualBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Clone" "', argument " "1"" of type '" "OpenBabel::OBVirtualBond const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBVirtualBond * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Clone" "', argument " "2"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  result = (OpenBabel::OBGenericData *)((OpenBabel::OBVirtualBond const *)arg1)->Clone(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_OBVirtualBond__SWIG_1(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  OpenBabel::OBVirtualBond *result = 0 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "OpenBabel::OBVirtualBond" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = static_cast< int >(val1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "OpenBabel::OBVirtualBond" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "OpenBabel::OBVirtualBond" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  ecode4 = SWIG_AsVal_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "OpenBabel::OBVirtualBond" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = static_cast< int >(val4);
  result = (OpenBabel::OBVirtualBond *)new OpenBabel::OBVirtualBond(arg1,arg2,arg3,arg4);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBVirtualBond_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBVirtualBond_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBVirtualBond);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBVirtualBond__SWIG_2(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int arg2 ;
  int arg3 ;
  OpenBabel::OBVirtualBond *result = 0 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "OpenBabel::OBVirtualBond" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = static_cast< int >(val1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "OpenBabel::OBVirtualBond" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "OpenBabel::OBVirtualBond" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  result = (OpenBabel::OBVirtualBond *)new OpenBabel::OBVirtualBond(arg1,arg2,arg3);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_OBVirtualBond(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs;
  if (argc > 4) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_OBVirtualBond__SWIG_0(nargs, args, self);
  }
  if (argc == 3) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_OBVirtualBond__SWIG_2(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_new_OBVirtualBond__SWIG_1(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_OBVirtualBond'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBVirtualBond_get_bgn(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBVirtualBond *arg1 = (OpenBabel::OBVirtualBond *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBVirtualBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetBgn" "', argument " "1"" of type '" "OpenBabel::OBVirtualBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBVirtualBond * >(argp1);
  result = (int)(arg1)->GetBgn();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBVirtualBond_get_end(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBVirtualBond *arg1 = (OpenBabel::OBVirtualBond *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBVirtualBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetEnd" "', argument " "1"" of type '" "OpenBabel::OBVirtualBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBVirtualBond * >(argp1);
  result = (int)(arg1)->GetEnd();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBVirtualBond_get_order(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBVirtualBond *arg1 = (OpenBabel::OBVirtualBond *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBVirtualBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetOrder" "', argument " "1"" of type '" "OpenBabel::OBVirtualBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBVirtualBond * >(argp1);
  result = (int)(arg1)->GetOrder();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBVirtualBond_get_stereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBVirtualBond *arg1 = (OpenBabel::OBVirtualBond *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBVirtualBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetStereo" "', argument " "1"" of type '" "OpenBabel::OBVirtualBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBVirtualBond * >(argp1);
  result = (int)(arg1)->GetStereo();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBVirtualBond(OpenBabel::OBVirtualBond *arg1) {
    delete arg1;
}

swig_class cOBRingData;

SWIGINTERN VALUE
_wrap_new_OBRingData__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRingData *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBRingData *)new OpenBabel::OBRingData();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBRingData_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBRingData_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBRingData);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBRingData__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRingData *arg1 = 0 ;
  OpenBabel::OBRingData *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBRingData,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBRingData" "', argument " "1"" of type '" "OpenBabel::OBRingData const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBRingData" "', argument " "1"" of type '" "OpenBabel::OBRingData const &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBRingData * >(argp1);
  result = (OpenBabel::OBRingData *)new OpenBabel::OBRingData((OpenBabel::OBRingData const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_OBRingData(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_OBRingData__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBRingData, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBRingData__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_OBRingData'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBRingData_clone(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRingData *arg1 = (OpenBabel::OBRingData *) 0 ;
  OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRingData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Clone" "', argument " "1"" of type '" "OpenBabel::OBRingData const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBRingData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Clone" "', argument " "2"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  result = (OpenBabel::OBGenericData *)((OpenBabel::OBRingData const *)arg1)->Clone(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBRingData(OpenBabel::OBRingData *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_OBRingData_set_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRingData *arg1 = (OpenBabel::OBRingData *) 0 ;
  std::vector<OpenBabel::OBRing * > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRingData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetData" "', argument " "1"" of type '" "OpenBabel::OBRingData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBRingData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBRing_p_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetData" "', argument " "2"" of type '" "std::vector<OpenBabel::OBRing * > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetData" "', argument " "2"" of type '" "std::vector<OpenBabel::OBRing * > &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<OpenBabel::OBRing * > * >(argp2);
  (arg1)->SetData(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBRingData_push_back(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRingData *arg1 = (OpenBabel::OBRingData *) 0 ;
  OpenBabel::OBRing *arg2 = (OpenBabel::OBRing *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRingData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PushBack" "', argument " "1"" of type '" "OpenBabel::OBRingData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBRingData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBRing, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "PushBack" "', argument " "2"" of type '" "OpenBabel::OBRing *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBRing * >(argp2);
  (arg1)->PushBack(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBRingData_get_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRingData *arg1 = (OpenBabel::OBRingData *) 0 ;
  std::vector<OpenBabel::OBRing * > *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRingData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBRingData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBRingData * >(argp1);
  {
    std::vector<OpenBabel::OBRing * > &_result_ref = (arg1)->GetData();
    result = (std::vector<OpenBabel::OBRing * > *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorTOpenBabel__OBRing_p_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBRingData_begin_rings(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRingData *arg1 = (OpenBabel::OBRingData *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBRing * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRingData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginRings" "', argument " "1"" of type '" "OpenBabel::OBRingData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBRingData * >(argp1);
  result = (arg1)->BeginRings();
  vresult = SWIG_NewPointerObj((new std::vector<OpenBabel::OBRing * >::iterator(static_cast< const std::vector<OpenBabel::OBRing * >::iterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBRing_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBRingData_end_rings(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRingData *arg1 = (OpenBabel::OBRingData *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBRing * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRingData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EndRings" "', argument " "1"" of type '" "OpenBabel::OBRingData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBRingData * >(argp1);
  result = (arg1)->EndRings();
  vresult = SWIG_NewPointerObj((new std::vector<OpenBabel::OBRing * >::iterator(static_cast< const std::vector<OpenBabel::OBRing * >::iterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBRing_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBRingData_begin_ring(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRingData *arg1 = (OpenBabel::OBRingData *) 0 ;
  std::vector<OpenBabel::OBRing * >::iterator *arg2 = 0 ;
  OpenBabel::OBRing *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRingData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginRing" "', argument " "1"" of type '" "OpenBabel::OBRingData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBRingData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBRing_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "BeginRing" "', argument " "2"" of type '" "std::vector<OpenBabel::OBRing * >::iterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "BeginRing" "', argument " "2"" of type '" "std::vector<OpenBabel::OBRing * >::iterator &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<OpenBabel::OBRing * >::iterator * >(argp2);
  result = (OpenBabel::OBRing *)(arg1)->BeginRing(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBRing, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBRingData_next_ring(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRingData *arg1 = (OpenBabel::OBRingData *) 0 ;
  std::vector<OpenBabel::OBRing * >::iterator *arg2 = 0 ;
  OpenBabel::OBRing *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRingData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NextRing" "', argument " "1"" of type '" "OpenBabel::OBRingData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBRingData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBRing_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "NextRing" "', argument " "2"" of type '" "std::vector<OpenBabel::OBRing * >::iterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "NextRing" "', argument " "2"" of type '" "std::vector<OpenBabel::OBRing * >::iterator &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<OpenBabel::OBRing * >::iterator * >(argp2);
  result = (OpenBabel::OBRing *)(arg1)->NextRing(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBRing, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


swig_class cOBUnitCell;

SWIGINTERN VALUE
_wrap_new_OBUnitCell__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBUnitCell *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBUnitCell *)new OpenBabel::OBUnitCell();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBUnitCell_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBUnitCell_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBUnitCell);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBUnitCell__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBUnitCell *arg1 = 0 ;
  OpenBabel::OBUnitCell *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBUnitCell,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBUnitCell" "', argument " "1"" of type '" "OpenBabel::OBUnitCell const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBUnitCell" "', argument " "1"" of type '" "OpenBabel::OBUnitCell const &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBUnitCell * >(argp1);
  result = (OpenBabel::OBUnitCell *)new OpenBabel::OBUnitCell((OpenBabel::OBUnitCell const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_OBUnitCell(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_OBUnitCell__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBUnitCell, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBUnitCell__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_OBUnitCell'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBUnitCell_clone(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBUnitCell *arg1 = (OpenBabel::OBUnitCell *) 0 ;
  OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBUnitCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Clone" "', argument " "1"" of type '" "OpenBabel::OBUnitCell const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBUnitCell * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Clone" "', argument " "2"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  result = (OpenBabel::OBGenericData *)((OpenBabel::OBUnitCell const *)arg1)->Clone(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBUnitCell(OpenBabel::OBUnitCell *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_OBUnitCell_set_data__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBUnitCell *arg1 = (OpenBabel::OBUnitCell *) 0 ;
  double arg2 ;
  double arg3 ;
  double arg4 ;
  double arg5 ;
  double arg6 ;
  double arg7 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  double val5 ;
  int ecode5 = 0 ;
  double val6 ;
  int ecode6 = 0 ;
  double val7 ;
  int ecode7 = 0 ;
  
  if ((argc < 6) || (argc > 6)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 6)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBUnitCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetData" "', argument " "1"" of type '" "OpenBabel::OBUnitCell *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBUnitCell * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetData" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SetData" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  ecode4 = SWIG_AsVal_double(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "SetData" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = static_cast< double >(val4);
  ecode5 = SWIG_AsVal_double(argv[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "SetData" "', argument " "5"" of type '" "double""'");
  } 
  arg5 = static_cast< double >(val5);
  ecode6 = SWIG_AsVal_double(argv[4], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "SetData" "', argument " "6"" of type '" "double""'");
  } 
  arg6 = static_cast< double >(val6);
  ecode7 = SWIG_AsVal_double(argv[5], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "SetData" "', argument " "7"" of type '" "double""'");
  } 
  arg7 = static_cast< double >(val7);
  (arg1)->SetData(arg2,arg3,arg4,arg5,arg6,arg7);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBUnitCell_set_data__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBUnitCell *arg1 = (OpenBabel::OBUnitCell *) 0 ;
  OpenBabel::vector3 arg2 ;
  OpenBabel::vector3 arg3 ;
  OpenBabel::vector3 arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  void *argp4 ;
  int res4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBUnitCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetData" "', argument " "1"" of type '" "OpenBabel::OBUnitCell *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBUnitCell * >(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetData" "', argument " "2"" of type '" "OpenBabel::vector3 const""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetData" "', argument " "2"" of type '" "OpenBabel::vector3 const""'");
    } else {
      arg2 = *(reinterpret_cast< OpenBabel::vector3 * >(argp2));
    }
  }
  {
    res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_OpenBabel__vector3,  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SetData" "', argument " "3"" of type '" "OpenBabel::vector3 const""'"); 
    }  
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetData" "', argument " "3"" of type '" "OpenBabel::vector3 const""'");
    } else {
      arg3 = *(reinterpret_cast< OpenBabel::vector3 * >(argp3));
    }
  }
  {
    res4 = SWIG_ConvertPtr(argv[2], &argp4, SWIGTYPE_p_OpenBabel__vector3,  0 );
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "SetData" "', argument " "4"" of type '" "OpenBabel::vector3 const""'"); 
    }  
    if (!argp4) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetData" "', argument " "4"" of type '" "OpenBabel::vector3 const""'");
    } else {
      arg4 = *(reinterpret_cast< OpenBabel::vector3 * >(argp4));
    }
  }
  (arg1)->SetData(arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBUnitCell_set_data(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[8];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 8) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBUnitCell, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__vector3, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_OpenBabel__vector3, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_OpenBabel__vector3, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_OBUnitCell_set_data__SWIG_1(nargs, args, self);
          }
        }
      }
    }
  }
  if (argc == 7) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBUnitCell, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_double(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            {
              int res = SWIG_AsVal_double(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              {
                int res = SWIG_AsVal_double(argv[5], NULL);
                _v = SWIG_CheckState(res);
              }
              if (_v) {
                {
                  int res = SWIG_AsVal_double(argv[6], NULL);
                  _v = SWIG_CheckState(res);
                }
                if (_v) {
                  return _wrap_OBUnitCell_set_data__SWIG_0(nargs, args, self);
                }
              }
            }
          }
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBUnitCell_set_data'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBUnitCell_set_offset(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBUnitCell *arg1 = (OpenBabel::OBUnitCell *) 0 ;
  OpenBabel::vector3 arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBUnitCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetOffset" "', argument " "1"" of type '" "OpenBabel::OBUnitCell *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBUnitCell * >(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetOffset" "', argument " "2"" of type '" "OpenBabel::vector3 const""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetOffset" "', argument " "2"" of type '" "OpenBabel::vector3 const""'");
    } else {
      arg2 = *(reinterpret_cast< OpenBabel::vector3 * >(argp2));
    }
  }
  (arg1)->SetOffset(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBUnitCell_set_space_group__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBUnitCell *arg1 = (OpenBabel::OBUnitCell *) 0 ;
  std::string arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBUnitCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetSpaceGroup" "', argument " "1"" of type '" "OpenBabel::OBUnitCell *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBUnitCell * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "SetSpaceGroup" "', argument " "2"" of type '" "std::string const""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  (arg1)->SetSpaceGroup(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBUnitCell_set_space_group__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBUnitCell *arg1 = (OpenBabel::OBUnitCell *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBUnitCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetSpaceGroup" "', argument " "1"" of type '" "OpenBabel::OBUnitCell *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBUnitCell * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetSpaceGroup" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->SetSpaceGroup(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBUnitCell_set_space_group(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBUnitCell, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBUnitCell_set_space_group__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBUnitCell, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBUnitCell_set_space_group__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBUnitCell_set_space_group'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBUnitCell_set_lattice_type(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBUnitCell *arg1 = (OpenBabel::OBUnitCell *) 0 ;
  OpenBabel::OBUnitCell::LatticeType arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBUnitCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetLatticeType" "', argument " "1"" of type '" "OpenBabel::OBUnitCell *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBUnitCell * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetLatticeType" "', argument " "2"" of type '" "OpenBabel::OBUnitCell::LatticeType""'");
  } 
  arg2 = static_cast< OpenBabel::OBUnitCell::LatticeType >(val2);
  (arg1)->SetLatticeType(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBUnitCell_get_a(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBUnitCell *arg1 = (OpenBabel::OBUnitCell *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBUnitCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetA" "', argument " "1"" of type '" "OpenBabel::OBUnitCell *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBUnitCell * >(argp1);
  result = (double)(arg1)->GetA();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBUnitCell_get_b(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBUnitCell *arg1 = (OpenBabel::OBUnitCell *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBUnitCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetB" "', argument " "1"" of type '" "OpenBabel::OBUnitCell *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBUnitCell * >(argp1);
  result = (double)(arg1)->GetB();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBUnitCell_get_c(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBUnitCell *arg1 = (OpenBabel::OBUnitCell *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBUnitCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetC" "', argument " "1"" of type '" "OpenBabel::OBUnitCell *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBUnitCell * >(argp1);
  result = (double)(arg1)->GetC();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBUnitCell_get_alpha(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBUnitCell *arg1 = (OpenBabel::OBUnitCell *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBUnitCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAlpha" "', argument " "1"" of type '" "OpenBabel::OBUnitCell *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBUnitCell * >(argp1);
  result = (double)(arg1)->GetAlpha();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBUnitCell_get_beta(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBUnitCell *arg1 = (OpenBabel::OBUnitCell *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBUnitCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetBeta" "', argument " "1"" of type '" "OpenBabel::OBUnitCell *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBUnitCell * >(argp1);
  result = (double)(arg1)->GetBeta();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBUnitCell_get_gamma(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBUnitCell *arg1 = (OpenBabel::OBUnitCell *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBUnitCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetGamma" "', argument " "1"" of type '" "OpenBabel::OBUnitCell *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBUnitCell * >(argp1);
  result = (double)(arg1)->GetGamma();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBUnitCell_get_offset(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBUnitCell *arg1 = (OpenBabel::OBUnitCell *) 0 ;
  OpenBabel::vector3 result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBUnitCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetOffset" "', argument " "1"" of type '" "OpenBabel::OBUnitCell *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBUnitCell * >(argp1);
  result = (arg1)->GetOffset();
  vresult = SWIG_NewPointerObj((new OpenBabel::vector3(static_cast< const OpenBabel::vector3& >(result))), SWIGTYPE_p_OpenBabel__vector3, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBUnitCell_get_space_group(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBUnitCell *arg1 = (OpenBabel::OBUnitCell *) 0 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBUnitCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetSpaceGroup" "', argument " "1"" of type '" "OpenBabel::OBUnitCell *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBUnitCell * >(argp1);
  result = (arg1)->GetSpaceGroup();
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBUnitCell_get_lattice_type__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBUnitCell *arg1 = (OpenBabel::OBUnitCell *) 0 ;
  int arg2 ;
  OpenBabel::OBUnitCell::LatticeType result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBUnitCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetLatticeType" "', argument " "1"" of type '" "OpenBabel::OBUnitCell *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBUnitCell * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetLatticeType" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (OpenBabel::OBUnitCell::LatticeType)(arg1)->GetLatticeType(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBUnitCell_get_lattice_type__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBUnitCell *arg1 = (OpenBabel::OBUnitCell *) 0 ;
  OpenBabel::OBUnitCell::LatticeType result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBUnitCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetLatticeType" "', argument " "1"" of type '" "OpenBabel::OBUnitCell *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBUnitCell * >(argp1);
  result = (OpenBabel::OBUnitCell::LatticeType)(arg1)->GetLatticeType();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBUnitCell_get_lattice_type(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBUnitCell, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBUnitCell_get_lattice_type__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBUnitCell, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBUnitCell_get_lattice_type__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBUnitCell_get_lattice_type'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBUnitCell_get_cell_vectors(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBUnitCell *arg1 = (OpenBabel::OBUnitCell *) 0 ;
  std::vector<OpenBabel::vector3 > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBUnitCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetCellVectors" "', argument " "1"" of type '" "OpenBabel::OBUnitCell *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBUnitCell * >(argp1);
  result = (arg1)->GetCellVectors();
  {
    vresult = rb_ary_new2((&result)->size());
    for (unsigned int i=0; i<(&result)->size(); i++) {
      OpenBabel::vector3* x = new OpenBabel::vector3(((std::vector<OpenBabel::vector3 > &)result)[i]);
      rb_ary_store(vresult,i,
        SWIG_NewPointerObj((void *) x, 
          SWIGTYPE_p_OpenBabel__vector3, 1));
    }
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBUnitCell_get_cell_matrix(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBUnitCell *arg1 = (OpenBabel::OBUnitCell *) 0 ;
  OpenBabel::matrix3x3 result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBUnitCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetCellMatrix" "', argument " "1"" of type '" "OpenBabel::OBUnitCell *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBUnitCell * >(argp1);
  result = (arg1)->GetCellMatrix();
  vresult = SWIG_NewPointerObj((new OpenBabel::matrix3x3(static_cast< const OpenBabel::matrix3x3& >(result))), SWIGTYPE_p_OpenBabel__matrix3x3, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBUnitCell_get_ortho_matrix(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBUnitCell *arg1 = (OpenBabel::OBUnitCell *) 0 ;
  OpenBabel::matrix3x3 result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBUnitCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetOrthoMatrix" "', argument " "1"" of type '" "OpenBabel::OBUnitCell *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBUnitCell * >(argp1);
  result = (arg1)->GetOrthoMatrix();
  vresult = SWIG_NewPointerObj((new OpenBabel::matrix3x3(static_cast< const OpenBabel::matrix3x3& >(result))), SWIGTYPE_p_OpenBabel__matrix3x3, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBUnitCell_get_fractional_matrix(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBUnitCell *arg1 = (OpenBabel::OBUnitCell *) 0 ;
  OpenBabel::matrix3x3 result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBUnitCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetFractionalMatrix" "', argument " "1"" of type '" "OpenBabel::OBUnitCell *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBUnitCell * >(argp1);
  result = (arg1)->GetFractionalMatrix();
  vresult = SWIG_NewPointerObj((new OpenBabel::matrix3x3(static_cast< const OpenBabel::matrix3x3& >(result))), SWIGTYPE_p_OpenBabel__matrix3x3, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBUnitCell_get_space_group_number(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBUnitCell *arg1 = (OpenBabel::OBUnitCell *) 0 ;
  std::string arg2 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBUnitCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetSpaceGroupNumber" "', argument " "1"" of type '" "OpenBabel::OBUnitCell *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBUnitCell * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "GetSpaceGroupNumber" "', argument " "2"" of type '" "std::string""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = (int)(arg1)->GetSpaceGroupNumber(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBUnitCell_get_cell_volume(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBUnitCell *arg1 = (OpenBabel::OBUnitCell *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBUnitCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetCellVolume" "', argument " "1"" of type '" "OpenBabel::OBUnitCell *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBUnitCell * >(argp1);
  result = (double)(arg1)->GetCellVolume();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


swig_class cOBConformerData;

SWIGINTERN VALUE
_wrap_new_OBConformerData__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConformerData *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBConformerData *)new OpenBabel::OBConformerData();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBConformerData_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBConformerData_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBConformerData);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBConformerData__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConformerData *arg1 = 0 ;
  OpenBabel::OBConformerData *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBConformerData,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBConformerData" "', argument " "1"" of type '" "OpenBabel::OBConformerData const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBConformerData" "', argument " "1"" of type '" "OpenBabel::OBConformerData const &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConformerData * >(argp1);
  result = (OpenBabel::OBConformerData *)new OpenBabel::OBConformerData((OpenBabel::OBConformerData const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_OBConformerData(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_OBConformerData__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBConformerData, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBConformerData__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_OBConformerData'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConformerData_clone(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConformerData *arg1 = (OpenBabel::OBConformerData *) 0 ;
  OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConformerData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Clone" "', argument " "1"" of type '" "OpenBabel::OBConformerData const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConformerData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Clone" "', argument " "2"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  result = (OpenBabel::OBGenericData *)((OpenBabel::OBConformerData const *)arg1)->Clone(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBConformerData(OpenBabel::OBConformerData *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_OBConformerData_set_dimension(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConformerData *arg1 = (OpenBabel::OBConformerData *) 0 ;
  std::vector<unsigned short > arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConformerData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetDimension" "', argument " "1"" of type '" "OpenBabel::OBConformerData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConformerData * >(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTunsigned_short_t,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetDimension" "', argument " "2"" of type '" "std::vector<unsigned short >""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetDimension" "', argument " "2"" of type '" "std::vector<unsigned short >""'");
    } else {
      arg2 = *(reinterpret_cast< std::vector<unsigned short > * >(argp2));
    }
  }
  (arg1)->SetDimension(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConformerData_set_energies(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConformerData *arg1 = (OpenBabel::OBConformerData *) 0 ;
  std::vector<double > arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConformerData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetEnergies" "', argument " "1"" of type '" "OpenBabel::OBConformerData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConformerData * >(argp1);
  {
    if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
      unsigned int size = RARRAY_LEN(argv[0]);
      arg2 = std::vector<double >(size);
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(argv[0])[i];
        if (SWIG_FLOAT_P(o))
        ((std::vector<double > &)arg2)[i] = (double)(SWIG_NUM2DBL(o));
        else
        rb_raise(rb_eTypeError,
          "wrong argument type"
          " (expected vector<""double" ">)");
      }
    } else {
      void *ptr;
      SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_std__vectorTdouble_t, 1);
      arg2 = *((std::vector<double > *) ptr);
    }
  }
  (arg1)->SetEnergies(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConformerData_set_forces(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConformerData *arg1 = (OpenBabel::OBConformerData *) 0 ;
  SwigValueWrapper<std::vector<std::vector<OpenBabel::vector3 > > > arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConformerData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetForces" "', argument " "1"" of type '" "OpenBabel::OBConformerData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConformerData * >(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTstd__vectorTOpenBabel__vector3_t_t,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetForces" "', argument " "2"" of type '" "std::vector<std::vector<OpenBabel::vector3 > >""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetForces" "', argument " "2"" of type '" "std::vector<std::vector<OpenBabel::vector3 > >""'");
    } else {
      arg2 = *(reinterpret_cast< std::vector<std::vector<OpenBabel::vector3 > > * >(argp2));
    }
  }
  (arg1)->SetForces(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConformerData_set_velocities(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConformerData *arg1 = (OpenBabel::OBConformerData *) 0 ;
  SwigValueWrapper<std::vector<std::vector<OpenBabel::vector3 > > > arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConformerData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetVelocities" "', argument " "1"" of type '" "OpenBabel::OBConformerData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConformerData * >(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTstd__vectorTOpenBabel__vector3_t_t,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetVelocities" "', argument " "2"" of type '" "std::vector<std::vector<OpenBabel::vector3 > >""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetVelocities" "', argument " "2"" of type '" "std::vector<std::vector<OpenBabel::vector3 > >""'");
    } else {
      arg2 = *(reinterpret_cast< std::vector<std::vector<OpenBabel::vector3 > > * >(argp2));
    }
  }
  (arg1)->SetVelocities(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConformerData_set_displacements(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConformerData *arg1 = (OpenBabel::OBConformerData *) 0 ;
  SwigValueWrapper<std::vector<std::vector<OpenBabel::vector3 > > > arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConformerData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetDisplacements" "', argument " "1"" of type '" "OpenBabel::OBConformerData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConformerData * >(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTstd__vectorTOpenBabel__vector3_t_t,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetDisplacements" "', argument " "2"" of type '" "std::vector<std::vector<OpenBabel::vector3 > >""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetDisplacements" "', argument " "2"" of type '" "std::vector<std::vector<OpenBabel::vector3 > >""'");
    } else {
      arg2 = *(reinterpret_cast< std::vector<std::vector<OpenBabel::vector3 > > * >(argp2));
    }
  }
  (arg1)->SetDisplacements(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConformerData_set_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConformerData *arg1 = (OpenBabel::OBConformerData *) 0 ;
  std::vector<std::string > arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConformerData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetData" "', argument " "1"" of type '" "OpenBabel::OBConformerData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConformerData * >(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTstd__string_t,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetData" "', argument " "2"" of type '" "std::vector<std::string >""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetData" "', argument " "2"" of type '" "std::vector<std::string >""'");
    } else {
      arg2 = *(reinterpret_cast< std::vector<std::string > * >(argp2));
    }
  }
  (arg1)->SetData(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConformerData_get_dimension(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConformerData *arg1 = (OpenBabel::OBConformerData *) 0 ;
  std::vector<unsigned short > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConformerData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetDimension" "', argument " "1"" of type '" "OpenBabel::OBConformerData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConformerData * >(argp1);
  result = (arg1)->GetDimension();
  vresult = SWIG_NewPointerObj((new std::vector<unsigned short >(static_cast< const std::vector<unsigned short >& >(result))), SWIGTYPE_p_std__vectorTunsigned_short_t, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConformerData_get_energies(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConformerData *arg1 = (OpenBabel::OBConformerData *) 0 ;
  std::vector<double > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConformerData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetEnergies" "', argument " "1"" of type '" "OpenBabel::OBConformerData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConformerData * >(argp1);
  result = (arg1)->GetEnergies();
  {
    vresult = rb_ary_new2((&result)->size());
    for (unsigned int i=0; i<(&result)->size(); i++)
    rb_ary_store(vresult,i,rb_float_new(((std::vector<double > &)result)[i]));
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConformerData_get_forces(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConformerData *arg1 = (OpenBabel::OBConformerData *) 0 ;
  SwigValueWrapper<std::vector<std::vector<OpenBabel::vector3 > > > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConformerData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetForces" "', argument " "1"" of type '" "OpenBabel::OBConformerData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConformerData * >(argp1);
  result = (arg1)->GetForces();
  vresult = SWIG_NewPointerObj((new std::vector<std::vector<OpenBabel::vector3 > >(static_cast< const std::vector<std::vector<OpenBabel::vector3 > >& >(result))), SWIGTYPE_p_std__vectorTstd__vectorTOpenBabel__vector3_t_t, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConformerData_get_velocities(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConformerData *arg1 = (OpenBabel::OBConformerData *) 0 ;
  SwigValueWrapper<std::vector<std::vector<OpenBabel::vector3 > > > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConformerData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetVelocities" "', argument " "1"" of type '" "OpenBabel::OBConformerData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConformerData * >(argp1);
  result = (arg1)->GetVelocities();
  vresult = SWIG_NewPointerObj((new std::vector<std::vector<OpenBabel::vector3 > >(static_cast< const std::vector<std::vector<OpenBabel::vector3 > >& >(result))), SWIGTYPE_p_std__vectorTstd__vectorTOpenBabel__vector3_t_t, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConformerData_get_displacements(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConformerData *arg1 = (OpenBabel::OBConformerData *) 0 ;
  SwigValueWrapper<std::vector<std::vector<OpenBabel::vector3 > > > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConformerData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetDisplacements" "', argument " "1"" of type '" "OpenBabel::OBConformerData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConformerData * >(argp1);
  result = (arg1)->GetDisplacements();
  vresult = SWIG_NewPointerObj((new std::vector<std::vector<OpenBabel::vector3 > >(static_cast< const std::vector<std::vector<OpenBabel::vector3 > >& >(result))), SWIGTYPE_p_std__vectorTstd__vectorTOpenBabel__vector3_t_t, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConformerData_get_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConformerData *arg1 = (OpenBabel::OBConformerData *) 0 ;
  std::vector<std::string > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConformerData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBConformerData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConformerData * >(argp1);
  result = (arg1)->GetData();
  vresult = SWIG_NewPointerObj((new std::vector<std::string >(static_cast< const std::vector<std::string >& >(result))), SWIGTYPE_p_std__vectorTstd__string_t, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


swig_class cOBSymmetryData;

SWIGINTERN VALUE
_wrap_new_OBSymmetryData__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSymmetryData *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBSymmetryData *)new OpenBabel::OBSymmetryData();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBSymmetryData_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBSymmetryData_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBSymmetryData);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBSymmetryData__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSymmetryData *arg1 = 0 ;
  OpenBabel::OBSymmetryData *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBSymmetryData,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBSymmetryData" "', argument " "1"" of type '" "OpenBabel::OBSymmetryData const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBSymmetryData" "', argument " "1"" of type '" "OpenBabel::OBSymmetryData const &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSymmetryData * >(argp1);
  result = (OpenBabel::OBSymmetryData *)new OpenBabel::OBSymmetryData((OpenBabel::OBSymmetryData const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_OBSymmetryData(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_OBSymmetryData__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBSymmetryData, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBSymmetryData__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_OBSymmetryData'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSymmetryData_clone(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSymmetryData *arg1 = (OpenBabel::OBSymmetryData *) 0 ;
  OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSymmetryData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Clone" "', argument " "1"" of type '" "OpenBabel::OBSymmetryData const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSymmetryData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Clone" "', argument " "2"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  result = (OpenBabel::OBGenericData *)((OpenBabel::OBSymmetryData const *)arg1)->Clone(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBSymmetryData(OpenBabel::OBSymmetryData *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_OBSymmetryData_set_data__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSymmetryData *arg1 = (OpenBabel::OBSymmetryData *) 0 ;
  std::string arg2 ;
  std::string arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSymmetryData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetData" "', argument " "1"" of type '" "OpenBabel::OBSymmetryData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSymmetryData * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "SetData" "', argument " "2"" of type '" "std::string""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "SetData" "', argument " "3"" of type '" "std::string""'"); 
    }
    arg3 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  (arg1)->SetData(arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSymmetryData_set_data__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSymmetryData *arg1 = (OpenBabel::OBSymmetryData *) 0 ;
  std::string arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSymmetryData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetData" "', argument " "1"" of type '" "OpenBabel::OBSymmetryData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSymmetryData * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "SetData" "', argument " "2"" of type '" "std::string""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  (arg1)->SetData(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBSymmetryData_set_data(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBSymmetryData, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBSymmetryData_set_data__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBSymmetryData, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_OBSymmetryData_set_data__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBSymmetryData_set_data'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSymmetryData_set_point_group(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSymmetryData *arg1 = (OpenBabel::OBSymmetryData *) 0 ;
  std::string arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSymmetryData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetPointGroup" "', argument " "1"" of type '" "OpenBabel::OBSymmetryData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSymmetryData * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "SetPointGroup" "', argument " "2"" of type '" "std::string""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  (arg1)->SetPointGroup(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSymmetryData_set_space_group(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSymmetryData *arg1 = (OpenBabel::OBSymmetryData *) 0 ;
  std::string arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSymmetryData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetSpaceGroup" "', argument " "1"" of type '" "OpenBabel::OBSymmetryData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSymmetryData * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "SetSpaceGroup" "', argument " "2"" of type '" "std::string""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  (arg1)->SetSpaceGroup(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSymmetryData_get_point_group(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSymmetryData *arg1 = (OpenBabel::OBSymmetryData *) 0 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSymmetryData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetPointGroup" "', argument " "1"" of type '" "OpenBabel::OBSymmetryData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSymmetryData * >(argp1);
  result = (arg1)->GetPointGroup();
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSymmetryData_get_space_group(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSymmetryData *arg1 = (OpenBabel::OBSymmetryData *) 0 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSymmetryData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetSpaceGroup" "', argument " "1"" of type '" "OpenBabel::OBSymmetryData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSymmetryData * >(argp1);
  result = (arg1)->GetSpaceGroup();
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


swig_class cOBTorsion;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBTorsion_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBTorsion_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBTorsion);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBTorsion__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTorsion *arg1 = 0 ;
  OpenBabel::OBTorsion *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBTorsion,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBTorsion" "', argument " "1"" of type '" "OpenBabel::OBTorsion const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBTorsion" "', argument " "1"" of type '" "OpenBabel::OBTorsion const &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBTorsion * >(argp1);
  result = (OpenBabel::OBTorsion *)new OpenBabel::OBTorsion((OpenBabel::OBTorsion const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_OBTorsion(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBTorsion, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBTorsion__SWIG_2(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_OBTorsion'");
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBTorsion(OpenBabel::OBTorsion *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_OBTorsion_clear(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTorsion *arg1 = (OpenBabel::OBTorsion *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTorsion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Clear" "', argument " "1"" of type '" "OpenBabel::OBTorsion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBTorsion * >(argp1);
  (arg1)->Clear();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBTorsion_empty(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTorsion *arg1 = (OpenBabel::OBTorsion *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTorsion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Empty" "', argument " "1"" of type '" "OpenBabel::OBTorsion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBTorsion * >(argp1);
  result = (bool)(arg1)->Empty();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBTorsion_add_torsion__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTorsion *arg1 = (OpenBabel::OBTorsion *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg3 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg4 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg5 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTorsion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AddTorsion" "', argument " "1"" of type '" "OpenBabel::OBTorsion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBTorsion * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AddTorsion" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "AddTorsion" "', argument " "3"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBAtom * >(argp3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "AddTorsion" "', argument " "4"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg4 = reinterpret_cast< OpenBabel::OBAtom * >(argp4);
  res5 = SWIG_ConvertPtr(argv[3], &argp5,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "AddTorsion" "', argument " "5"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg5 = reinterpret_cast< OpenBabel::OBAtom * >(argp5);
  result = (bool)(arg1)->AddTorsion(arg2,arg3,arg4,arg5);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBTorsion_add_torsion__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTorsion *arg1 = (OpenBabel::OBTorsion *) 0 ;
  OpenBabel::quad<OpenBabel::OBAtom *,OpenBabel::OBAtom *,OpenBabel::OBAtom *,OpenBabel::OBAtom * > *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTorsion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AddTorsion" "', argument " "1"" of type '" "OpenBabel::OBTorsion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBTorsion * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__quadTOpenBabel__OBAtom_p_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AddTorsion" "', argument " "2"" of type '" "OpenBabel::quad<OpenBabel::OBAtom *,OpenBabel::OBAtom *,OpenBabel::OBAtom *,OpenBabel::OBAtom * > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "AddTorsion" "', argument " "2"" of type '" "OpenBabel::quad<OpenBabel::OBAtom *,OpenBabel::OBAtom *,OpenBabel::OBAtom *,OpenBabel::OBAtom * > &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::quad<OpenBabel::OBAtom *,OpenBabel::OBAtom *,OpenBabel::OBAtom *,OpenBabel::OBAtom * > * >(argp2);
  result = (bool)(arg1)->AddTorsion(*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBTorsion_add_torsion(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[6];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 6) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBTorsion, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__quadTOpenBabel__OBAtom_p_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_t, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBTorsion_add_torsion__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 5) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBTorsion, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            void *vptr = 0;
            int res = SWIG_ConvertPtr(argv[4], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
            _v = SWIG_CheckState(res);
            if (_v) {
              return _wrap_OBTorsion_add_torsion__SWIG_0(nargs, args, self);
            }
          }
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBTorsion_add_torsion'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBTorsion_set_angle__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTorsion *arg1 = (OpenBabel::OBTorsion *) 0 ;
  double arg2 ;
  unsigned int arg3 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTorsion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetAngle" "', argument " "1"" of type '" "OpenBabel::OBTorsion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBTorsion * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetAngle" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SetAngle" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  result = (bool)(arg1)->SetAngle(arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBTorsion_set_angle__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTorsion *arg1 = (OpenBabel::OBTorsion *) 0 ;
  double arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTorsion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetAngle" "', argument " "1"" of type '" "OpenBabel::OBTorsion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBTorsion * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetAngle" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  result = (bool)(arg1)->SetAngle(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBTorsion_set_angle(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBTorsion, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBTorsion_set_angle__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBTorsion, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_OBTorsion_set_angle__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBTorsion_set_angle'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBTorsion_set_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTorsion *arg1 = (OpenBabel::OBTorsion *) 0 ;
  OpenBabel::OBBond *arg2 = (OpenBabel::OBBond *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTorsion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetData" "', argument " "1"" of type '" "OpenBabel::OBTorsion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBTorsion * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetData" "', argument " "2"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBond * >(argp2);
  result = (bool)(arg1)->SetData(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBTorsion_get_angle__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTorsion *arg1 = (OpenBabel::OBTorsion *) 0 ;
  double *arg2 = 0 ;
  unsigned int arg3 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTorsion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAngle" "', argument " "1"" of type '" "OpenBabel::OBTorsion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBTorsion * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_double,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetAngle" "', argument " "2"" of type '" "double &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GetAngle" "', argument " "2"" of type '" "double &""'"); 
  }
  arg2 = reinterpret_cast< double * >(argp2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "GetAngle" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  result = (bool)(arg1)->GetAngle(*arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBTorsion_get_angle__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTorsion *arg1 = (OpenBabel::OBTorsion *) 0 ;
  double *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTorsion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAngle" "', argument " "1"" of type '" "OpenBabel::OBTorsion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBTorsion * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_double,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetAngle" "', argument " "2"" of type '" "double &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GetAngle" "', argument " "2"" of type '" "double &""'"); 
  }
  arg2 = reinterpret_cast< double * >(argp2);
  result = (bool)(arg1)->GetAngle(*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBTorsion_get_angle(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBTorsion, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_double, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBTorsion_get_angle__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBTorsion, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_double, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_OBTorsion_get_angle__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBTorsion_get_angle'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBTorsion_get_bond_idx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTorsion *arg1 = (OpenBabel::OBTorsion *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTorsion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetBondIdx" "', argument " "1"" of type '" "OpenBabel::OBTorsion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBTorsion * >(argp1);
  result = (unsigned int)(arg1)->GetBondIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBTorsion_get_size(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTorsion *arg1 = (OpenBabel::OBTorsion *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTorsion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetSize" "', argument " "1"" of type '" "OpenBabel::OBTorsion const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBTorsion * >(argp1);
  result = (unsigned int)((OpenBabel::OBTorsion const *)arg1)->GetSize();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBTorsion_get_bc(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTorsion *arg1 = (OpenBabel::OBTorsion *) 0 ;
  SwigValueWrapper<std::pair<OpenBabel::OBAtom *,OpenBabel::OBAtom * > > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTorsion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetBC" "', argument " "1"" of type '" "OpenBabel::OBTorsion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBTorsion * >(argp1);
  result = (arg1)->GetBC();
  vresult = SWIG_NewPointerObj((new std::pair<OpenBabel::OBAtom *,OpenBabel::OBAtom * >(static_cast< const std::pair<OpenBabel::OBAtom *,OpenBabel::OBAtom * >& >(result))), SWIGTYPE_p_std__pairTOpenBabel__OBAtom_p_OpenBabel__OBAtom_p_t, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBTorsion_get_ads(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTorsion *arg1 = (OpenBabel::OBTorsion *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::triple<OpenBabel::OBAtom *,OpenBabel::OBAtom *,double > > > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTorsion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetADs" "', argument " "1"" of type '" "OpenBabel::OBTorsion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBTorsion * >(argp1);
  result = (arg1)->GetADs();
  vresult = SWIG_NewPointerObj((new std::vector<OpenBabel::triple<OpenBabel::OBAtom *,OpenBabel::OBAtom *,double > >(static_cast< const std::vector<OpenBabel::triple<OpenBabel::OBAtom *,OpenBabel::OBAtom *,double > >& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__tripleTOpenBabel__OBAtom_p_OpenBabel__OBAtom_p_double_t_t, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBTorsion_is_proton_rotor(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTorsion *arg1 = (OpenBabel::OBTorsion *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTorsion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsProtonRotor" "', argument " "1"" of type '" "OpenBabel::OBTorsion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBTorsion * >(argp1);
  result = (bool)(arg1)->IsProtonRotor();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


swig_class cOBTorsionData;

SWIGINTERN VALUE
_wrap_OBTorsionData_clone(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTorsionData *arg1 = (OpenBabel::OBTorsionData *) 0 ;
  OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTorsionData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Clone" "', argument " "1"" of type '" "OpenBabel::OBTorsionData const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBTorsionData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Clone" "', argument " "2"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  result = (OpenBabel::OBGenericData *)((OpenBabel::OBTorsionData const *)arg1)->Clone(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBTorsionData_clear(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTorsionData *arg1 = (OpenBabel::OBTorsionData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTorsionData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Clear" "', argument " "1"" of type '" "OpenBabel::OBTorsionData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBTorsionData * >(argp1);
  (arg1)->Clear();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBTorsionData_get_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTorsionData *arg1 = (OpenBabel::OBTorsionData *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBTorsion > > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTorsionData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBTorsionData const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBTorsionData * >(argp1);
  result = ((OpenBabel::OBTorsionData const *)arg1)->GetData();
  vresult = SWIG_NewPointerObj((new std::vector<OpenBabel::OBTorsion >(static_cast< const std::vector<OpenBabel::OBTorsion >& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBTorsion_t, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBTorsionData_get_size(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTorsionData *arg1 = (OpenBabel::OBTorsionData *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTorsionData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetSize" "', argument " "1"" of type '" "OpenBabel::OBTorsionData const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBTorsionData * >(argp1);
  result = (unsigned int)((OpenBabel::OBTorsionData const *)arg1)->GetSize();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBTorsionData_set_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTorsionData *arg1 = (OpenBabel::OBTorsionData *) 0 ;
  OpenBabel::OBTorsion *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTorsionData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetData" "', argument " "1"" of type '" "OpenBabel::OBTorsionData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBTorsionData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBTorsion,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetData" "', argument " "2"" of type '" "OpenBabel::OBTorsion &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetData" "', argument " "2"" of type '" "OpenBabel::OBTorsion &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBTorsion * >(argp2);
  (arg1)->SetData(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBTorsionData_fill_torsion_array(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTorsionData *arg1 = (OpenBabel::OBTorsionData *) 0 ;
  std::vector<std::vector<unsigned int > > *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTorsionData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FillTorsionArray" "', argument " "1"" of type '" "OpenBabel::OBTorsionData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBTorsionData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTstd__vectorTunsigned_int_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "FillTorsionArray" "', argument " "2"" of type '" "std::vector<std::vector<unsigned int > > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "FillTorsionArray" "', argument " "2"" of type '" "std::vector<std::vector<unsigned int > > &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<std::vector<unsigned int > > * >(argp2);
  result = (bool)(arg1)->FillTorsionArray(*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBTorsionData(OpenBabel::OBTorsionData *arg1) {
    delete arg1;
}

swig_class cOBAngle;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBAngle_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBAngle_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBAngle);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBAngle__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAngle *arg1 = 0 ;
  OpenBabel::OBAngle *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBAngle,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBAngle" "', argument " "1"" of type '" "OpenBabel::OBAngle const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBAngle" "', argument " "1"" of type '" "OpenBabel::OBAngle const &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAngle * >(argp1);
  result = (OpenBabel::OBAngle *)new OpenBabel::OBAngle((OpenBabel::OBAngle const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_OBAngle(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAngle, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBAngle__SWIG_2(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_OBAngle'");
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBAngle(OpenBabel::OBAngle *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_OBAngle___eq__(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAngle *arg1 = (OpenBabel::OBAngle *) 0 ;
  OpenBabel::OBAngle *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAngle, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator ==" "', argument " "1"" of type '" "OpenBabel::OBAngle *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAngle * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBAngle,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "operator ==" "', argument " "2"" of type '" "OpenBabel::OBAngle const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "operator ==" "', argument " "2"" of type '" "OpenBabel::OBAngle const &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAngle * >(argp2);
  result = (bool)(arg1)->operator ==((OpenBabel::OBAngle const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAngle_clear(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAngle *arg1 = (OpenBabel::OBAngle *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAngle, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Clear" "', argument " "1"" of type '" "OpenBabel::OBAngle *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAngle * >(argp1);
  (arg1)->Clear();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAngle_get_angle(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAngle *arg1 = (OpenBabel::OBAngle *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAngle, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAngle" "', argument " "1"" of type '" "OpenBabel::OBAngle const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAngle * >(argp1);
  result = (double)((OpenBabel::OBAngle const *)arg1)->GetAngle();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAngle_set_angle(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAngle *arg1 = (OpenBabel::OBAngle *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAngle, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetAngle" "', argument " "1"" of type '" "OpenBabel::OBAngle *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAngle * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetAngle" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  (arg1)->SetAngle(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAngle_set_atoms__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAngle *arg1 = (OpenBabel::OBAngle *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg3 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg4 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAngle, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetAtoms" "', argument " "1"" of type '" "OpenBabel::OBAngle *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAngle * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetAtoms" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SetAtoms" "', argument " "3"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBAtom * >(argp3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "SetAtoms" "', argument " "4"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg4 = reinterpret_cast< OpenBabel::OBAtom * >(argp4);
  (arg1)->SetAtoms(arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAngle_set_atoms__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAngle *arg1 = (OpenBabel::OBAngle *) 0 ;
  OpenBabel::triple<OpenBabel::OBAtom *,OpenBabel::OBAtom *,OpenBabel::OBAtom * > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAngle, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetAtoms" "', argument " "1"" of type '" "OpenBabel::OBAngle *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAngle * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__tripleTOpenBabel__OBAtom_p_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetAtoms" "', argument " "2"" of type '" "OpenBabel::triple<OpenBabel::OBAtom *,OpenBabel::OBAtom *,OpenBabel::OBAtom * > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetAtoms" "', argument " "2"" of type '" "OpenBabel::triple<OpenBabel::OBAtom *,OpenBabel::OBAtom *,OpenBabel::OBAtom * > &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::triple<OpenBabel::OBAtom *,OpenBabel::OBAtom *,OpenBabel::OBAtom * > * >(argp2);
  (arg1)->SetAtoms(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBAngle_set_atoms(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAngle, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__tripleTOpenBabel__OBAtom_p_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_t, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBAngle_set_atoms__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAngle, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_OBAngle_set_atoms__SWIG_0(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBAngle_set_atoms'");
  return Qnil;
}


swig_class cOBAngleData;

SWIGINTERN VALUE
_wrap_OBAngleData_clone(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAngleData *arg1 = (OpenBabel::OBAngleData *) 0 ;
  OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAngleData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Clone" "', argument " "1"" of type '" "OpenBabel::OBAngleData const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAngleData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Clone" "', argument " "2"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  result = (OpenBabel::OBGenericData *)((OpenBabel::OBAngleData const *)arg1)->Clone(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAngleData_clear(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAngleData *arg1 = (OpenBabel::OBAngleData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAngleData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Clear" "', argument " "1"" of type '" "OpenBabel::OBAngleData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAngleData * >(argp1);
  (arg1)->Clear();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAngleData_fill_angle_array__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAngleData *arg1 = (OpenBabel::OBAngleData *) 0 ;
  int **arg2 = (int **) 0 ;
  unsigned int *arg3 = 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAngleData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FillAngleArray" "', argument " "1"" of type '" "OpenBabel::OBAngleData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAngleData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_p_int, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "FillAngleArray" "', argument " "2"" of type '" "int **""'"); 
  }
  arg2 = reinterpret_cast< int ** >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_unsigned_int,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "FillAngleArray" "', argument " "3"" of type '" "unsigned int &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "FillAngleArray" "', argument " "3"" of type '" "unsigned int &""'"); 
  }
  arg3 = reinterpret_cast< unsigned int * >(argp3);
  result = (unsigned int)(arg1)->FillAngleArray(arg2,*arg3);
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAngleData_fill_angle_array__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAngleData *arg1 = (OpenBabel::OBAngleData *) 0 ;
  std::vector<std::vector<unsigned int > > *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAngleData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FillAngleArray" "', argument " "1"" of type '" "OpenBabel::OBAngleData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAngleData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTstd__vectorTunsigned_int_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "FillAngleArray" "', argument " "2"" of type '" "std::vector<std::vector<unsigned int > > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "FillAngleArray" "', argument " "2"" of type '" "std::vector<std::vector<unsigned int > > &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<std::vector<unsigned int > > * >(argp2);
  result = (bool)(arg1)->FillAngleArray(*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBAngleData_fill_angle_array(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAngleData, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__vectorTstd__vectorTunsigned_int_t_t, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBAngleData_fill_angle_array__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAngleData, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_p_int, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_unsigned_int, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_OBAngleData_fill_angle_array__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBAngleData_fill_angle_array'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAngleData_set_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAngleData *arg1 = (OpenBabel::OBAngleData *) 0 ;
  OpenBabel::OBAngle *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAngleData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetData" "', argument " "1"" of type '" "OpenBabel::OBAngleData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAngleData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBAngle,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetData" "', argument " "2"" of type '" "OpenBabel::OBAngle &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetData" "', argument " "2"" of type '" "OpenBabel::OBAngle &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAngle * >(argp2);
  (arg1)->SetData(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAngleData_get_size(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAngleData *arg1 = (OpenBabel::OBAngleData *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAngleData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetSize" "', argument " "1"" of type '" "OpenBabel::OBAngleData const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAngleData * >(argp1);
  result = (unsigned int)((OpenBabel::OBAngleData const *)arg1)->GetSize();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBAngleData(OpenBabel::OBAngleData *arg1) {
    delete arg1;
}

swig_class cOBChiralData;

SWIGINTERN VALUE
_wrap_new_OBChiralData__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBChiralData *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBChiralData *)new OpenBabel::OBChiralData();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBChiralData_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBChiralData_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBChiralData);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBChiralData__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBChiralData *arg1 = 0 ;
  OpenBabel::OBChiralData *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBChiralData,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBChiralData" "', argument " "1"" of type '" "OpenBabel::OBChiralData const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBChiralData" "', argument " "1"" of type '" "OpenBabel::OBChiralData const &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBChiralData * >(argp1);
  result = (OpenBabel::OBChiralData *)new OpenBabel::OBChiralData((OpenBabel::OBChiralData const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_OBChiralData(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_OBChiralData__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBChiralData, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBChiralData__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_OBChiralData'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBChiralData_clone(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBChiralData *arg1 = (OpenBabel::OBChiralData *) 0 ;
  OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBChiralData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Clone" "', argument " "1"" of type '" "OpenBabel::OBChiralData const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBChiralData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Clone" "', argument " "2"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  result = (OpenBabel::OBGenericData *)((OpenBabel::OBChiralData const *)arg1)->Clone(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBChiralData(OpenBabel::OBChiralData *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_OBChiralData_clear(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBChiralData *arg1 = (OpenBabel::OBChiralData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBChiralData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Clear" "', argument " "1"" of type '" "OpenBabel::OBChiralData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBChiralData * >(argp1);
  (arg1)->Clear();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBChiralData_get_atom_4refs(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBChiralData *arg1 = (OpenBabel::OBChiralData *) 0 ;
  OpenBabel::atomreftype arg2 ;
  std::vector<unsigned int > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBChiralData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAtom4Refs" "', argument " "1"" of type '" "OpenBabel::OBChiralData const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBChiralData * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetAtom4Refs" "', argument " "2"" of type '" "OpenBabel::atomreftype""'");
  } 
  arg2 = static_cast< OpenBabel::atomreftype >(val2);
  result = ((OpenBabel::OBChiralData const *)arg1)->GetAtom4Refs(arg2);
  {
    vresult = rb_ary_new2((&result)->size());
    for (unsigned int i=0; i<(&result)->size(); i++)
    rb_ary_store(vresult,i,INT2NUM(((std::vector<unsigned int > &)result)[i]));
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBChiralData_get_atom_ref(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBChiralData *arg1 = (OpenBabel::OBChiralData *) 0 ;
  int arg2 ;
  OpenBabel::atomreftype arg3 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBChiralData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAtomRef" "', argument " "1"" of type '" "OpenBabel::OBChiralData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBChiralData * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetAtomRef" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "GetAtomRef" "', argument " "3"" of type '" "OpenBabel::atomreftype""'");
  } 
  arg3 = static_cast< OpenBabel::atomreftype >(val3);
  result = (unsigned int)(arg1)->GetAtomRef(arg2,arg3);
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBChiralData_set_atom_4refs(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBChiralData *arg1 = (OpenBabel::OBChiralData *) 0 ;
  std::vector<unsigned int > arg2 ;
  OpenBabel::atomreftype arg3 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBChiralData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetAtom4Refs" "', argument " "1"" of type '" "OpenBabel::OBChiralData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBChiralData * >(argp1);
  {
    if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
      unsigned int size = RARRAY_LEN(argv[0]);
      arg2 = std::vector<unsigned int >(size);
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(argv[0])[i];
        if (FIXNUM_P(o))
        ((std::vector<unsigned int > &)arg2)[i] = (unsigned int)(FIX2INT(o));
        else
        rb_raise(rb_eTypeError,
          "wrong argument type"
          " (expected vector<""unsigned int" ">)");
      }
    } else {
      void *ptr;
      SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_std__vectorTunsigned_int_t, 1);
      arg2 = *((std::vector<unsigned int > *) ptr);
    }
  }
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SetAtom4Refs" "', argument " "3"" of type '" "OpenBabel::atomreftype""'");
  } 
  arg3 = static_cast< OpenBabel::atomreftype >(val3);
  result = (bool)(arg1)->SetAtom4Refs(arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBChiralData_add_atom_ref(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBChiralData *arg1 = (OpenBabel::OBChiralData *) 0 ;
  unsigned int arg2 ;
  OpenBabel::atomreftype arg3 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBChiralData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AddAtomRef" "', argument " "1"" of type '" "OpenBabel::OBChiralData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBChiralData * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "AddAtomRef" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "AddAtomRef" "', argument " "3"" of type '" "OpenBabel::atomreftype""'");
  } 
  arg3 = static_cast< OpenBabel::atomreftype >(val3);
  result = (int)(arg1)->AddAtomRef(arg2,arg3);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBChiralData_get_size(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBChiralData *arg1 = (OpenBabel::OBChiralData *) 0 ;
  OpenBabel::atomreftype arg2 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBChiralData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetSize" "', argument " "1"" of type '" "OpenBabel::OBChiralData const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBChiralData * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetSize" "', argument " "2"" of type '" "OpenBabel::atomreftype""'");
  } 
  arg2 = static_cast< OpenBabel::atomreftype >(val2);
  result = (unsigned int)((OpenBabel::OBChiralData const *)arg1)->GetSize(arg2);
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


swig_class cOBSerialNums;

SWIGINTERN VALUE
_wrap_new_OBSerialNums__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSerialNums *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBSerialNums *)new OpenBabel::OBSerialNums();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBSerialNums_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBSerialNums_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBSerialNums);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBSerialNums__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSerialNums *arg1 = 0 ;
  OpenBabel::OBSerialNums *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBSerialNums,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBSerialNums" "', argument " "1"" of type '" "OpenBabel::OBSerialNums const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBSerialNums" "', argument " "1"" of type '" "OpenBabel::OBSerialNums const &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSerialNums * >(argp1);
  result = (OpenBabel::OBSerialNums *)new OpenBabel::OBSerialNums((OpenBabel::OBSerialNums const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_OBSerialNums(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_OBSerialNums__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBSerialNums, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBSerialNums__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_OBSerialNums'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSerialNums_clone(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSerialNums *arg1 = (OpenBabel::OBSerialNums *) 0 ;
  OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSerialNums, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Clone" "', argument " "1"" of type '" "OpenBabel::OBSerialNums const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSerialNums * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Clone" "', argument " "2"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  result = (OpenBabel::OBGenericData *)((OpenBabel::OBSerialNums const *)arg1)->Clone(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSerialNums_get_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSerialNums *arg1 = (OpenBabel::OBSerialNums *) 0 ;
  std::map<int,OpenBabel::OBAtom * > *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSerialNums, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBSerialNums *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSerialNums * >(argp1);
  {
    std::map<int,OpenBabel::OBAtom * > &_result_ref = (arg1)->GetData();
    result = (std::map<int,OpenBabel::OBAtom * > *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__mapTint_OpenBabel__OBAtom_p_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSerialNums_set_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSerialNums *arg1 = (OpenBabel::OBSerialNums *) 0 ;
  std::map<int,OpenBabel::OBAtom * > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSerialNums, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetData" "', argument " "1"" of type '" "OpenBabel::OBSerialNums *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSerialNums * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__mapTint_OpenBabel__OBAtom_p_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetData" "', argument " "2"" of type '" "std::map<int,OpenBabel::OBAtom * > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetData" "', argument " "2"" of type '" "std::map<int,OpenBabel::OBAtom * > &""'"); 
  }
  arg2 = reinterpret_cast< std::map<int,OpenBabel::OBAtom * > * >(argp2);
  (arg1)->SetData(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBSerialNums(OpenBabel::OBSerialNums *arg1) {
    delete arg1;
}

swig_class cOBVibrationData;

SWIGINTERN VALUE
_wrap_new_OBVibrationData__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBVibrationData *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBVibrationData *)new OpenBabel::OBVibrationData();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBVibrationData_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBVibrationData_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBVibrationData);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBVibrationData__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBVibrationData *arg1 = 0 ;
  OpenBabel::OBVibrationData *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBVibrationData,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBVibrationData" "', argument " "1"" of type '" "OpenBabel::OBVibrationData const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBVibrationData" "', argument " "1"" of type '" "OpenBabel::OBVibrationData const &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBVibrationData * >(argp1);
  result = (OpenBabel::OBVibrationData *)new OpenBabel::OBVibrationData((OpenBabel::OBVibrationData const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_OBVibrationData(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_OBVibrationData__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBVibrationData, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBVibrationData__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_OBVibrationData'");
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBVibrationData(OpenBabel::OBVibrationData *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_OBVibrationData_set_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBVibrationData *arg1 = (OpenBabel::OBVibrationData *) 0 ;
  std::vector<std::vector<OpenBabel::vector3 > > *arg2 = 0 ;
  std::vector<double > *arg3 = 0 ;
  std::vector<double > *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  std::vector<double > temp3 ;
  std::vector<double > temp4 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBVibrationData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetData" "', argument " "1"" of type '" "OpenBabel::OBVibrationData *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBVibrationData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTstd__vectorTOpenBabel__vector3_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetData" "', argument " "2"" of type '" "std::vector<std::vector<OpenBabel::vector3 > > const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetData" "', argument " "2"" of type '" "std::vector<std::vector<OpenBabel::vector3 > > const &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<std::vector<OpenBabel::vector3 > > * >(argp2);
  {
    if (rb_obj_is_kind_of(argv[1],rb_cArray)) {
      unsigned int size = RARRAY_LEN(argv[1]);
      temp3 = std::vector<double >(size);
      arg3 = &temp3;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(argv[1])[i];
        if (SWIG_FLOAT_P(o))
        temp3[i] = (double)(SWIG_NUM2DBL(o));
        else
        rb_raise(rb_eTypeError,
          "wrong argument type"
          " (expected vector<""double" ">)");
      }
    } else {
      SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_std__vectorTdouble_t, 1);
    }
  }
  {
    if (rb_obj_is_kind_of(argv[2],rb_cArray)) {
      unsigned int size = RARRAY_LEN(argv[2]);
      temp4 = std::vector<double >(size);
      arg4 = &temp4;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(argv[2])[i];
        if (SWIG_FLOAT_P(o))
        temp4[i] = (double)(SWIG_NUM2DBL(o));
        else
        rb_raise(rb_eTypeError,
          "wrong argument type"
          " (expected vector<""double" ">)");
      }
    } else {
      SWIG_ConvertPtr(argv[2], (void **) &arg4, SWIGTYPE_p_std__vectorTdouble_t, 1);
    }
  }
  (arg1)->SetData((std::vector<std::vector<OpenBabel::vector3 > > const &)*arg2,(std::vector<double > const &)*arg3,(std::vector<double > const &)*arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBVibrationData_get_lx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBVibrationData *arg1 = (OpenBabel::OBVibrationData *) 0 ;
  SwigValueWrapper<std::vector<std::vector<OpenBabel::vector3 > > > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBVibrationData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetLx" "', argument " "1"" of type '" "OpenBabel::OBVibrationData const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBVibrationData * >(argp1);
  result = ((OpenBabel::OBVibrationData const *)arg1)->GetLx();
  vresult = SWIG_NewPointerObj((new std::vector<std::vector<OpenBabel::vector3 > >(static_cast< const std::vector<std::vector<OpenBabel::vector3 > >& >(result))), SWIGTYPE_p_std__vectorTstd__vectorTOpenBabel__vector3_t_t, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBVibrationData_get_frequencies(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBVibrationData *arg1 = (OpenBabel::OBVibrationData *) 0 ;
  std::vector<double > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBVibrationData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetFrequencies" "', argument " "1"" of type '" "OpenBabel::OBVibrationData const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBVibrationData * >(argp1);
  result = ((OpenBabel::OBVibrationData const *)arg1)->GetFrequencies();
  {
    vresult = rb_ary_new2((&result)->size());
    for (unsigned int i=0; i<(&result)->size(); i++)
    rb_ary_store(vresult,i,rb_float_new(((std::vector<double > &)result)[i]));
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBVibrationData_get_intensities(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBVibrationData *arg1 = (OpenBabel::OBVibrationData *) 0 ;
  std::vector<double > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBVibrationData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetIntensities" "', argument " "1"" of type '" "OpenBabel::OBVibrationData const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBVibrationData * >(argp1);
  result = ((OpenBabel::OBVibrationData const *)arg1)->GetIntensities();
  {
    vresult = rb_ary_new2((&result)->size());
    for (unsigned int i=0; i<(&result)->size(); i++)
    rb_ary_store(vresult,i,rb_float_new(((std::vector<double > &)result)[i]));
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBVibrationData_get_number_of_frequencies(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBVibrationData *arg1 = (OpenBabel::OBVibrationData *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBVibrationData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetNumberOfFrequencies" "', argument " "1"" of type '" "OpenBabel::OBVibrationData const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBVibrationData * >(argp1);
  result = (unsigned int)((OpenBabel::OBVibrationData const *)arg1)->GetNumberOfFrequencies();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


swig_class cOBBase;

SWIGINTERN void
free_OpenBabel_OBBase(OpenBabel::OBBase *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_OBBase_clear(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBase *arg1 = (OpenBabel::OBBase *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Clear" "', argument " "1"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBase * >(argp1);
  result = (bool)(arg1)->Clear();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBase_do_transformations(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBase *arg1 = (OpenBabel::OBBase *) 0 ;
  std::map<std::string,std::string > *arg2 = (std::map<std::string,std::string > *) 0 ;
  OpenBabel::OBBase *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DoTransformations" "', argument " "1"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBase * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_std__mapTstd__string_std__string_t, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DoTransformations" "', argument " "2"" of type '" "std::map<std::string,std::string > const *""'"); 
  }
  arg2 = reinterpret_cast< std::map<std::string,std::string > * >(argp2);
  result = (OpenBabel::OBBase *)(arg1)->DoTransformations((std::map<std::string,std::string > const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBase_class_description(int argc, VALUE *argv, VALUE self) {
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (char *)OpenBabel::OBBase::ClassDescription();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBase_has_data__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBase *arg1 = (OpenBabel::OBBase *) 0 ;
  std::string *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasData" "', argument " "1"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBase * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "HasData" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "HasData" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (bool)(arg1)->HasData((std::string const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBase_has_data__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBase *arg1 = (OpenBabel::OBBase *) 0 ;
  char *arg2 = (char *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasData" "', argument " "1"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBase * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "HasData" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (bool)(arg1)->HasData((char const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBase_has_data__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBase *arg1 = (OpenBabel::OBBase *) 0 ;
  unsigned int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasData" "', argument " "1"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBase * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "HasData" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (bool)(arg1)->HasData(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBBase_has_data(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBBase_has_data__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBBase_has_data__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBBase_has_data__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBBase_has_data'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBase_delete_data__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBase *arg1 = (OpenBabel::OBBase *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteData" "', argument " "1"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBase * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DeleteData" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  (arg1)->DeleteData(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBase_delete_data__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBase *arg1 = (OpenBabel::OBBase *) 0 ;
  OpenBabel::OBGenericData *arg2 = (OpenBabel::OBGenericData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteData" "', argument " "1"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBase * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DeleteData" "', argument " "2"" of type '" "OpenBabel::OBGenericData *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBGenericData * >(argp2);
  (arg1)->DeleteData(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBase_delete_data__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBase *arg1 = (OpenBabel::OBBase *) 0 ;
  std::vector<OpenBabel::OBGenericData * > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteData" "', argument " "1"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBase * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DeleteData" "', argument " "2"" of type '" "std::vector<OpenBabel::OBGenericData * > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DeleteData" "', argument " "2"" of type '" "std::vector<OpenBabel::OBGenericData * > &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<OpenBabel::OBGenericData * > * >(argp2);
  (arg1)->DeleteData(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBBase_delete_data(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBGenericData, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBBase_delete_data__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBBase_delete_data__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBBase_delete_data__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBBase_delete_data'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBase_set_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBase *arg1 = (OpenBabel::OBBase *) 0 ;
  OpenBabel::OBGenericData *arg2 = (OpenBabel::OBGenericData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetData" "', argument " "1"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBase * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetData" "', argument " "2"" of type '" "OpenBabel::OBGenericData *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBGenericData * >(argp2);
  (arg1)->SetData(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBase_data_size(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBase *arg1 = (OpenBabel::OBBase *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataSize" "', argument " "1"" of type '" "OpenBabel::OBBase const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBase * >(argp1);
  result = (unsigned int)((OpenBabel::OBBase const *)arg1)->DataSize();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBase_get_data__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBase *arg1 = (OpenBabel::OBBase *) 0 ;
  unsigned int arg2 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBase * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetData" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (OpenBabel::OBGenericData *)(arg1)->GetData(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBase_get_data__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBase *arg1 = (OpenBabel::OBBase *) 0 ;
  std::string *arg2 = 0 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBase * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetData" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GetData" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (OpenBabel::OBGenericData *)(arg1)->GetData((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBase_get_data__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBase *arg1 = (OpenBabel::OBBase *) 0 ;
  char *arg2 = (char *) 0 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBase * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetData" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (OpenBabel::OBGenericData *)(arg1)->GetData((char const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBase_get_data__SWIG_3(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBase *arg1 = (OpenBabel::OBBase *) 0 ;
  std::vector<OpenBabel::OBGenericData * > *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBase * >(argp1);
  {
    std::vector<OpenBabel::OBGenericData * > &_result_ref = (arg1)->GetData();
    result = (std::vector<OpenBabel::OBGenericData * > *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBase_get_data__SWIG_4(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBase *arg1 = (OpenBabel::OBBase *) 0 ;
  OpenBabel::DataOrigin arg2 ;
  std::vector<OpenBabel::OBGenericData * > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBase * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetData" "', argument " "2"" of type '" "OpenBabel::DataOrigin""'");
  } 
  arg2 = static_cast< OpenBabel::DataOrigin >(val2);
  result = (arg1)->GetData(arg2);
  {
    vresult = rb_ary_new2((&result)->size());
    for (unsigned int i=0; i<(&result)->size(); i++) {
      OpenBabel::OBGenericData* x = ((std::vector<OpenBabel::OBGenericData * > &)result)[i];
      rb_ary_store(vresult,i,
        SWIG_NewPointerObj((void *) x, 
          SWIGTYPE_p_OpenBabel__OBGenericData, 0));
    }
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBBase_get_data(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBBase_get_data__SWIG_3(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBBase_get_data__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBBase_get_data__SWIG_4(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBBase_get_data__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBBase_get_data__SWIG_2(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBBase_get_data'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBase_begin_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBase *arg1 = (OpenBabel::OBBase *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBGenericData * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginData" "', argument " "1"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBase * >(argp1);
  result = (arg1)->BeginData();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBDataIterator(static_cast< const OpenBabel::OBDataIterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBase_end_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBase *arg1 = (OpenBabel::OBBase *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBGenericData * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EndData" "', argument " "1"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBase * >(argp1);
  result = (arg1)->EndData();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBDataIterator(static_cast< const OpenBabel::OBDataIterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBBase_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBBase_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBBase);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBBase(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBase *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBBase *)new OpenBabel::OBBase();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


swig_class cPluginiterFingerprint;

SWIGINTERN VALUE
_wrap_pluginiterFingerprint_register(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBFingerprint > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBFingerprint > *) 0 ;
  OpenBabel::OBFingerprint *arg2 = (OpenBabel::OBFingerprint *) 0 ;
  std::string arg3 ;
  bool arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBFingerprint_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Register" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBFingerprint > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBFingerprint > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBFingerprint, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Register" "', argument " "2"" of type '" "OpenBabel::OBFingerprint *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBFingerprint * >(argp2);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "Register" "', argument " "3"" of type '" "std::string const""'"); 
    }
    arg3 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  ecode4 = SWIG_AsVal_bool(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Register" "', argument " "4"" of type '" "bool""'");
  } 
  arg4 = static_cast< bool >(val4);
  (arg1)->Register(arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterFingerprint_find_type(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBFingerprint > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBFingerprint > *) 0 ;
  std::string *arg2 = 0 ;
  OpenBabel::OBFingerprint *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBFingerprint_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FindType" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBFingerprint > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBFingerprint > * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "FindType" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "FindType" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (OpenBabel::OBFingerprint *)(arg1)->FindType((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBFingerprint, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterFingerprint_find_default_type(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBFingerprint > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBFingerprint > *) 0 ;
  OpenBabel::OBFingerprint *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBFingerprint_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FindDefaultType" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBFingerprint > const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBFingerprint > * >(argp1);
  result = (OpenBabel::OBFingerprint *)((OpenBabel::PluginIter<OpenBabel::OBFingerprint > const *)arg1)->FindDefaultType();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBFingerprint, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterFingerprint_id(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBFingerprint > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBFingerprint > *) 0 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBFingerprint_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ID" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBFingerprint > const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBFingerprint > * >(argp1);
  result = ((OpenBabel::PluginIter<OpenBabel::OBFingerprint > const *)arg1)->ID();
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterFingerprint_to_start(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBFingerprint > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBFingerprint > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBFingerprint_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ToStart" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBFingerprint > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBFingerprint > * >(argp1);
  (arg1)->ToStart();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterFingerprint_inc(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBFingerprint > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBFingerprint > *) 0 ;
  OpenBabel::PluginIter<OpenBabel::OBFingerprint > *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBFingerprint_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator ++" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBFingerprint > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBFingerprint > * >(argp1);
  {
    OpenBabel::PluginIter<OpenBabel::OBFingerprint > &_result_ref = (arg1)->operator ++();
    result = (OpenBabel::PluginIter<OpenBabel::OBFingerprint > *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBFingerprint_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterFingerprint_good(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBFingerprint > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBFingerprint > *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBFingerprint_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator bool" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBFingerprint > const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBFingerprint > * >(argp1);
  result = (bool)((OpenBabel::PluginIter<OpenBabel::OBFingerprint > const *)arg1)->operator bool();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterFingerprint_deref(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBFingerprint > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBFingerprint > *) 0 ;
  OpenBabel::OBFingerprint *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBFingerprint_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator ->" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBFingerprint > const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBFingerprint > * >(argp1);
  result = (OpenBabel::OBFingerprint *)((OpenBabel::PluginIter<OpenBabel::OBFingerprint > const *)arg1)->operator ->();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBFingerprint, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_pluginiterFingerprint_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_pluginiterFingerprint_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBFingerprint_t);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_pluginiterFingerprint(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBFingerprint > *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::PluginIter<OpenBabel::OBFingerprint > *)new OpenBabel::PluginIter<OpenBabel::OBFingerprint >();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_PluginIter_Sl_OpenBabel_OBFingerprint_Sg_(OpenBabel::PluginIter<OpenBabel::OBFingerprint > *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_pluginiterFingerprint_iter(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBFingerprint > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBFingerprint > *) 0 ;
  OpenBabel::PluginIter<OpenBabel::OBFingerprint > *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBFingerprint_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Iter" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBFingerprint > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBFingerprint > * >(argp1);
  {
    OpenBabel::PluginIter<OpenBabel::OBFingerprint > &_result_ref = (*arg1)->Iter();
    result = (OpenBabel::PluginIter<OpenBabel::OBFingerprint > *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBFingerprint_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterFingerprint_set_bit(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBFingerprint > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBFingerprint > *) 0 ;
  std::vector<unsigned int > *arg2 = 0 ;
  unsigned int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBFingerprint_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetBit" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBFingerprint > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBFingerprint > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTunsigned_int_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetBit" "', argument " "2"" of type '" "std::vector<unsigned int > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetBit" "', argument " "2"" of type '" "std::vector<unsigned int > &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<unsigned int > * >(argp2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SetBit" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  (*arg1)->SetBit(*arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterFingerprint_fold(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBFingerprint > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBFingerprint > *) 0 ;
  std::vector<unsigned int > *arg2 = 0 ;
  unsigned int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBFingerprint_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Fold" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBFingerprint > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBFingerprint > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTunsigned_int_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Fold" "', argument " "2"" of type '" "std::vector<unsigned int > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Fold" "', argument " "2"" of type '" "std::vector<unsigned int > &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<unsigned int > * >(argp2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Fold" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  (*arg1)->Fold(*arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterFingerprint_get_fingerprint__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBFingerprint > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBFingerprint > *) 0 ;
  OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  std::vector<unsigned int > *arg3 = 0 ;
  int arg4 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBFingerprint_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetFingerprint" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBFingerprint > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBFingerprint > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetFingerprint" "', argument " "2"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_std__vectorTunsigned_int_t,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "GetFingerprint" "', argument " "3"" of type '" "std::vector<unsigned int > &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GetFingerprint" "', argument " "3"" of type '" "std::vector<unsigned int > &""'"); 
  }
  arg3 = reinterpret_cast< std::vector<unsigned int > * >(argp3);
  ecode4 = SWIG_AsVal_int(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "GetFingerprint" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = static_cast< int >(val4);
  result = (bool)(*arg1)->GetFingerprint(arg2,*arg3,arg4);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterFingerprint_get_fingerprint__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBFingerprint > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBFingerprint > *) 0 ;
  OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  std::vector<unsigned int > *arg3 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBFingerprint_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetFingerprint" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBFingerprint > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBFingerprint > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetFingerprint" "', argument " "2"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_std__vectorTunsigned_int_t,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "GetFingerprint" "', argument " "3"" of type '" "std::vector<unsigned int > &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GetFingerprint" "', argument " "3"" of type '" "std::vector<unsigned int > &""'"); 
  }
  arg3 = reinterpret_cast< std::vector<unsigned int > * >(argp3);
  result = (bool)(*arg1)->GetFingerprint(arg2,*arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_pluginiterFingerprint_get_fingerprint(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBFingerprint_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBBase, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_std__vectorTunsigned_int_t, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_pluginiterFingerprint_get_fingerprint__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBFingerprint_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBBase, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_std__vectorTunsigned_int_t, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_pluginiterFingerprint_get_fingerprint__SWIG_0(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'pluginiterFingerprint_get_fingerprint'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterFingerprint_description(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBFingerprint > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBFingerprint > *) 0 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBFingerprint_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Description" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBFingerprint > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBFingerprint > * >(argp1);
  result = (*arg1)->Description();
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterFingerprint_flags(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBFingerprint > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBFingerprint > *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBFingerprint_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Flags" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBFingerprint > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBFingerprint > * >(argp1);
  result = (unsigned int)(*arg1)->Flags();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterFingerprint_tanimoto__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBFingerprint > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBFingerprint > *) 0 ;
  std::vector<unsigned int > *arg2 = 0 ;
  std::vector<unsigned int > *arg3 = 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector<unsigned int > temp2 ;
  std::vector<unsigned int > temp3 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBFingerprint_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tanimoto" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBFingerprint > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBFingerprint > * >(argp1);
  {
    if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
      unsigned int size = RARRAY_LEN(argv[0]);
      temp2 = std::vector<unsigned int >(size);
      arg2 = &temp2;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(argv[0])[i];
        if (FIXNUM_P(o))
        temp2[i] = (unsigned int)(FIX2INT(o));
        else
        rb_raise(rb_eTypeError,
          "wrong argument type"
          " (expected vector<""unsigned int" ">)");
      }
    } else {
      SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_std__vectorTunsigned_int_t, 1);
    }
  }
  {
    if (rb_obj_is_kind_of(argv[1],rb_cArray)) {
      unsigned int size = RARRAY_LEN(argv[1]);
      temp3 = std::vector<unsigned int >(size);
      arg3 = &temp3;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(argv[1])[i];
        if (FIXNUM_P(o))
        temp3[i] = (unsigned int)(FIX2INT(o));
        else
        rb_raise(rb_eTypeError,
          "wrong argument type"
          " (expected vector<""unsigned int" ">)");
      }
    } else {
      SWIG_ConvertPtr(argv[1], (void **) &arg3, SWIGTYPE_p_std__vectorTunsigned_int_t, 1);
    }
  }
  result = (double)(*arg1)->Tanimoto((std::vector<unsigned int > const &)*arg2,(std::vector<unsigned int > const &)*arg3);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterFingerprint_tanimoto__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBFingerprint > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBFingerprint > *) 0 ;
  std::vector<unsigned int > *arg2 = 0 ;
  unsigned int *arg3 = (unsigned int *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector<unsigned int > temp2 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBFingerprint_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tanimoto" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBFingerprint > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBFingerprint > * >(argp1);
  {
    if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
      unsigned int size = RARRAY_LEN(argv[0]);
      temp2 = std::vector<unsigned int >(size);
      arg2 = &temp2;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(argv[0])[i];
        if (FIXNUM_P(o))
        temp2[i] = (unsigned int)(FIX2INT(o));
        else
        rb_raise(rb_eTypeError,
          "wrong argument type"
          " (expected vector<""unsigned int" ">)");
      }
    } else {
      SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_std__vectorTunsigned_int_t, 1);
    }
  }
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_unsigned_int, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Tanimoto" "', argument " "3"" of type '" "unsigned int const *""'"); 
  }
  arg3 = reinterpret_cast< unsigned int * >(argp3);
  result = (double)(*arg1)->Tanimoto((std::vector<unsigned int > const &)*arg2,(unsigned int const *)arg3);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_pluginiterFingerprint_tanimoto(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBFingerprint_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        /* native sequence? */
        if (rb_obj_is_kind_of(argv[1],rb_cArray)) {
          unsigned int size = RARRAY_LEN(argv[1]);
          if (size == 0) {
            /* an empty sequence can be of any type */
            _v = 1;
          } else {
            /* check the first element only */
            VALUE o = RARRAY_PTR(argv[1])[0];
            if (FIXNUM_P(o))
            _v = 1;
            else
            _v = 0;
          }
        } else {
          /* wrapped vector? */
          std::vector<unsigned int >* v;
          if (SWIG_ConvertPtr(argv[1],(void **) &v, 
              SWIGTYPE_p_std__vectorTunsigned_int_t,0) != -1)
          _v = 1;
          else
          _v = 0;
        }
      }
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_unsigned_int, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_pluginiterFingerprint_tanimoto__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBFingerprint_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        /* native sequence? */
        if (rb_obj_is_kind_of(argv[1],rb_cArray)) {
          unsigned int size = RARRAY_LEN(argv[1]);
          if (size == 0) {
            /* an empty sequence can be of any type */
            _v = 1;
          } else {
            /* check the first element only */
            VALUE o = RARRAY_PTR(argv[1])[0];
            if (FIXNUM_P(o))
            _v = 1;
            else
            _v = 0;
          }
        } else {
          /* wrapped vector? */
          std::vector<unsigned int >* v;
          if (SWIG_ConvertPtr(argv[1],(void **) &v, 
              SWIGTYPE_p_std__vectorTunsigned_int_t,0) != -1)
          _v = 1;
          else
          _v = 0;
        }
      }
      if (_v) {
        {
          /* native sequence? */
          if (rb_obj_is_kind_of(argv[2],rb_cArray)) {
            unsigned int size = RARRAY_LEN(argv[2]);
            if (size == 0) {
              /* an empty sequence can be of any type */
              _v = 1;
            } else {
              /* check the first element only */
              VALUE o = RARRAY_PTR(argv[2])[0];
              if (FIXNUM_P(o))
              _v = 1;
              else
              _v = 0;
            }
          } else {
            /* wrapped vector? */
            std::vector<unsigned int >* v;
            if (SWIG_ConvertPtr(argv[2],(void **) &v, 
                SWIGTYPE_p_std__vectorTunsigned_int_t,0) != -1)
            _v = 1;
            else
            _v = 0;
          }
        }
        if (_v) {
          return _wrap_pluginiterFingerprint_tanimoto__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'pluginiterFingerprint_tanimoto'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterFingerprint_getbitsperint(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBFingerprint > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBFingerprint > *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBFingerprint_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Getbitsperint" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBFingerprint > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBFingerprint > * >(argp1);
  result = (unsigned int)(*arg1)->Getbitsperint();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterFingerprint_find_fingerprint(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBFingerprint > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBFingerprint > *) 0 ;
  std::string *arg2 = 0 ;
  OpenBabel::OBFingerprint *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBFingerprint_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FindFingerprint" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBFingerprint > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBFingerprint > * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "FindFingerprint" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "FindFingerprint" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (OpenBabel::OBFingerprint *)(*arg1)->FindFingerprint((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBFingerprint, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


swig_class cPluginiterForceField;

SWIGINTERN VALUE
_wrap_pluginiterForceField_register(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  OpenBabel::OBForceField *arg2 = (OpenBabel::OBForceField *) 0 ;
  std::string arg3 ;
  bool arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Register" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Register" "', argument " "2"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBForceField * >(argp2);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "Register" "', argument " "3"" of type '" "std::string const""'"); 
    }
    arg3 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  ecode4 = SWIG_AsVal_bool(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Register" "', argument " "4"" of type '" "bool""'");
  } 
  arg4 = static_cast< bool >(val4);
  (arg1)->Register(arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_find_type(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  std::string *arg2 = 0 ;
  OpenBabel::OBForceField *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FindType" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "FindType" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "FindType" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (OpenBabel::OBForceField *)(arg1)->FindType((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_find_default_type(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  OpenBabel::OBForceField *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FindDefaultType" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  result = (OpenBabel::OBForceField *)((OpenBabel::PluginIter<OpenBabel::OBForceField > const *)arg1)->FindDefaultType();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_id(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ID" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  result = ((OpenBabel::PluginIter<OpenBabel::OBForceField > const *)arg1)->ID();
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_to_start(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ToStart" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  (arg1)->ToStart();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_inc(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  OpenBabel::PluginIter<OpenBabel::OBForceField > *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator ++" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  {
    OpenBabel::PluginIter<OpenBabel::OBForceField > &_result_ref = (arg1)->operator ++();
    result = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_good(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator bool" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  result = (bool)((OpenBabel::PluginIter<OpenBabel::OBForceField > const *)arg1)->operator bool();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_deref(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  OpenBabel::OBForceField *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator ->" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  result = (OpenBabel::OBForceField *)((OpenBabel::PluginIter<OpenBabel::OBForceField > const *)arg1)->operator ->();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_pluginiterForceField_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_pluginiterForceField_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_pluginiterForceField(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::PluginIter<OpenBabel::OBForceField > *)new OpenBabel::PluginIter<OpenBabel::OBForceField >();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_PluginIter_Sl_OpenBabel_OBForceField_Sg_(OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_pluginiterForceField_iter(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  OpenBabel::PluginIter<OpenBabel::OBForceField > *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Iter" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  {
    OpenBabel::PluginIter<OpenBabel::OBForceField > &_result_ref = (*arg1)->Iter();
    result = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_find_force_field__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  std::string *arg2 = 0 ;
  OpenBabel::OBForceField *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FindForceField" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "FindForceField" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "FindForceField" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (OpenBabel::OBForceField *)(*arg1)->FindForceField((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_find_force_field__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  char *arg2 = (char *) 0 ;
  OpenBabel::OBForceField *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FindForceField" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "FindForceField" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (OpenBabel::OBForceField *)(*arg1)->FindForceField((char const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_pluginiterForceField_find_force_field(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_pluginiterForceField_find_force_field__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_pluginiterForceField_find_force_field__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'pluginiterForceField_find_force_field'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_get_unit(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetUnit" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  result = (*arg1)->GetUnit();
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_setup(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  OpenBabel::OBMol *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Setup" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBMol,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Setup" "', argument " "2"" of type '" "OpenBabel::OBMol &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Setup" "', argument " "2"" of type '" "OpenBabel::OBMol &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2);
  result = (bool)(*arg1)->Setup(*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_update_coordinates(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  OpenBabel::OBMol *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UpdateCoordinates" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBMol,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "UpdateCoordinates" "', argument " "2"" of type '" "OpenBabel::OBMol &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "UpdateCoordinates" "', argument " "2"" of type '" "OpenBabel::OBMol &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2);
  result = (bool)(*arg1)->UpdateCoordinates(*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_update_conformers(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  OpenBabel::OBMol *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UpdateConformers" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBMol,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "UpdateConformers" "', argument " "2"" of type '" "OpenBabel::OBMol &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "UpdateConformers" "', argument " "2"" of type '" "OpenBabel::OBMol &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2);
  result = (bool)(*arg1)->UpdateConformers(*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_obfflog__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  std::string arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OBFFLog" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "OBFFLog" "', argument " "2"" of type '" "std::string""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  (*arg1)->OBFFLog(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_obfflog__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OBFFLog" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OBFFLog" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  (*arg1)->OBFFLog((char const *)arg2);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_pluginiterForceField_obfflog(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_pluginiterForceField_obfflog__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_pluginiterForceField_obfflog__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'pluginiterForceField_obfflog'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_energy__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  bool arg2 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Energy" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Energy" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (double)(*arg1)->Energy(arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_energy__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Energy" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  result = (double)(*arg1)->Energy();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_pluginiterForceField_energy(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_pluginiterForceField_energy__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_pluginiterForceField_energy__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'pluginiterForceField_energy'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_e_bond__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  bool arg2 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "E_Bond" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "E_Bond" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (double)(*arg1)->E_Bond(arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_e_bond__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "E_Bond" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  result = (double)(*arg1)->E_Bond();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_pluginiterForceField_e_bond(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_pluginiterForceField_e_bond__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_pluginiterForceField_e_bond__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'pluginiterForceField_e_bond'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_e_angle__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  bool arg2 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "E_Angle" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "E_Angle" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (double)(*arg1)->E_Angle(arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_e_angle__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "E_Angle" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  result = (double)(*arg1)->E_Angle();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_pluginiterForceField_e_angle(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_pluginiterForceField_e_angle__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_pluginiterForceField_e_angle__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'pluginiterForceField_e_angle'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_e_str_bnd__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  bool arg2 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "E_StrBnd" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "E_StrBnd" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (double)(*arg1)->E_StrBnd(arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_e_str_bnd__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "E_StrBnd" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  result = (double)(*arg1)->E_StrBnd();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_pluginiterForceField_e_str_bnd(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_pluginiterForceField_e_str_bnd__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_pluginiterForceField_e_str_bnd__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'pluginiterForceField_e_str_bnd'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_e_torsion__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  bool arg2 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "E_Torsion" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "E_Torsion" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (double)(*arg1)->E_Torsion(arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_e_torsion__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "E_Torsion" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  result = (double)(*arg1)->E_Torsion();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_pluginiterForceField_e_torsion(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_pluginiterForceField_e_torsion__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_pluginiterForceField_e_torsion__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'pluginiterForceField_e_torsion'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_e_oop__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  bool arg2 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "E_OOP" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "E_OOP" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (double)(*arg1)->E_OOP(arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_e_oop__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "E_OOP" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  result = (double)(*arg1)->E_OOP();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_pluginiterForceField_e_oop(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_pluginiterForceField_e_oop__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_pluginiterForceField_e_oop__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'pluginiterForceField_e_oop'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_e_vdw__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  bool arg2 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "E_VDW" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "E_VDW" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (double)(*arg1)->E_VDW(arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_e_vdw__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "E_VDW" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  result = (double)(*arg1)->E_VDW();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_pluginiterForceField_e_vdw(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_pluginiterForceField_e_vdw__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_pluginiterForceField_e_vdw__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'pluginiterForceField_e_vdw'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_e_electrostatic__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  bool arg2 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "E_Electrostatic" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "E_Electrostatic" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (double)(*arg1)->E_Electrostatic(arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_e_electrostatic__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "E_Electrostatic" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  result = (double)(*arg1)->E_Electrostatic();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_pluginiterForceField_e_electrostatic(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_pluginiterForceField_e_electrostatic__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_pluginiterForceField_e_electrostatic__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'pluginiterForceField_e_electrostatic'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_set_log_file(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  std::ostream *arg2 = (std::ostream *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetLogFile" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_std__ostream, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetLogFile" "', argument " "2"" of type '" "std::ostream *""'"); 
  }
  arg2 = reinterpret_cast< std::ostream * >(argp2);
  result = (bool)(*arg1)->SetLogFile(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_set_log_level(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetLogLevel" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetLogLevel" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (bool)(*arg1)->SetLogLevel(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_get_log_level(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetLogLevel" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  result = (int)(*arg1)->GetLogLevel();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_systematic_rotor_search(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SystematicRotorSearch" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  (*arg1)->SystematicRotorSearch();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_line_search(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::vector3 *arg3 = 0 ;
  OpenBabel::vector3 result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LineSearch" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "LineSearch" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "LineSearch" "', argument " "3"" of type '" "OpenBabel::vector3 &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "LineSearch" "', argument " "3"" of type '" "OpenBabel::vector3 &""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::vector3 * >(argp3);
  result = (*arg1)->LineSearch(arg2,*arg3);
  vresult = SWIG_NewPointerObj((new OpenBabel::vector3(static_cast< const OpenBabel::vector3& >(result))), SWIGTYPE_p_OpenBabel__vector3, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_steepest_descent__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  int arg2 ;
  double arg3 ;
  int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SteepestDescent" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SteepestDescent" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_double(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SteepestDescent" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  ecode4 = SWIG_AsVal_int(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "SteepestDescent" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = static_cast< int >(val4);
  (*arg1)->SteepestDescent(arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_steepest_descent__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  int arg2 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SteepestDescent" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SteepestDescent" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_double(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SteepestDescent" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  (*arg1)->SteepestDescent(arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_steepest_descent__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SteepestDescent" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SteepestDescent" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (*arg1)->SteepestDescent(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_pluginiterForceField_steepest_descent(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_pluginiterForceField_steepest_descent__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_pluginiterForceField_steepest_descent__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_pluginiterForceField_steepest_descent__SWIG_0(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'pluginiterForceField_steepest_descent'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_steepest_descent_initialize__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  int arg2 ;
  double arg3 ;
  int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SteepestDescentInitialize" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SteepestDescentInitialize" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_double(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SteepestDescentInitialize" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  ecode4 = SWIG_AsVal_int(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "SteepestDescentInitialize" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = static_cast< int >(val4);
  (*arg1)->SteepestDescentInitialize(arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_steepest_descent_initialize__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  int arg2 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SteepestDescentInitialize" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SteepestDescentInitialize" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_double(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SteepestDescentInitialize" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  (*arg1)->SteepestDescentInitialize(arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_steepest_descent_initialize__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SteepestDescentInitialize" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SteepestDescentInitialize" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (*arg1)->SteepestDescentInitialize(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_steepest_descent_initialize__SWIG_3(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SteepestDescentInitialize" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  (*arg1)->SteepestDescentInitialize();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_pluginiterForceField_steepest_descent_initialize(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_pluginiterForceField_steepest_descent_initialize__SWIG_3(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_pluginiterForceField_steepest_descent_initialize__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_pluginiterForceField_steepest_descent_initialize__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_pluginiterForceField_steepest_descent_initialize__SWIG_0(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'pluginiterForceField_steepest_descent_initialize'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_steepest_descent_take_nsteps(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SteepestDescentTakeNSteps" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SteepestDescentTakeNSteps" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (bool)(*arg1)->SteepestDescentTakeNSteps(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_conjugate_gradients__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  int arg2 ;
  double arg3 ;
  int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConjugateGradients" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ConjugateGradients" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_double(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "ConjugateGradients" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  ecode4 = SWIG_AsVal_int(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "ConjugateGradients" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = static_cast< int >(val4);
  (*arg1)->ConjugateGradients(arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_conjugate_gradients__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  int arg2 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConjugateGradients" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ConjugateGradients" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_double(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "ConjugateGradients" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  (*arg1)->ConjugateGradients(arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_conjugate_gradients__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConjugateGradients" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ConjugateGradients" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (*arg1)->ConjugateGradients(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_pluginiterForceField_conjugate_gradients(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_pluginiterForceField_conjugate_gradients__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_pluginiterForceField_conjugate_gradients__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_pluginiterForceField_conjugate_gradients__SWIG_0(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'pluginiterForceField_conjugate_gradients'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_conjugate_gradients_initialize__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  int arg2 ;
  double arg3 ;
  int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConjugateGradientsInitialize" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ConjugateGradientsInitialize" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_double(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "ConjugateGradientsInitialize" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  ecode4 = SWIG_AsVal_int(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "ConjugateGradientsInitialize" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = static_cast< int >(val4);
  (*arg1)->ConjugateGradientsInitialize(arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_conjugate_gradients_initialize__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  int arg2 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConjugateGradientsInitialize" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ConjugateGradientsInitialize" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_double(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "ConjugateGradientsInitialize" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  (*arg1)->ConjugateGradientsInitialize(arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_conjugate_gradients_initialize__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConjugateGradientsInitialize" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ConjugateGradientsInitialize" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (*arg1)->ConjugateGradientsInitialize(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_conjugate_gradients_initialize__SWIG_3(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConjugateGradientsInitialize" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  (*arg1)->ConjugateGradientsInitialize();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_pluginiterForceField_conjugate_gradients_initialize(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_pluginiterForceField_conjugate_gradients_initialize__SWIG_3(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_pluginiterForceField_conjugate_gradients_initialize__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_pluginiterForceField_conjugate_gradients_initialize__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_pluginiterForceField_conjugate_gradients_initialize__SWIG_0(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'pluginiterForceField_conjugate_gradients_initialize'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_conjugate_gradients_take_nsteps(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConjugateGradientsTakeNSteps" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ConjugateGradientsTakeNSteps" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (bool)(*arg1)->ConjugateGradientsTakeNSteps(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_validate(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Validate" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  result = (bool)(*arg1)->Validate();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_validate_gradients(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ValidateGradients" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  result = (bool)(*arg1)->ValidateGradients();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_validate_gradient_error(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  OpenBabel::vector3 *arg3 = 0 ;
  OpenBabel::vector3 result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ValidateGradientError" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ValidateGradientError" "', argument " "2"" of type '" "OpenBabel::vector3 &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ValidateGradientError" "', argument " "2"" of type '" "OpenBabel::vector3 &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "ValidateGradientError" "', argument " "3"" of type '" "OpenBabel::vector3 &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ValidateGradientError" "', argument " "3"" of type '" "OpenBabel::vector3 &""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::vector3 * >(argp3);
  result = (*arg1)->ValidateGradientError(*arg2,*arg3);
  vresult = SWIG_NewPointerObj((new OpenBabel::vector3(static_cast< const OpenBabel::vector3& >(result))), SWIGTYPE_p_OpenBabel__vector3, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_vector_length_derivative(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  OpenBabel::vector3 *arg3 = 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VectorLengthDerivative" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VectorLengthDerivative" "', argument " "2"" of type '" "OpenBabel::vector3 &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VectorLengthDerivative" "', argument " "2"" of type '" "OpenBabel::vector3 &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "VectorLengthDerivative" "', argument " "3"" of type '" "OpenBabel::vector3 &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VectorLengthDerivative" "', argument " "3"" of type '" "OpenBabel::vector3 &""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::vector3 * >(argp3);
  result = (double)(*arg1)->VectorLengthDerivative(*arg2,*arg3);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_vector_angle_derivative(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  OpenBabel::vector3 *arg3 = 0 ;
  OpenBabel::vector3 *arg4 = 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VectorAngleDerivative" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VectorAngleDerivative" "', argument " "2"" of type '" "OpenBabel::vector3 &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VectorAngleDerivative" "', argument " "2"" of type '" "OpenBabel::vector3 &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "VectorAngleDerivative" "', argument " "3"" of type '" "OpenBabel::vector3 &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VectorAngleDerivative" "', argument " "3"" of type '" "OpenBabel::vector3 &""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::vector3 * >(argp3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "VectorAngleDerivative" "', argument " "4"" of type '" "OpenBabel::vector3 &""'"); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VectorAngleDerivative" "', argument " "4"" of type '" "OpenBabel::vector3 &""'"); 
  }
  arg4 = reinterpret_cast< OpenBabel::vector3 * >(argp4);
  result = (double)(*arg1)->VectorAngleDerivative(*arg2,*arg3,*arg4);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_vector_torsion_derivative(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  OpenBabel::vector3 *arg3 = 0 ;
  OpenBabel::vector3 *arg4 = 0 ;
  OpenBabel::vector3 *arg5 = 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VectorTorsionDerivative" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VectorTorsionDerivative" "', argument " "2"" of type '" "OpenBabel::vector3 &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VectorTorsionDerivative" "', argument " "2"" of type '" "OpenBabel::vector3 &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "VectorTorsionDerivative" "', argument " "3"" of type '" "OpenBabel::vector3 &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VectorTorsionDerivative" "', argument " "3"" of type '" "OpenBabel::vector3 &""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::vector3 * >(argp3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "VectorTorsionDerivative" "', argument " "4"" of type '" "OpenBabel::vector3 &""'"); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VectorTorsionDerivative" "', argument " "4"" of type '" "OpenBabel::vector3 &""'"); 
  }
  arg4 = reinterpret_cast< OpenBabel::vector3 * >(argp4);
  res5 = SWIG_ConvertPtr(argv[3], &argp5, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "VectorTorsionDerivative" "', argument " "5"" of type '" "OpenBabel::vector3 &""'"); 
  }
  if (!argp5) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VectorTorsionDerivative" "', argument " "5"" of type '" "OpenBabel::vector3 &""'"); 
  }
  arg5 = reinterpret_cast< OpenBabel::vector3 * >(argp5);
  result = (double)(*arg1)->VectorTorsionDerivative(*arg2,*arg3,*arg4,*arg5);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_pluginiterForceField_kludge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *arg1 = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "kludge" "', argument " "1"" of type '" "OpenBabel::PluginIter<OpenBabel::OBForceField > *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::PluginIter<OpenBabel::OBForceField > * >(argp1);
  (*arg1)->kludge();
  return Qnil;
fail:
  return Qnil;
}


swig_class cOBError;

SWIGINTERN VALUE
_wrap_new_OBError__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  std::string *arg4 = 0 ;
  std::string *arg5 = 0 ;
  OpenBabel::obMessageLevel arg6 ;
  OpenBabel::OBError *result = 0 ;
  int res1 = SWIG_OLDOBJ ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  int res4 = SWIG_OLDOBJ ;
  int res5 = SWIG_OLDOBJ ;
  int val6 ;
  int ecode6 = 0 ;
  
  if ((argc < 6) || (argc > 6)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 6)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBError" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBError" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::OBError" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBError" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(argv[2], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "OpenBabel::OBError" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBError" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res4 = SWIG_AsPtr_std_string(argv[3], &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "OpenBabel::OBError" "', argument " "4"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBError" "', argument " "4"" of type '" "std::string const &""'"); 
    }
    arg4 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res5 = SWIG_AsPtr_std_string(argv[4], &ptr);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "OpenBabel::OBError" "', argument " "5"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBError" "', argument " "5"" of type '" "std::string const &""'"); 
    }
    arg5 = ptr;
  }
  ecode6 = SWIG_AsVal_int(argv[5], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "OpenBabel::OBError" "', argument " "6"" of type '" "OpenBabel::obMessageLevel""'");
  } 
  arg6 = static_cast< OpenBabel::obMessageLevel >(val6);
  result = (OpenBabel::OBError *)new OpenBabel::OBError((std::string const &)*arg1,(std::string const &)*arg2,(std::string const &)*arg3,(std::string const &)*arg4,(std::string const &)*arg5,arg6);DATA_PTR(self) = result;
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_OBError__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  std::string *arg4 = 0 ;
  std::string *arg5 = 0 ;
  OpenBabel::OBError *result = 0 ;
  int res1 = SWIG_OLDOBJ ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  int res4 = SWIG_OLDOBJ ;
  int res5 = SWIG_OLDOBJ ;
  
  if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBError" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBError" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::OBError" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBError" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(argv[2], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "OpenBabel::OBError" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBError" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res4 = SWIG_AsPtr_std_string(argv[3], &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "OpenBabel::OBError" "', argument " "4"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBError" "', argument " "4"" of type '" "std::string const &""'"); 
    }
    arg4 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res5 = SWIG_AsPtr_std_string(argv[4], &ptr);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "OpenBabel::OBError" "', argument " "5"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBError" "', argument " "5"" of type '" "std::string const &""'"); 
    }
    arg5 = ptr;
  }
  result = (OpenBabel::OBError *)new OpenBabel::OBError((std::string const &)*arg1,(std::string const &)*arg2,(std::string const &)*arg3,(std::string const &)*arg4,(std::string const &)*arg5);DATA_PTR(self) = result;
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_OBError__SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  std::string *arg4 = 0 ;
  OpenBabel::OBError *result = 0 ;
  int res1 = SWIG_OLDOBJ ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  int res4 = SWIG_OLDOBJ ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBError" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBError" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::OBError" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBError" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(argv[2], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "OpenBabel::OBError" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBError" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res4 = SWIG_AsPtr_std_string(argv[3], &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "OpenBabel::OBError" "', argument " "4"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBError" "', argument " "4"" of type '" "std::string const &""'"); 
    }
    arg4 = ptr;
  }
  result = (OpenBabel::OBError *)new OpenBabel::OBError((std::string const &)*arg1,(std::string const &)*arg2,(std::string const &)*arg3,(std::string const &)*arg4);DATA_PTR(self) = result;
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_OBError__SWIG_3(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  OpenBabel::OBError *result = 0 ;
  int res1 = SWIG_OLDOBJ ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBError" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBError" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::OBError" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBError" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(argv[2], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "OpenBabel::OBError" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBError" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  result = (OpenBabel::OBError *)new OpenBabel::OBError((std::string const &)*arg1,(std::string const &)*arg2,(std::string const &)*arg3);DATA_PTR(self) = result;
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_OBError__SWIG_4(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  std::string *arg2 = 0 ;
  OpenBabel::OBError *result = 0 ;
  int res1 = SWIG_OLDOBJ ;
  int res2 = SWIG_OLDOBJ ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBError" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBError" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::OBError" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBError" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (OpenBabel::OBError *)new OpenBabel::OBError((std::string const &)*arg1,(std::string const &)*arg2);DATA_PTR(self) = result;
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_OBError__SWIG_5(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  OpenBabel::OBError *result = 0 ;
  int res1 = SWIG_OLDOBJ ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBError" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBError" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  result = (OpenBabel::OBError *)new OpenBabel::OBError((std::string const &)*arg1);DATA_PTR(self) = result;
  
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBError_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBError_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBError);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBError__SWIG_6(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBError *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBError *)new OpenBabel::OBError();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_OBError(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[6];
  int ii;
  
  argc = nargs;
  if (argc > 6) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_OBError__SWIG_6(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBError__SWIG_5(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_OBError__SWIG_4(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_new_OBError__SWIG_3(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          int res = SWIG_AsPtr_std_string(argv[3], (std::string**)(0));
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_new_OBError__SWIG_2(nargs, args, self);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          int res = SWIG_AsPtr_std_string(argv[3], (std::string**)(0));
          _v = SWIG_CheckState(res);
          if (_v) {
            int res = SWIG_AsPtr_std_string(argv[4], (std::string**)(0));
            _v = SWIG_CheckState(res);
            if (_v) {
              return _wrap_new_OBError__SWIG_1(nargs, args, self);
            }
          }
        }
      }
    }
  }
  if (argc == 6) {
    int _v;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          int res = SWIG_AsPtr_std_string(argv[3], (std::string**)(0));
          _v = SWIG_CheckState(res);
          if (_v) {
            int res = SWIG_AsPtr_std_string(argv[4], (std::string**)(0));
            _v = SWIG_CheckState(res);
            if (_v) {
              {
                int res = SWIG_AsVal_int(argv[5], NULL);
                _v = SWIG_CheckState(res);
              }
              if (_v) {
                return _wrap_new_OBError__SWIG_0(nargs, args, self);
              }
            }
          }
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_OBError'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBError_message(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBError *arg1 = (OpenBabel::OBError *) 0 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBError, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "message" "', argument " "1"" of type '" "OpenBabel::OBError const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBError * >(argp1);
  result = ((OpenBabel::OBError const *)arg1)->message();
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBError_get_method(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBError *arg1 = (OpenBabel::OBError *) 0 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBError, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetMethod" "', argument " "1"" of type '" "OpenBabel::OBError *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBError * >(argp1);
  result = (arg1)->GetMethod();
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBError_get_error(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBError *arg1 = (OpenBabel::OBError *) 0 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBError, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetError" "', argument " "1"" of type '" "OpenBabel::OBError *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBError * >(argp1);
  result = (arg1)->GetError();
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBError_get_explanation(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBError *arg1 = (OpenBabel::OBError *) 0 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBError, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetExplanation" "', argument " "1"" of type '" "OpenBabel::OBError *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBError * >(argp1);
  result = (arg1)->GetExplanation();
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBError_get_possible_cause(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBError *arg1 = (OpenBabel::OBError *) 0 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBError, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetPossibleCause" "', argument " "1"" of type '" "OpenBabel::OBError *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBError * >(argp1);
  result = (arg1)->GetPossibleCause();
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBError_get_suggested_remedy(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBError *arg1 = (OpenBabel::OBError *) 0 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBError, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetSuggestedRemedy" "', argument " "1"" of type '" "OpenBabel::OBError *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBError * >(argp1);
  result = (arg1)->GetSuggestedRemedy();
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBError_get_level(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBError *arg1 = (OpenBabel::OBError *) 0 ;
  OpenBabel::obMessageLevel result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBError, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetLevel" "', argument " "1"" of type '" "OpenBabel::OBError *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBError * >(argp1);
  result = (OpenBabel::obMessageLevel)(arg1)->GetLevel();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBError(OpenBabel::OBError *arg1) {
    delete arg1;
}

swig_class cOBMessageHandler;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBMessageHandler_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBMessageHandler_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBMessageHandler);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBMessageHandler(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMessageHandler *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBMessageHandler *)new OpenBabel::OBMessageHandler();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBMessageHandler(OpenBabel::OBMessageHandler *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_OBMessageHandler_throw_error__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMessageHandler *arg1 = (OpenBabel::OBMessageHandler *) 0 ;
  OpenBabel::OBError arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMessageHandler, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ThrowError" "', argument " "1"" of type '" "OpenBabel::OBMessageHandler *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMessageHandler * >(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBError,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ThrowError" "', argument " "2"" of type '" "OpenBabel::OBError""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ThrowError" "', argument " "2"" of type '" "OpenBabel::OBError""'");
    } else {
      arg2 = *(reinterpret_cast< OpenBabel::OBError * >(argp2));
    }
  }
  (arg1)->ThrowError(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMessageHandler_throw_error__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMessageHandler *arg1 = (OpenBabel::OBMessageHandler *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  OpenBabel::obMessageLevel arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  int val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMessageHandler, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ThrowError" "', argument " "1"" of type '" "OpenBabel::OBMessageHandler *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMessageHandler * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ThrowError" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ThrowError" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "ThrowError" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ThrowError" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  ecode4 = SWIG_AsVal_int(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "ThrowError" "', argument " "4"" of type '" "OpenBabel::obMessageLevel""'");
  } 
  arg4 = static_cast< OpenBabel::obMessageLevel >(val4);
  (arg1)->ThrowError((std::string const &)*arg2,(std::string const &)*arg3,arg4);
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMessageHandler_throw_error__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMessageHandler *arg1 = (OpenBabel::OBMessageHandler *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMessageHandler, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ThrowError" "', argument " "1"" of type '" "OpenBabel::OBMessageHandler *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMessageHandler * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ThrowError" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ThrowError" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "ThrowError" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ThrowError" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  (arg1)->ThrowError((std::string const &)*arg2,(std::string const &)*arg3);
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMessageHandler_throw_error(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMessageHandler, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBError, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMessageHandler_throw_error__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMessageHandler, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_OBMessageHandler_throw_error__SWIG_2(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMessageHandler, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_OBMessageHandler_throw_error__SWIG_1(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMessageHandler_throw_error'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMessageHandler_get_messages_of_level(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMessageHandler *arg1 = (OpenBabel::OBMessageHandler *) 0 ;
  OpenBabel::obMessageLevel arg2 ;
  std::vector<std::string > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMessageHandler, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetMessagesOfLevel" "', argument " "1"" of type '" "OpenBabel::OBMessageHandler *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMessageHandler * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetMessagesOfLevel" "', argument " "2"" of type '" "OpenBabel::obMessageLevel""'");
  } 
  arg2 = static_cast< OpenBabel::obMessageLevel >(val2);
  result = (arg1)->GetMessagesOfLevel(arg2);
  vresult = SWIG_NewPointerObj((new std::vector<std::string >(static_cast< const std::vector<std::string >& >(result))), SWIGTYPE_p_std__vectorTstd__string_t, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMessageHandler_start_logging(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMessageHandler *arg1 = (OpenBabel::OBMessageHandler *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMessageHandler, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StartLogging" "', argument " "1"" of type '" "OpenBabel::OBMessageHandler *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMessageHandler * >(argp1);
  (arg1)->StartLogging();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMessageHandler_stop_logging(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMessageHandler *arg1 = (OpenBabel::OBMessageHandler *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMessageHandler, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StopLogging" "', argument " "1"" of type '" "OpenBabel::OBMessageHandler *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMessageHandler * >(argp1);
  (arg1)->StopLogging();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMessageHandler_set_max_log_entries(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMessageHandler *arg1 = (OpenBabel::OBMessageHandler *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMessageHandler, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetMaxLogEntries" "', argument " "1"" of type '" "OpenBabel::OBMessageHandler *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMessageHandler * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetMaxLogEntries" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  (arg1)->SetMaxLogEntries(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMessageHandler_get_max_log_entries(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMessageHandler *arg1 = (OpenBabel::OBMessageHandler *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMessageHandler, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetMaxLogEntries" "', argument " "1"" of type '" "OpenBabel::OBMessageHandler *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMessageHandler * >(argp1);
  result = (unsigned int)(arg1)->GetMaxLogEntries();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMessageHandler_clear_log(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMessageHandler *arg1 = (OpenBabel::OBMessageHandler *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMessageHandler, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ClearLog" "', argument " "1"" of type '" "OpenBabel::OBMessageHandler *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMessageHandler * >(argp1);
  (arg1)->ClearLog();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMessageHandler_set_output_level(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMessageHandler *arg1 = (OpenBabel::OBMessageHandler *) 0 ;
  OpenBabel::obMessageLevel arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMessageHandler, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetOutputLevel" "', argument " "1"" of type '" "OpenBabel::OBMessageHandler *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMessageHandler * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetOutputLevel" "', argument " "2"" of type '" "OpenBabel::obMessageLevel""'");
  } 
  arg2 = static_cast< OpenBabel::obMessageLevel >(val2);
  (arg1)->SetOutputLevel(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMessageHandler_get_output_level(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMessageHandler *arg1 = (OpenBabel::OBMessageHandler *) 0 ;
  OpenBabel::obMessageLevel result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMessageHandler, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetOutputLevel" "', argument " "1"" of type '" "OpenBabel::OBMessageHandler *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMessageHandler * >(argp1);
  result = (OpenBabel::obMessageLevel)(arg1)->GetOutputLevel();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMessageHandler_set_output_stream(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMessageHandler *arg1 = (OpenBabel::OBMessageHandler *) 0 ;
  std::ostream *arg2 = (std::ostream *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMessageHandler, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetOutputStream" "', argument " "1"" of type '" "OpenBabel::OBMessageHandler *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMessageHandler * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_std__ostream, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetOutputStream" "', argument " "2"" of type '" "std::ostream *""'"); 
  }
  arg2 = reinterpret_cast< std::ostream * >(argp2);
  (arg1)->SetOutputStream(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMessageHandler_get_output_stream(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMessageHandler *arg1 = (OpenBabel::OBMessageHandler *) 0 ;
  std::ostream *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMessageHandler, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetOutputStream" "', argument " "1"" of type '" "OpenBabel::OBMessageHandler *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMessageHandler * >(argp1);
  result = (std::ostream *)(arg1)->GetOutputStream();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__ostream, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMessageHandler_start_error_wrap(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMessageHandler *arg1 = (OpenBabel::OBMessageHandler *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMessageHandler, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StartErrorWrap" "', argument " "1"" of type '" "OpenBabel::OBMessageHandler *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMessageHandler * >(argp1);
  result = (bool)(arg1)->StartErrorWrap();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMessageHandler_stop_error_wrap(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMessageHandler *arg1 = (OpenBabel::OBMessageHandler *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMessageHandler, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StopErrorWrap" "', argument " "1"" of type '" "OpenBabel::OBMessageHandler *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMessageHandler * >(argp1);
  result = (bool)(arg1)->StopErrorWrap();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMessageHandler_get_error_message_count(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMessageHandler *arg1 = (OpenBabel::OBMessageHandler *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMessageHandler, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetErrorMessageCount" "', argument " "1"" of type '" "OpenBabel::OBMessageHandler *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMessageHandler * >(argp1);
  result = (unsigned int)(arg1)->GetErrorMessageCount();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMessageHandler_get_warning_message_count(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMessageHandler *arg1 = (OpenBabel::OBMessageHandler *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMessageHandler, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetWarningMessageCount" "', argument " "1"" of type '" "OpenBabel::OBMessageHandler *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMessageHandler * >(argp1);
  result = (unsigned int)(arg1)->GetWarningMessageCount();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMessageHandler_get_info_message_count(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMessageHandler *arg1 = (OpenBabel::OBMessageHandler *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMessageHandler, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetInfoMessageCount" "', argument " "1"" of type '" "OpenBabel::OBMessageHandler *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMessageHandler * >(argp1);
  result = (unsigned int)(arg1)->GetInfoMessageCount();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMessageHandler_get_audit_message_count(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMessageHandler *arg1 = (OpenBabel::OBMessageHandler *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMessageHandler, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAuditMessageCount" "', argument " "1"" of type '" "OpenBabel::OBMessageHandler *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMessageHandler * >(argp1);
  result = (unsigned int)(arg1)->GetAuditMessageCount();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMessageHandler_get_debug_message_count(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMessageHandler *arg1 = (OpenBabel::OBMessageHandler *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMessageHandler, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetDebugMessageCount" "', argument " "1"" of type '" "OpenBabel::OBMessageHandler *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMessageHandler * >(argp1);
  result = (unsigned int)(arg1)->GetDebugMessageCount();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMessageHandler_get_message_summary(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMessageHandler *arg1 = (OpenBabel::OBMessageHandler *) 0 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMessageHandler, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetMessageSummary" "', argument " "1"" of type '" "OpenBabel::OBMessageHandler *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMessageHandler * >(argp1);
  result = (arg1)->GetMessageSummary();
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
obErrorLog_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_NewPointerObj(SWIG_as_voidptr(&OpenBabel::obErrorLog), SWIGTYPE_p_OpenBabel__OBMessageHandler,  0 );
  return _val;
}


SWIGINTERN VALUE
obErrorLog_set(VALUE self, VALUE _val) {
  {
    void *argp = 0;
    int res = SWIG_ConvertPtr(_val, &argp, SWIGTYPE_p_OpenBabel__OBMessageHandler,  0 );
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""OpenBabel::obErrorLog""' of type '""OpenBabel::OBMessageHandler""'");
    }
    if (!argp) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""OpenBabel::obErrorLog""' of type '""OpenBabel::OBMessageHandler""'");
    } else {
      OpenBabel::obErrorLog = *(reinterpret_cast< OpenBabel::OBMessageHandler * >(argp));
    }
  }
  return _val;
fail:
  return Qnil;
}


swig_class cObLogBuf;

SWIGINTERN void
free_OpenBabel_obLogBuf(OpenBabel::obLogBuf *arg1) {
    delete arg1;
}

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_ObLogBuf_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_ObLogBuf_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__obLogBuf);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_ObLogBuf(int argc, VALUE *argv, VALUE self) {
  OpenBabel::obLogBuf *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::obLogBuf *)new OpenBabel::obLogBuf();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


swig_class cOBFormat;

SWIGINTERN VALUE
_wrap_OBFormat_read_molecule(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFormat *arg1 = (OpenBabel::OBFormat *) 0 ;
  OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  OpenBabel::OBConversion *arg3 = (OpenBabel::OBConversion *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ReadMolecule" "', argument " "1"" of type '" "OpenBabel::OBFormat *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFormat * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ReadMolecule" "', argument " "2"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "ReadMolecule" "', argument " "3"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBConversion * >(argp3);
  result = (bool)(arg1)->ReadMolecule(arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFormat_read_chem_object(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFormat *arg1 = (OpenBabel::OBFormat *) 0 ;
  OpenBabel::OBConversion *arg2 = (OpenBabel::OBConversion *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ReadChemObject" "', argument " "1"" of type '" "OpenBabel::OBFormat *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFormat * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ReadChemObject" "', argument " "2"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBConversion * >(argp2);
  result = (bool)(arg1)->ReadChemObject(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFormat_write_molecule(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFormat *arg1 = (OpenBabel::OBFormat *) 0 ;
  OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  OpenBabel::OBConversion *arg3 = (OpenBabel::OBConversion *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "WriteMolecule" "', argument " "1"" of type '" "OpenBabel::OBFormat *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFormat * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "WriteMolecule" "', argument " "2"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "WriteMolecule" "', argument " "3"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBConversion * >(argp3);
  result = (bool)(arg1)->WriteMolecule(arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFormat_write_chem_object(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFormat *arg1 = (OpenBabel::OBFormat *) 0 ;
  OpenBabel::OBConversion *arg2 = (OpenBabel::OBConversion *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "WriteChemObject" "', argument " "1"" of type '" "OpenBabel::OBFormat *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFormat * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "WriteChemObject" "', argument " "2"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBConversion * >(argp2);
  result = (bool)(arg1)->WriteChemObject(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFormat_description(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFormat *arg1 = (OpenBabel::OBFormat *) 0 ;
  char *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Description" "', argument " "1"" of type '" "OpenBabel::OBFormat *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFormat * >(argp1);
  result = (char *)(arg1)->Description();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFormat_target_class_description(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFormat *arg1 = (OpenBabel::OBFormat *) 0 ;
  char *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TargetClassDescription" "', argument " "1"" of type '" "OpenBabel::OBFormat *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFormat * >(argp1);
  result = (char *)(arg1)->TargetClassDescription();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFormat_get_type(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFormat *arg1 = (OpenBabel::OBFormat *) 0 ;
  std::type_info *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetType" "', argument " "1"" of type '" "OpenBabel::OBFormat *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFormat * >(argp1);
  {
    std::type_info const &_result_ref = (arg1)->GetType();
    result = (std::type_info *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__type_info, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFormat_specification_url(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFormat *arg1 = (OpenBabel::OBFormat *) 0 ;
  char *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpecificationURL" "', argument " "1"" of type '" "OpenBabel::OBFormat *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFormat * >(argp1);
  result = (char *)(arg1)->SpecificationURL();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFormat_get_mimetype(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFormat *arg1 = (OpenBabel::OBFormat *) 0 ;
  char *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetMIMEType" "', argument " "1"" of type '" "OpenBabel::OBFormat *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFormat * >(argp1);
  result = (char *)(arg1)->GetMIMEType();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFormat_flags(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFormat *arg1 = (OpenBabel::OBFormat *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Flags" "', argument " "1"" of type '" "OpenBabel::OBFormat *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFormat * >(argp1);
  result = (unsigned int)(arg1)->Flags();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFormat_skip_objects(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFormat *arg1 = (OpenBabel::OBFormat *) 0 ;
  int arg2 ;
  OpenBabel::OBConversion *arg3 = (OpenBabel::OBConversion *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SkipObjects" "', argument " "1"" of type '" "OpenBabel::OBFormat *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFormat * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SkipObjects" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SkipObjects" "', argument " "3"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBConversion * >(argp3);
  result = (int)(arg1)->SkipObjects(arg2,arg3);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFormat_make_new_instance(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFormat *arg1 = (OpenBabel::OBFormat *) 0 ;
  OpenBabel::OBFormat *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MakeNewInstance" "', argument " "1"" of type '" "OpenBabel::OBFormat *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFormat * >(argp1);
  result = (OpenBabel::OBFormat *)(arg1)->MakeNewInstance();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBFormat(OpenBabel::OBFormat *arg1) {
    delete arg1;
}

swig_class cCharPtrLess;

SWIGINTERN VALUE
_wrap_CharPtrLess___call__(int argc, VALUE *argv, VALUE self) {
  OpenBabel::CharPtrLess *arg1 = (OpenBabel::CharPtrLess *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__CharPtrLess, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator ()" "', argument " "1"" of type '" "OpenBabel::CharPtrLess const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::CharPtrLess * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "operator ()" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[1], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "operator ()" "', argument " "3"" of type '" "char const *""'");
  }
  arg3 = reinterpret_cast< char * >(buf3);
  result = (bool)((OpenBabel::CharPtrLess const *)arg1)->operator ()((char const *)arg2,(char const *)arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_CharPtrLess_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_CharPtrLess_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__CharPtrLess);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_CharPtrLess(int argc, VALUE *argv, VALUE self) {
  OpenBabel::CharPtrLess *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::CharPtrLess *)new OpenBabel::CharPtrLess();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_CharPtrLess(OpenBabel::CharPtrLess *arg1) {
    delete arg1;
}

swig_class cOBConversion;

SWIGINTERN VALUE
_wrap_new_OBConversion__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::istream *arg1 = (std::istream *) 0 ;
  std::ostream *arg2 = (std::ostream *) 0 ;
  OpenBabel::OBConversion *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__istream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBConversion" "', argument " "1"" of type '" "std::istream *""'"); 
  }
  arg1 = reinterpret_cast< std::istream * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_std__ostream, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::OBConversion" "', argument " "2"" of type '" "std::ostream *""'"); 
  }
  arg2 = reinterpret_cast< std::ostream * >(argp2);
  result = (OpenBabel::OBConversion *)new OpenBabel::OBConversion(arg1,arg2);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_OBConversion__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::istream *arg1 = (std::istream *) 0 ;
  OpenBabel::OBConversion *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__istream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBConversion" "', argument " "1"" of type '" "std::istream *""'"); 
  }
  arg1 = reinterpret_cast< std::istream * >(argp1);
  result = (OpenBabel::OBConversion *)new OpenBabel::OBConversion(arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_OBConversion__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBConversion *)new OpenBabel::OBConversion();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBConversion_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBConversion_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBConversion);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBConversion__SWIG_3(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = 0 ;
  OpenBabel::OBConversion *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBConversion,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBConversion" "', argument " "1"" of type '" "OpenBabel::OBConversion const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBConversion" "', argument " "1"" of type '" "OpenBabel::OBConversion const &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  result = (OpenBabel::OBConversion *)new OpenBabel::OBConversion((OpenBabel::OBConversion const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_OBConversion(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_OBConversion__SWIG_2(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__istream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBConversion__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBConversion, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBConversion__SWIG_3(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__istream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__ostream, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_OBConversion__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_OBConversion'");
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBConversion(OpenBabel::OBConversion *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_OBConversion_register_format__SWIG_0(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  OpenBabel::OBFormat *arg2 = (OpenBabel::OBFormat *) 0 ;
  char *arg3 = (char *) 0 ;
  int result;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBConversion::RegisterFormat" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::OBConversion::RegisterFormat" "', argument " "2"" of type '" "OpenBabel::OBFormat *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBFormat * >(argp2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "OpenBabel::OBConversion::RegisterFormat" "', argument " "3"" of type '" "char const *""'");
  }
  arg3 = reinterpret_cast< char * >(buf3);
  result = (int)OpenBabel::OBConversion::RegisterFormat((char const *)arg1,arg2,(char const *)arg3);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return vresult;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_register_format__SWIG_1(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  OpenBabel::OBFormat *arg2 = (OpenBabel::OBFormat *) 0 ;
  int result;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBConversion::RegisterFormat" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::OBConversion::RegisterFormat" "', argument " "2"" of type '" "OpenBabel::OBFormat *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBFormat * >(argp2);
  result = (int)OpenBabel::OBConversion::RegisterFormat((char const *)arg1,arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return vresult;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBConversion_register_format(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs;
  if (argc > 3) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBFormat, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBConversion_register_format__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBFormat, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_OBConversion_register_format__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBConversion_register_format'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_find_format(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  OpenBabel::OBFormat *result = 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBConversion::FindFormat" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  result = (OpenBabel::OBFormat *)OpenBabel::OBConversion::FindFormat((char const *)arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 );
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return vresult;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_format_from_ext(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  OpenBabel::OBFormat *result = 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBConversion::FormatFromExt" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  result = (OpenBabel::OBFormat *)OpenBabel::OBConversion::FormatFromExt((char const *)arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 );
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return vresult;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_format_from_mime(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  OpenBabel::OBFormat *result = 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBConversion::FormatFromMIME" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  result = (OpenBabel::OBFormat *)OpenBabel::OBConversion::FormatFromMIME((char const *)arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 );
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return vresult;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_get_next_format(int argc, VALUE *argv, VALUE self) {
  OpenBabel::Formatpos *arg1 = 0 ;
  char **arg2 = 0 ;
  OpenBabel::OBFormat **arg3 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__FMapType__iterator,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBConversion::GetNextFormat" "', argument " "1"" of type '" "OpenBabel::Formatpos &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBConversion::GetNextFormat" "', argument " "1"" of type '" "OpenBabel::Formatpos &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::Formatpos * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::OBConversion::GetNextFormat" "', argument " "2"" of type '" "char const *&""'");
  }
  arg2 = &buf2;
  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_p_OpenBabel__OBFormat,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "OpenBabel::OBConversion::GetNextFormat" "', argument " "3"" of type '" "OpenBabel::OBFormat *&""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBConversion::GetNextFormat" "', argument " "3"" of type '" "OpenBabel::OBFormat *&""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBFormat ** >(argp3);
  result = (bool)OpenBabel::OBConversion::GetNextFormat(*arg1,(char const *&)*arg2,*arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_description(int argc, VALUE *argv, VALUE self) {
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (char *)OpenBabel::OBConversion::Description();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_get_in_stream(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  std::istream *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetInStream" "', argument " "1"" of type '" "OpenBabel::OBConversion const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  result = (std::istream *)((OpenBabel::OBConversion const *)arg1)->GetInStream();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__istream, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_get_out_stream(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  std::ostream *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetOutStream" "', argument " "1"" of type '" "OpenBabel::OBConversion const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  result = (std::ostream *)((OpenBabel::OBConversion const *)arg1)->GetOutStream();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__ostream, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_set_in_stream(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  std::istream *arg2 = (std::istream *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetInStream" "', argument " "1"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_std__istream, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetInStream" "', argument " "2"" of type '" "std::istream *""'"); 
  }
  arg2 = reinterpret_cast< std::istream * >(argp2);
  (arg1)->SetInStream(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_set_out_stream(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  std::ostream *arg2 = (std::ostream *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetOutStream" "', argument " "1"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_std__ostream, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetOutStream" "', argument " "2"" of type '" "std::ostream *""'"); 
  }
  arg2 = reinterpret_cast< std::ostream * >(argp2);
  (arg1)->SetOutStream(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_set_in_and_out_formats__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetInAndOutFormats" "', argument " "1"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetInAndOutFormats" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[1], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SetInAndOutFormats" "', argument " "3"" of type '" "char const *""'");
  }
  arg3 = reinterpret_cast< char * >(buf3);
  result = (bool)(arg1)->SetInAndOutFormats((char const *)arg2,(char const *)arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_set_in_and_out_formats__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  OpenBabel::OBFormat *arg2 = (OpenBabel::OBFormat *) 0 ;
  OpenBabel::OBFormat *arg3 = (OpenBabel::OBFormat *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetInAndOutFormats" "', argument " "1"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetInAndOutFormats" "', argument " "2"" of type '" "OpenBabel::OBFormat *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBFormat * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SetInAndOutFormats" "', argument " "3"" of type '" "OpenBabel::OBFormat *""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBFormat * >(argp3);
  result = (bool)(arg1)->SetInAndOutFormats(arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBConversion_set_in_and_out_formats(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBConversion, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBFormat, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_OpenBabel__OBFormat, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_OBConversion_set_in_and_out_formats__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBConversion, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_OBConversion_set_in_and_out_formats__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBConversion_set_in_and_out_formats'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_set_in_format__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  char *arg2 = (char *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetInFormat" "', argument " "1"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetInFormat" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (bool)(arg1)->SetInFormat((char const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_set_in_format__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  OpenBabel::OBFormat *arg2 = (OpenBabel::OBFormat *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetInFormat" "', argument " "1"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetInFormat" "', argument " "2"" of type '" "OpenBabel::OBFormat *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBFormat * >(argp2);
  result = (bool)(arg1)->SetInFormat(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBConversion_set_in_format(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBConversion, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBFormat, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBConversion_set_in_format__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBConversion, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBConversion_set_in_format__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBConversion_set_in_format'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_set_out_format__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  char *arg2 = (char *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetOutFormat" "', argument " "1"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetOutFormat" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (bool)(arg1)->SetOutFormat((char const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_set_out_format__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  OpenBabel::OBFormat *arg2 = (OpenBabel::OBFormat *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetOutFormat" "', argument " "1"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetOutFormat" "', argument " "2"" of type '" "OpenBabel::OBFormat *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBFormat * >(argp2);
  result = (bool)(arg1)->SetOutFormat(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBConversion_set_out_format(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBConversion, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBFormat, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBConversion_set_out_format__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBConversion, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBConversion_set_out_format__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBConversion_set_out_format'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_get_in_format(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  OpenBabel::OBFormat *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetInFormat" "', argument " "1"" of type '" "OpenBabel::OBConversion const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  result = (OpenBabel::OBFormat *)((OpenBabel::OBConversion const *)arg1)->GetInFormat();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_get_out_format(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  OpenBabel::OBFormat *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetOutFormat" "', argument " "1"" of type '" "OpenBabel::OBConversion const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  result = (OpenBabel::OBFormat *)((OpenBabel::OBConversion const *)arg1)->GetOutFormat();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_get_in_filename(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetInFilename" "', argument " "1"" of type '" "OpenBabel::OBConversion const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  result = ((OpenBabel::OBConversion const *)arg1)->GetInFilename();
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_get_in_pos(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  std::streampos result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetInPos" "', argument " "1"" of type '" "OpenBabel::OBConversion const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  result = ((OpenBabel::OBConversion const *)arg1)->GetInPos();
  vresult = SWIG_NewPointerObj((new std::streampos(static_cast< const std::streampos& >(result))), SWIGTYPE_p_std__streampos, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_get_in_len(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  size_t result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetInLen" "', argument " "1"" of type '" "OpenBabel::OBConversion const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  result = ((OpenBabel::OBConversion const *)arg1)->GetInLen();
  vresult = SWIG_From_size_t(static_cast< size_t >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_get_title(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  char *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetTitle" "', argument " "1"" of type '" "OpenBabel::OBConversion const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  result = (char *)((OpenBabel::OBConversion const *)arg1)->GetTitle();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_get_aux_conv(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  OpenBabel::OBConversion *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAuxConv" "', argument " "1"" of type '" "OpenBabel::OBConversion const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  result = (OpenBabel::OBConversion *)((OpenBabel::OBConversion const *)arg1)->GetAuxConv();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_set_aux_conv(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  OpenBabel::OBConversion *arg2 = (OpenBabel::OBConversion *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetAuxConv" "', argument " "1"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetAuxConv" "', argument " "2"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBConversion * >(argp2);
  (arg1)->SetAuxConv(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_is_option__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  char *arg2 = (char *) 0 ;
  OpenBabel::OBConversion::Option_type arg3 ;
  char *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsOption" "', argument " "1"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "IsOption" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "IsOption" "', argument " "3"" of type '" "OpenBabel::OBConversion::Option_type""'");
  } 
  arg3 = static_cast< OpenBabel::OBConversion::Option_type >(val3);
  result = (char *)(arg1)->IsOption((char const *)arg2,arg3);
  vresult = SWIG_FromCharPtr((const char *)result);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_is_option__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  char *arg2 = (char *) 0 ;
  char *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsOption" "', argument " "1"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "IsOption" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (char *)(arg1)->IsOption((char const *)arg2);
  vresult = SWIG_FromCharPtr((const char *)result);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBConversion_is_option(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBConversion, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBConversion_is_option__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBConversion, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_OBConversion_is_option__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBConversion_is_option'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_get_options(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  OpenBabel::OBConversion::Option_type arg2 ;
  std::map<std::string,std::string > *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetOptions" "', argument " "1"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetOptions" "', argument " "2"" of type '" "OpenBabel::OBConversion::Option_type""'");
  } 
  arg2 = static_cast< OpenBabel::OBConversion::Option_type >(val2);
  result = (std::map<std::string,std::string > *)(arg1)->GetOptions(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__mapTstd__string_std__string_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_add_option__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  char *arg2 = (char *) 0 ;
  OpenBabel::OBConversion::Option_type arg3 ;
  char *arg4 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  int alloc4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AddOption" "', argument " "1"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AddOption" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "AddOption" "', argument " "3"" of type '" "OpenBabel::OBConversion::Option_type""'");
  } 
  arg3 = static_cast< OpenBabel::OBConversion::Option_type >(val3);
  res4 = SWIG_AsCharPtrAndSize(argv[2], &buf4, NULL, &alloc4);
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "AddOption" "', argument " "4"" of type '" "char const *""'");
  }
  arg4 = reinterpret_cast< char * >(buf4);
  (arg1)->AddOption((char const *)arg2,arg3,(char const *)arg4);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc4 == SWIG_NEWOBJ) delete[] buf4;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc4 == SWIG_NEWOBJ) delete[] buf4;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_add_option__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  char *arg2 = (char *) 0 ;
  OpenBabel::OBConversion::Option_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AddOption" "', argument " "1"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AddOption" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "AddOption" "', argument " "3"" of type '" "OpenBabel::OBConversion::Option_type""'");
  } 
  arg3 = static_cast< OpenBabel::OBConversion::Option_type >(val3);
  (arg1)->AddOption((char const *)arg2,arg3);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBConversion_add_option(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBConversion, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_OBConversion_add_option__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBConversion, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          int res = SWIG_AsCharPtrAndSize(argv[3], 0, NULL, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_OBConversion_add_option__SWIG_0(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBConversion_add_option'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_remove_option(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  char *arg2 = (char *) 0 ;
  OpenBabel::OBConversion::Option_type arg3 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RemoveOption" "', argument " "1"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "RemoveOption" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "RemoveOption" "', argument " "3"" of type '" "OpenBabel::OBConversion::Option_type""'");
  } 
  arg3 = static_cast< OpenBabel::OBConversion::Option_type >(val3);
  result = (bool)(arg1)->RemoveOption((char const *)arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_set_options(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  char *arg2 = (char *) 0 ;
  OpenBabel::OBConversion::Option_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetOptions" "', argument " "1"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetOptions" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SetOptions" "', argument " "3"" of type '" "OpenBabel::OBConversion::Option_type""'");
  } 
  arg3 = static_cast< OpenBabel::OBConversion::Option_type >(val3);
  (arg1)->SetOptions((char const *)arg2,arg3);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_register_option_param__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::string arg1 ;
  OpenBabel::OBFormat *arg2 = (OpenBabel::OBFormat *) 0 ;
  int arg3 ;
  OpenBabel::OBConversion::Option_type arg4 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "OpenBabel::OBConversion::RegisterOptionParam" "', argument " "1"" of type '" "std::string""'"); 
    }
    arg1 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::OBConversion::RegisterOptionParam" "', argument " "2"" of type '" "OpenBabel::OBFormat *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBFormat * >(argp2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "OpenBabel::OBConversion::RegisterOptionParam" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  ecode4 = SWIG_AsVal_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "OpenBabel::OBConversion::RegisterOptionParam" "', argument " "4"" of type '" "OpenBabel::OBConversion::Option_type""'");
  } 
  arg4 = static_cast< OpenBabel::OBConversion::Option_type >(val4);
  OpenBabel::OBConversion::RegisterOptionParam(arg1,arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_register_option_param__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::string arg1 ;
  OpenBabel::OBFormat *arg2 = (OpenBabel::OBFormat *) 0 ;
  int arg3 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "OpenBabel::OBConversion::RegisterOptionParam" "', argument " "1"" of type '" "std::string""'"); 
    }
    arg1 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::OBConversion::RegisterOptionParam" "', argument " "2"" of type '" "OpenBabel::OBFormat *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBFormat * >(argp2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "OpenBabel::OBConversion::RegisterOptionParam" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  OpenBabel::OBConversion::RegisterOptionParam(arg1,arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_register_option_param__SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::string arg1 ;
  OpenBabel::OBFormat *arg2 = (OpenBabel::OBFormat *) 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "OpenBabel::OBConversion::RegisterOptionParam" "', argument " "1"" of type '" "std::string""'"); 
    }
    arg1 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::OBConversion::RegisterOptionParam" "', argument " "2"" of type '" "OpenBabel::OBFormat *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBFormat * >(argp2);
  OpenBabel::OBConversion::RegisterOptionParam(arg1,arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBConversion_register_option_param(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs;
  if (argc > 4) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBFormat, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBConversion_register_option_param__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBFormat, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_OBConversion_register_option_param__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBFormat, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_OBConversion_register_option_param__SWIG_0(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBConversion_register_option_param'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_get_option_params(int argc, VALUE *argv, VALUE self) {
  std::string arg1 ;
  OpenBabel::OBConversion::Option_type arg2 ;
  int result;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "OpenBabel::OBConversion::GetOptionParams" "', argument " "1"" of type '" "std::string""'"); 
    }
    arg1 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "OpenBabel::OBConversion::GetOptionParams" "', argument " "2"" of type '" "OpenBabel::OBConversion::Option_type""'");
  } 
  arg2 = static_cast< OpenBabel::OBConversion::Option_type >(val2);
  result = (int)OpenBabel::OBConversion::GetOptionParams(arg1,arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_get_supported_input_format(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  std::vector<std::string > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetSupportedInputFormat" "', argument " "1"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  result = (arg1)->GetSupportedInputFormat();
  vresult = SWIG_NewPointerObj((new std::vector<std::string >(static_cast< const std::vector<std::string >& >(result))), SWIGTYPE_p_std__vectorTstd__string_t, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_get_supported_output_format(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  std::vector<std::string > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetSupportedOutputFormat" "', argument " "1"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  result = (arg1)->GetSupportedOutputFormat();
  vresult = SWIG_NewPointerObj((new std::vector<std::string >(static_cast< const std::vector<std::string >& >(result))), SWIGTYPE_p_std__vectorTstd__string_t, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_convert__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  std::istream *arg2 = (std::istream *) 0 ;
  std::ostream *arg3 = (std::ostream *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Convert" "', argument " "1"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_std__istream, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Convert" "', argument " "2"" of type '" "std::istream *""'"); 
  }
  arg2 = reinterpret_cast< std::istream * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_std__ostream, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Convert" "', argument " "3"" of type '" "std::ostream *""'"); 
  }
  arg3 = reinterpret_cast< std::ostream * >(argp3);
  result = (int)(arg1)->Convert(arg2,arg3);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_convert__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Convert" "', argument " "1"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  result = (int)(arg1)->Convert();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBConversion_convert(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBConversion, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBConversion_convert__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBConversion, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__istream, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_std__ostream, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_OBConversion_convert__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBConversion_convert'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_full_convert(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  std::vector<std::string > *arg2 = 0 ;
  std::string *arg3 = 0 ;
  std::vector<std::string > *arg4 = 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FullConvert" "', argument " "1"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTstd__string_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "FullConvert" "', argument " "2"" of type '" "std::vector<std::string > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "FullConvert" "', argument " "2"" of type '" "std::vector<std::string > &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<std::string > * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_std__string,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "FullConvert" "', argument " "3"" of type '" "std::string &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "FullConvert" "', argument " "3"" of type '" "std::string &""'"); 
  }
  arg3 = reinterpret_cast< std::string * >(argp3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4, SWIGTYPE_p_std__vectorTstd__string_t,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "FullConvert" "', argument " "4"" of type '" "std::vector<std::string > &""'"); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "FullConvert" "', argument " "4"" of type '" "std::vector<std::string > &""'"); 
  }
  arg4 = reinterpret_cast< std::vector<std::string > * >(argp4);
  result = (int)(arg1)->FullConvert(*arg2,*arg3,*arg4);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_add_chem_object(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AddChemObject" "', argument " "1"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AddChemObject" "', argument " "2"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  result = (bool)(arg1)->AddChemObject(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_get_chem_object(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  OpenBabel::OBBase *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetChemObject" "', argument " "1"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  result = (OpenBabel::OBBase *)(arg1)->GetChemObject();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_is_last(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsLast" "', argument " "1"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  result = (bool)(arg1)->IsLast();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_is_first_input(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsFirstInput" "', argument " "1"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  result = (bool)(arg1)->IsFirstInput();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_get_output_index(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetOutputIndex" "', argument " "1"" of type '" "OpenBabel::OBConversion const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  result = (int)((OpenBabel::OBConversion const *)arg1)->GetOutputIndex();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_set_output_index(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetOutputIndex" "', argument " "1"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetOutputIndex" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->SetOutputIndex(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_set_more_files_to_come(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetMoreFilesToCome" "', argument " "1"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  (arg1)->SetMoreFilesToCome();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_set_one_object_only__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetOneObjectOnly" "', argument " "1"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetOneObjectOnly" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  (arg1)->SetOneObjectOnly(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_set_one_object_only__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetOneObjectOnly" "', argument " "1"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  (arg1)->SetOneObjectOnly();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBConversion_set_one_object_only(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBConversion, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBConversion_set_one_object_only__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBConversion, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBConversion_set_one_object_only__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBConversion_set_one_object_only'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_set_last(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetLast" "', argument " "1"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetLast" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  (arg1)->SetLast(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_get_default_format(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFormat *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBFormat *)OpenBabel::OBConversion::GetDefaultFormat();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_write__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  std::ostream *arg3 = (std::ostream *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Write" "', argument " "1"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Write" "', argument " "2"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_std__ostream, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Write" "', argument " "3"" of type '" "std::ostream *""'"); 
  }
  arg3 = reinterpret_cast< std::ostream * >(argp3);
  result = (bool)(arg1)->Write(arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_write__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Write" "', argument " "1"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Write" "', argument " "2"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  result = (bool)(arg1)->Write(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBConversion_write(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBConversion, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBBase, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBConversion_write__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBConversion, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBBase, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_std__ostream, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_OBConversion_write__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBConversion_write'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_write_string__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  bool arg3 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "WriteString" "', argument " "1"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "WriteString" "', argument " "2"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  ecode3 = SWIG_AsVal_bool(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "WriteString" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  result = (arg1)->WriteString(arg2,arg3);
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_write_string__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "WriteString" "', argument " "1"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "WriteString" "', argument " "2"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  result = (arg1)->WriteString(arg2);
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBConversion_write_string(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBConversion, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBBase, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBConversion_write_string__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBConversion, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBBase, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_bool(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_OBConversion_write_string__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBConversion_write_string'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_write_file(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  std::string arg3 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "WriteFile" "', argument " "1"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "WriteFile" "', argument " "2"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "WriteFile" "', argument " "3"" of type '" "std::string""'"); 
    }
    arg3 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = (bool)(arg1)->WriteFile(arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_close_out_file(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CloseOutFile" "', argument " "1"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  (arg1)->CloseOutFile();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_read__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  std::istream *arg3 = (std::istream *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Read" "', argument " "1"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Read" "', argument " "2"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_std__istream, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Read" "', argument " "3"" of type '" "std::istream *""'"); 
  }
  arg3 = reinterpret_cast< std::istream * >(argp3);
  result = (bool)(arg1)->Read(arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_read__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Read" "', argument " "1"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Read" "', argument " "2"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  result = (bool)(arg1)->Read(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBConversion_read(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBConversion, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBBase, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBConversion_read__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBConversion, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBBase, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_std__istream, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_OBConversion_read__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBConversion_read'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_read_string(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  std::string arg3 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ReadString" "', argument " "1"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ReadString" "', argument " "2"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "ReadString" "', argument " "3"" of type '" "std::string""'"); 
    }
    arg3 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = (bool)(arg1)->ReadString(arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBConversion_read_file(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  std::string arg3 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ReadFile" "', argument " "1"" of type '" "OpenBabel::OBConversion *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ReadFile" "', argument " "2"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "ReadFile" "', argument " "3"" of type '" "std::string""'"); 
    }
    arg3 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = (bool)(arg1)->ReadFile(arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


swig_class cOBResidue;

SWIGINTERN VALUE
_wrap_new_OBResidue__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBResidue *)new OpenBabel::OBResidue();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBResidue_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBResidue_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBResidue);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBResidue__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = 0 ;
  OpenBabel::OBResidue *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBResidue,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBResidue" "', argument " "1"" of type '" "OpenBabel::OBResidue const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBResidue" "', argument " "1"" of type '" "OpenBabel::OBResidue const &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  result = (OpenBabel::OBResidue *)new OpenBabel::OBResidue((OpenBabel::OBResidue const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_OBResidue(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_OBResidue__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidue, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBResidue__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_OBResidue'");
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBResidue(OpenBabel::OBResidue *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_OBResidue_add_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AddAtom" "', argument " "1"" of type '" "OpenBabel::OBResidue *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AddAtom" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  (arg1)->AddAtom(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidue_insert_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InsertAtom" "', argument " "1"" of type '" "OpenBabel::OBResidue *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InsertAtom" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  (arg1)->InsertAtom(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidue_remove_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RemoveAtom" "', argument " "1"" of type '" "OpenBabel::OBResidue *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "RemoveAtom" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  (arg1)->RemoveAtom(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidue_clear(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Clear" "', argument " "1"" of type '" "OpenBabel::OBResidue *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  result = (bool)(arg1)->Clear();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidue_set_name(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetName" "', argument " "1"" of type '" "OpenBabel::OBResidue *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetName" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetName" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  (arg1)->SetName((std::string const &)*arg2);
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidue_set_num(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetNum" "', argument " "1"" of type '" "OpenBabel::OBResidue *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetNum" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  (arg1)->SetNum(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidue_set_chain(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ;
  char arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetChain" "', argument " "1"" of type '" "OpenBabel::OBResidue *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  ecode2 = SWIG_AsVal_char(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetChain" "', argument " "2"" of type '" "char""'");
  } 
  arg2 = static_cast< char >(val2);
  (arg1)->SetChain(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidue_set_chain_num(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetChainNum" "', argument " "1"" of type '" "OpenBabel::OBResidue *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetChainNum" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  (arg1)->SetChainNum(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidue_set_idx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetIdx" "', argument " "1"" of type '" "OpenBabel::OBResidue *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetIdx" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  (arg1)->SetIdx(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidue_set_atom_id(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int res3 = SWIG_OLDOBJ ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetAtomID" "', argument " "1"" of type '" "OpenBabel::OBResidue *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetAtomID" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SetAtomID" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetAtomID" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  (arg1)->SetAtomID(arg2,(std::string const &)*arg3);
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
fail:
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidue_set_het_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  bool arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetHetAtom" "', argument " "1"" of type '" "OpenBabel::OBResidue *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetHetAtom" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  ecode3 = SWIG_AsVal_bool(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SetHetAtom" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  (arg1)->SetHetAtom(arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidue_set_serial_num(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  unsigned int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetSerialNum" "', argument " "1"" of type '" "OpenBabel::OBResidue *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetSerialNum" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SetSerialNum" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  (arg1)->SetSerialNum(arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidue_get_name(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetName" "', argument " "1"" of type '" "OpenBabel::OBResidue const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  result = ((OpenBabel::OBResidue const *)arg1)->GetName();
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidue_get_num(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetNum" "', argument " "1"" of type '" "OpenBabel::OBResidue const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  result = (unsigned int)((OpenBabel::OBResidue const *)arg1)->GetNum();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidue_get_num_atoms(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetNumAtoms" "', argument " "1"" of type '" "OpenBabel::OBResidue const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  result = (unsigned int)((OpenBabel::OBResidue const *)arg1)->GetNumAtoms();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidue_get_chain(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ;
  char result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetChain" "', argument " "1"" of type '" "OpenBabel::OBResidue const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  result = (char)((OpenBabel::OBResidue const *)arg1)->GetChain();
  vresult = SWIG_From_char(static_cast< char >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidue_get_chain_num(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetChainNum" "', argument " "1"" of type '" "OpenBabel::OBResidue const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  result = (unsigned int)((OpenBabel::OBResidue const *)arg1)->GetChainNum();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidue_get_idx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetIdx" "', argument " "1"" of type '" "OpenBabel::OBResidue const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  result = (unsigned int)((OpenBabel::OBResidue const *)arg1)->GetIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidue_get_res_key(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetResKey" "', argument " "1"" of type '" "OpenBabel::OBResidue const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  result = (unsigned int)((OpenBabel::OBResidue const *)arg1)->GetResKey();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidue_get_atoms(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBAtom * > > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAtoms" "', argument " "1"" of type '" "OpenBabel::OBResidue const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  result = ((OpenBabel::OBResidue const *)arg1)->GetAtoms();
  vresult = SWIG_NewPointerObj((new std::vector<OpenBabel::OBAtom * >(static_cast< const std::vector<OpenBabel::OBAtom * >& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBAtom_p_t, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidue_get_bonds__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ;
  bool arg2 ;
  SwigValueWrapper<std::vector<OpenBabel::OBBond * > > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetBonds" "', argument " "1"" of type '" "OpenBabel::OBResidue const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetBonds" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = ((OpenBabel::OBResidue const *)arg1)->GetBonds(arg2);
  vresult = SWIG_NewPointerObj((new std::vector<OpenBabel::OBBond * >(static_cast< const std::vector<OpenBabel::OBBond * >& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidue_get_bonds__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBBond * > > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetBonds" "', argument " "1"" of type '" "OpenBabel::OBResidue const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  result = ((OpenBabel::OBResidue const *)arg1)->GetBonds();
  vresult = SWIG_NewPointerObj((new std::vector<OpenBabel::OBBond * >(static_cast< const std::vector<OpenBabel::OBBond * >& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBResidue_get_bonds(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidue, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBResidue_get_bonds__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidue, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBResidue_get_bonds__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBResidue_get_bonds'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidue_get_atom_id(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAtomID" "', argument " "1"" of type '" "OpenBabel::OBResidue const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetAtomID" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = ((OpenBabel::OBResidue const *)arg1)->GetAtomID(arg2);
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidue_get_serial_num(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetSerialNum" "', argument " "1"" of type '" "OpenBabel::OBResidue const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetSerialNum" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (unsigned int)((OpenBabel::OBResidue const *)arg1)->GetSerialNum(arg2);
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidue_get_amino_acid_property(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ;
  int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAminoAcidProperty" "', argument " "1"" of type '" "OpenBabel::OBResidue const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetAminoAcidProperty" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (bool)((OpenBabel::OBResidue const *)arg1)->GetAminoAcidProperty(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidue_get_atom_property(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  int arg3 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAtomProperty" "', argument " "1"" of type '" "OpenBabel::OBResidue const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetAtomProperty" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "GetAtomProperty" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  result = (bool)((OpenBabel::OBResidue const *)arg1)->GetAtomProperty(arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidue_get_residue_property(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ;
  int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetResidueProperty" "', argument " "1"" of type '" "OpenBabel::OBResidue const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetResidueProperty" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (bool)((OpenBabel::OBResidue const *)arg1)->GetResidueProperty(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidue_is_het_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsHetAtom" "', argument " "1"" of type '" "OpenBabel::OBResidue const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "IsHetAtom" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (bool)((OpenBabel::OBResidue const *)arg1)->IsHetAtom(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidue_is_residue_type(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ;
  int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsResidueType" "', argument " "1"" of type '" "OpenBabel::OBResidue const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IsResidueType" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (bool)((OpenBabel::OBResidue const *)arg1)->IsResidueType(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidue_begin_atoms(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBAtom * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginAtoms" "', argument " "1"" of type '" "OpenBabel::OBResidue *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  result = (arg1)->BeginAtoms();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBAtomIterator(static_cast< const OpenBabel::OBAtomIterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBAtom_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidue_end_atoms(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBAtom * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EndAtoms" "', argument " "1"" of type '" "OpenBabel::OBResidue *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  result = (arg1)->EndAtoms();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBAtomIterator(static_cast< const OpenBabel::OBAtomIterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBAtom_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidue_begin_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ;
  std::vector<OpenBabel::OBAtom * >::iterator *arg2 = 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginAtom" "', argument " "1"" of type '" "OpenBabel::OBResidue *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBAtom_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "BeginAtom" "', argument " "2"" of type '" "std::vector<OpenBabel::OBAtom * >::iterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "BeginAtom" "', argument " "2"" of type '" "std::vector<OpenBabel::OBAtom * >::iterator &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<OpenBabel::OBAtom * >::iterator * >(argp2);
  result = (OpenBabel::OBAtom *)(arg1)->BeginAtom(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidue_next_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ;
  std::vector<OpenBabel::OBAtom * >::iterator *arg2 = 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NextAtom" "', argument " "1"" of type '" "OpenBabel::OBResidue *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBAtom_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "NextAtom" "', argument " "2"" of type '" "std::vector<OpenBabel::OBAtom * >::iterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "NextAtom" "', argument " "2"" of type '" "std::vector<OpenBabel::OBAtom * >::iterator &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<OpenBabel::OBAtom * >::iterator * >(argp2);
  result = (OpenBabel::OBAtom *)(arg1)->NextAtom(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
Residue_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_NewPointerObj(SWIG_as_voidptr(OpenBabel::Residue), SWIGTYPE_p_a_4__char,  0 );
  return _val;
}


SWIGINTERN VALUE
Residue_set(VALUE self, VALUE _val) {
  {
    char (*inp)[4] = 0;
    int res = SWIG_ConvertPtr(_val, SWIG_as_voidptrptr(&inp), SWIGTYPE_p_a_4__char,  0 );
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""OpenBabel::Residue""' of type '""char [100][4]""'");
    } else if (inp) {
      size_t ii = 0;
      for (; ii < (size_t)100; ++ii) {
        if (inp[ii]) {
          size_t jj = 0;
          for (; jj < (size_t)4; ++jj) OpenBabel::Residue[ii][jj] = inp[ii][jj];
        } else {
          SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""OpenBabel::Residue""' of type '""char [100][4]""'");
        }
      }
    } else {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""OpenBabel::Residue""' of type '""char [100][4]""'");
    }
  }
  return _val;
fail:
  return Qnil;
}


SWIGINTERN VALUE
ElemDesc_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_NewPointerObj(SWIG_as_voidptr(OpenBabel::ElemDesc), SWIGTYPE_p_a_4__char,  0 );
  return _val;
}


SWIGINTERN VALUE
ElemDesc_set(VALUE self, VALUE _val) {
  {
    char (*inp)[4] = 0;
    int res = SWIG_ConvertPtr(_val, SWIG_as_voidptrptr(&inp), SWIGTYPE_p_a_4__char,  0 );
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""OpenBabel::ElemDesc""' of type '""char [1024][4]""'");
    } else if (inp) {
      size_t ii = 0;
      for (; ii < (size_t)1024; ++ii) {
        if (inp[ii]) {
          size_t jj = 0;
          for (; jj < (size_t)4; ++jj) OpenBabel::ElemDesc[ii][jj] = inp[ii][jj];
        } else {
          SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""OpenBabel::ElemDesc""' of type '""char [1024][4]""'");
        }
      }
    } else {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""OpenBabel::ElemDesc""' of type '""char [1024][4]""'");
    }
  }
  return _val;
fail:
  return Qnil;
}


SWIGINTERN VALUE
ResNo_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(OpenBabel::ResNo));
  return _val;
}


SWIGINTERN VALUE
ResNo_set(VALUE self, VALUE _val) {
  {
    unsigned int val;
    int res = SWIG_AsVal_unsigned_SS_int(_val, &val);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""OpenBabel::ResNo""' of type '""unsigned int""'");
    }
    OpenBabel::ResNo = static_cast< unsigned int >(val);
  }
  return _val;
fail:
  return Qnil;
}


SWIGINTERN VALUE
ElemNo_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(OpenBabel::ElemNo));
  return _val;
}


SWIGINTERN VALUE
ElemNo_set(VALUE self, VALUE _val) {
  {
    unsigned int val;
    int res = SWIG_AsVal_unsigned_SS_int(_val, &val);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""OpenBabel::ElemNo""' of type '""unsigned int""'");
    }
    OpenBabel::ElemNo = static_cast< unsigned int >(val);
  }
  return _val;
fail:
  return Qnil;
}


swig_class cOBInternalCoord;

SWIGINTERN VALUE
_wrap_OBInternalCoord__a_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBInternalCoord *arg1 = (OpenBabel::OBInternalCoord *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBInternalCoord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_a" "', argument " "1"" of type '" "OpenBabel::OBInternalCoord *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBInternalCoord * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "_a" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  if (arg1) (arg1)->_a = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBInternalCoord__a_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBInternalCoord *arg1 = (OpenBabel::OBInternalCoord *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBInternalCoord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_a" "', argument " "1"" of type '" "OpenBabel::OBInternalCoord *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBInternalCoord * >(argp1);
  result = (OpenBabel::OBAtom *) ((arg1)->_a);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBInternalCoord__b_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBInternalCoord *arg1 = (OpenBabel::OBInternalCoord *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBInternalCoord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_b" "', argument " "1"" of type '" "OpenBabel::OBInternalCoord *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBInternalCoord * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "_b" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  if (arg1) (arg1)->_b = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBInternalCoord__b_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBInternalCoord *arg1 = (OpenBabel::OBInternalCoord *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBInternalCoord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_b" "', argument " "1"" of type '" "OpenBabel::OBInternalCoord *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBInternalCoord * >(argp1);
  result = (OpenBabel::OBAtom *) ((arg1)->_b);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBInternalCoord__c_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBInternalCoord *arg1 = (OpenBabel::OBInternalCoord *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBInternalCoord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_c" "', argument " "1"" of type '" "OpenBabel::OBInternalCoord *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBInternalCoord * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "_c" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  if (arg1) (arg1)->_c = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBInternalCoord__c_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBInternalCoord *arg1 = (OpenBabel::OBInternalCoord *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBInternalCoord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_c" "', argument " "1"" of type '" "OpenBabel::OBInternalCoord *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBInternalCoord * >(argp1);
  result = (OpenBabel::OBAtom *) ((arg1)->_c);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBInternalCoord__dst_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBInternalCoord *arg1 = (OpenBabel::OBInternalCoord *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBInternalCoord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_dst" "', argument " "1"" of type '" "OpenBabel::OBInternalCoord *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBInternalCoord * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "_dst" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  if (arg1) (arg1)->_dst = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBInternalCoord__dst_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBInternalCoord *arg1 = (OpenBabel::OBInternalCoord *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBInternalCoord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_dst" "', argument " "1"" of type '" "OpenBabel::OBInternalCoord *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBInternalCoord * >(argp1);
  result = (double) ((arg1)->_dst);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBInternalCoord__ang_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBInternalCoord *arg1 = (OpenBabel::OBInternalCoord *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBInternalCoord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_ang" "', argument " "1"" of type '" "OpenBabel::OBInternalCoord *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBInternalCoord * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "_ang" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  if (arg1) (arg1)->_ang = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBInternalCoord__ang_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBInternalCoord *arg1 = (OpenBabel::OBInternalCoord *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBInternalCoord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_ang" "', argument " "1"" of type '" "OpenBabel::OBInternalCoord *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBInternalCoord * >(argp1);
  result = (double) ((arg1)->_ang);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBInternalCoord__tor_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBInternalCoord *arg1 = (OpenBabel::OBInternalCoord *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBInternalCoord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_tor" "', argument " "1"" of type '" "OpenBabel::OBInternalCoord *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBInternalCoord * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "_tor" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  if (arg1) (arg1)->_tor = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBInternalCoord__tor_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBInternalCoord *arg1 = (OpenBabel::OBInternalCoord *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBInternalCoord, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_tor" "', argument " "1"" of type '" "OpenBabel::OBInternalCoord *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBInternalCoord * >(argp1);
  result = (double) ((arg1)->_tor);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_OBInternalCoord__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg3 = (OpenBabel::OBAtom *) 0 ;
  double arg4 ;
  double arg5 ;
  double arg6 ;
  OpenBabel::OBInternalCoord *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  double val5 ;
  int ecode5 = 0 ;
  double val6 ;
  int ecode6 = 0 ;
  
  if ((argc < 6) || (argc > 6)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 6)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBInternalCoord" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::OBInternalCoord" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "OpenBabel::OBInternalCoord" "', argument " "3"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBAtom * >(argp3);
  ecode4 = SWIG_AsVal_double(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "OpenBabel::OBInternalCoord" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = static_cast< double >(val4);
  ecode5 = SWIG_AsVal_double(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "OpenBabel::OBInternalCoord" "', argument " "5"" of type '" "double""'");
  } 
  arg5 = static_cast< double >(val5);
  ecode6 = SWIG_AsVal_double(argv[5], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "OpenBabel::OBInternalCoord" "', argument " "6"" of type '" "double""'");
  } 
  arg6 = static_cast< double >(val6);
  result = (OpenBabel::OBInternalCoord *)new OpenBabel::OBInternalCoord(arg1,arg2,arg3,arg4,arg5,arg6);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_OBInternalCoord__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg3 = (OpenBabel::OBAtom *) 0 ;
  double arg4 ;
  double arg5 ;
  OpenBabel::OBInternalCoord *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  double val5 ;
  int ecode5 = 0 ;
  
  if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBInternalCoord" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::OBInternalCoord" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "OpenBabel::OBInternalCoord" "', argument " "3"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBAtom * >(argp3);
  ecode4 = SWIG_AsVal_double(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "OpenBabel::OBInternalCoord" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = static_cast< double >(val4);
  ecode5 = SWIG_AsVal_double(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "OpenBabel::OBInternalCoord" "', argument " "5"" of type '" "double""'");
  } 
  arg5 = static_cast< double >(val5);
  result = (OpenBabel::OBInternalCoord *)new OpenBabel::OBInternalCoord(arg1,arg2,arg3,arg4,arg5);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_OBInternalCoord__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg3 = (OpenBabel::OBAtom *) 0 ;
  double arg4 ;
  OpenBabel::OBInternalCoord *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBInternalCoord" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::OBInternalCoord" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "OpenBabel::OBInternalCoord" "', argument " "3"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBAtom * >(argp3);
  ecode4 = SWIG_AsVal_double(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "OpenBabel::OBInternalCoord" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = static_cast< double >(val4);
  result = (OpenBabel::OBInternalCoord *)new OpenBabel::OBInternalCoord(arg1,arg2,arg3,arg4);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_OBInternalCoord__SWIG_3(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg3 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBInternalCoord *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBInternalCoord" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::OBInternalCoord" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "OpenBabel::OBInternalCoord" "', argument " "3"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBAtom * >(argp3);
  result = (OpenBabel::OBInternalCoord *)new OpenBabel::OBInternalCoord(arg1,arg2,arg3);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_OBInternalCoord__SWIG_4(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBInternalCoord *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBInternalCoord" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::OBInternalCoord" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (OpenBabel::OBInternalCoord *)new OpenBabel::OBInternalCoord(arg1,arg2);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_OBInternalCoord__SWIG_5(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBInternalCoord *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBInternalCoord" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (OpenBabel::OBInternalCoord *)new OpenBabel::OBInternalCoord(arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBInternalCoord_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBInternalCoord_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBInternalCoord);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBInternalCoord__SWIG_6(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBInternalCoord *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBInternalCoord *)new OpenBabel::OBInternalCoord();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_OBInternalCoord(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[6];
  int ii;
  
  argc = nargs;
  if (argc > 6) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_OBInternalCoord__SWIG_6(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBInternalCoord__SWIG_5(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_OBInternalCoord__SWIG_4(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_new_OBInternalCoord__SWIG_3(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_double(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_new_OBInternalCoord__SWIG_2(nargs, args, self);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_double(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            {
              int res = SWIG_AsVal_double(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              return _wrap_new_OBInternalCoord__SWIG_1(nargs, args, self);
            }
          }
        }
      }
    }
  }
  if (argc == 6) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_double(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            {
              int res = SWIG_AsVal_double(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              {
                int res = SWIG_AsVal_double(argv[5], NULL);
                _v = SWIG_CheckState(res);
              }
              if (_v) {
                return _wrap_new_OBInternalCoord__SWIG_0(nargs, args, self);
              }
            }
          }
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_OBInternalCoord'");
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBInternalCoord(OpenBabel::OBInternalCoord *arg1) {
    delete arg1;
}

swig_class cOBAtom;

SWIGINTERN VALUE
_wrap_OBAtom_Visit_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Visit" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Visit" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  if (arg1) (arg1)->Visit = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_Visit_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Visit" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (bool) ((arg1)->Visit);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBAtom_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBAtom_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBAtom);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBAtom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBAtom *)new OpenBabel::OBAtom();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBAtom(OpenBabel::OBAtom *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_OBAtom_clear(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Clear" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (bool)(arg1)->Clear();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_set_idx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetIdx" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetIdx" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->SetIdx(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_set_hyb(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetHyb" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetHyb" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->SetHyb(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_set_atomic_num(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetAtomicNum" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetAtomicNum" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->SetAtomicNum(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_set_isotope(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetIsotope" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetIsotope" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  (arg1)->SetIsotope(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_set_implicit_valence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetImplicitValence" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetImplicitValence" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->SetImplicitValence(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_increment_implicit_valence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IncrementImplicitValence" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  (arg1)->IncrementImplicitValence();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_decrement_implicit_valence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DecrementImplicitValence" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  (arg1)->DecrementImplicitValence();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_set_formal_charge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetFormalCharge" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetFormalCharge" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->SetFormalCharge(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_set_spin_multiplicity(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  short arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  short val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetSpinMultiplicity" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  ecode2 = SWIG_AsVal_short(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetSpinMultiplicity" "', argument " "2"" of type '" "short""'");
  } 
  arg2 = static_cast< short >(val2);
  (arg1)->SetSpinMultiplicity(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_set_type__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetType" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetType" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  (arg1)->SetType(arg2);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_set_type__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetType" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__string,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetType" "', argument " "2"" of type '" "std::string &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetType" "', argument " "2"" of type '" "std::string &""'"); 
  }
  arg2 = reinterpret_cast< std::string * >(argp2);
  (arg1)->SetType(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBAtom_set_type(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__string, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBAtom_set_type__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBAtom_set_type__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBAtom_set_type'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_set_partial_charge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetPartialCharge" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetPartialCharge" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  (arg1)->SetPartialCharge(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_set_vector__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetVector" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetVector" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetVector" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  (arg1)->SetVector((OpenBabel::vector3 const &)*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_set_vector__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  double arg2 ;
  double arg3 ;
  double arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetVector" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetVector" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SetVector" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  ecode4 = SWIG_AsVal_double(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "SetVector" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = static_cast< double >(val4);
  (arg1)->SetVector(arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_set_coord_ptr(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  double **arg2 = (double **) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetCoordPtr" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetCoordPtr" "', argument " "2"" of type '" "double **""'"); 
  }
  arg2 = reinterpret_cast< double ** >(argp2);
  (arg1)->SetCoordPtr(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_set_vector__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetVector" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  (arg1)->SetVector();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBAtom_set_vector(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBAtom_set_vector__SWIG_2(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__vector3, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBAtom_set_vector__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_double(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_OBAtom_set_vector__SWIG_1(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBAtom_set_vector'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_set_residue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBResidue *arg2 = (OpenBabel::OBResidue *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetResidue" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetResidue" "', argument " "2"" of type '" "OpenBabel::OBResidue *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBResidue * >(argp2);
  (arg1)->SetResidue(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_set_parent(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBMol *arg2 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetParent" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetParent" "', argument " "2"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2);
  (arg1)->SetParent(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_set_aromatic(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetAromatic" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  (arg1)->SetAromatic();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_unset_aromatic(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnsetAromatic" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  (arg1)->UnsetAromatic();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_set_clockwise_stereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetClockwiseStereo" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  (arg1)->SetClockwiseStereo();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_set_anti_clockwise_stereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetAntiClockwiseStereo" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  (arg1)->SetAntiClockwiseStereo();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_set_positive_stereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetPositiveStereo" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  (arg1)->SetPositiveStereo();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_set_negative_stereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetNegativeStereo" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  (arg1)->SetNegativeStereo();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_unset_stereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnsetStereo" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  (arg1)->UnsetStereo();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_set_in_ring(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetInRing" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  (arg1)->SetInRing();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_set_chiral(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetChiral" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  (arg1)->SetChiral();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_clear_coord_ptr(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ClearCoordPtr" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  (arg1)->ClearCoordPtr();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_get_formal_charge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetFormalCharge" "', argument " "1"" of type '" "OpenBabel::OBAtom const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (int)((OpenBabel::OBAtom const *)arg1)->GetFormalCharge();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_get_atomic_num(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAtomicNum" "', argument " "1"" of type '" "OpenBabel::OBAtom const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (unsigned int)((OpenBabel::OBAtom const *)arg1)->GetAtomicNum();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_get_isotope(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  unsigned short result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetIsotope" "', argument " "1"" of type '" "OpenBabel::OBAtom const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (unsigned short)((OpenBabel::OBAtom const *)arg1)->GetIsotope();
  vresult = SWIG_From_unsigned_SS_short(static_cast< unsigned short >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_get_spin_multiplicity(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetSpinMultiplicity" "', argument " "1"" of type '" "OpenBabel::OBAtom const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (int)((OpenBabel::OBAtom const *)arg1)->GetSpinMultiplicity();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_get_atomic_mass(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAtomicMass" "', argument " "1"" of type '" "OpenBabel::OBAtom const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (double)((OpenBabel::OBAtom const *)arg1)->GetAtomicMass();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_get_exact_mass(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetExactMass" "', argument " "1"" of type '" "OpenBabel::OBAtom const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (double)((OpenBabel::OBAtom const *)arg1)->GetExactMass();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_get_idx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetIdx" "', argument " "1"" of type '" "OpenBabel::OBAtom const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (unsigned int)((OpenBabel::OBAtom const *)arg1)->GetIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_get_coordinate_idx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetCoordinateIdx" "', argument " "1"" of type '" "OpenBabel::OBAtom const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (unsigned int)((OpenBabel::OBAtom const *)arg1)->GetCoordinateIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_get_cidx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetCIdx" "', argument " "1"" of type '" "OpenBabel::OBAtom const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (unsigned int)((OpenBabel::OBAtom const *)arg1)->GetCIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_get_valence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetValence" "', argument " "1"" of type '" "OpenBabel::OBAtom const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (unsigned int)((OpenBabel::OBAtom const *)arg1)->GetValence();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_get_hyb(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetHyb" "', argument " "1"" of type '" "OpenBabel::OBAtom const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (unsigned int)((OpenBabel::OBAtom const *)arg1)->GetHyb();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_get_implicit_valence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetImplicitValence" "', argument " "1"" of type '" "OpenBabel::OBAtom const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (unsigned int)((OpenBabel::OBAtom const *)arg1)->GetImplicitValence();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_get_hvy_valence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetHvyValence" "', argument " "1"" of type '" "OpenBabel::OBAtom const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (unsigned int)((OpenBabel::OBAtom const *)arg1)->GetHvyValence();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_get_hetero_valence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetHeteroValence" "', argument " "1"" of type '" "OpenBabel::OBAtom const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (unsigned int)((OpenBabel::OBAtom const *)arg1)->GetHeteroValence();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_get_type(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  char *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetType" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (char *)(arg1)->GetType();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_get_x(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetX" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (double)(arg1)->GetX();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_get_y(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetY" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (double)(arg1)->GetY();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_get_z(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetZ" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (double)(arg1)->GetZ();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_x(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "x" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (double)(arg1)->x();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_y(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "y" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (double)(arg1)->y();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_z(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "z" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (double)(arg1)->z();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_get_coordinate(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  double *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetCoordinate" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (double *)(arg1)->GetCoordinate();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_get_vector__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::vector3 *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetVector" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  {
    OpenBabel::vector3 &_result_ref = (arg1)->GetVector();
    result = (OpenBabel::vector3 *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_get_vector__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::vector3 *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetVector" "', argument " "1"" of type '" "OpenBabel::OBAtom const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  {
    OpenBabel::vector3 const &_result_ref = ((OpenBabel::OBAtom const *)arg1)->GetVector();
    result = (OpenBabel::vector3 *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBAtom_get_vector(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBAtom_get_vector__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBAtom_get_vector__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBAtom_get_vector'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_get_partial_charge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetPartialCharge" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (double)(arg1)->GetPartialCharge();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_get_residue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBResidue *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetResidue" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (OpenBabel::OBResidue *)(arg1)->GetResidue();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_get_parent(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBMol *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetParent" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (OpenBabel::OBMol *)(arg1)->GetParent();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_get_new_bond_vector(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  double arg3 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetNewBondVector" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetNewBondVector" "', argument " "2"" of type '" "OpenBabel::vector3 &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GetNewBondVector" "', argument " "2"" of type '" "OpenBabel::vector3 &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  ecode3 = SWIG_AsVal_double(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "GetNewBondVector" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  result = (bool)(arg1)->GetNewBondVector(*arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_get_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBBond *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetBond" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetBond" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (OpenBabel::OBBond *)(arg1)->GetBond(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_get_next_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetNextAtom" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (OpenBabel::OBAtom *)(arg1)->GetNextAtom();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_begin_bonds(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBBond * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginBonds" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (arg1)->BeginBonds();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBBondIterator(static_cast< const OpenBabel::OBBondIterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_end_bonds(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBBond * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EndBonds" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (arg1)->EndBonds();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBBondIterator(static_cast< const OpenBabel::OBBondIterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_begin_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBBondIterator *arg2 = 0 ;
  OpenBabel::OBBond *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginBond" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "BeginBond" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "BeginBond" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2);
  result = (OpenBabel::OBBond *)(arg1)->BeginBond(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_next_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBBondIterator *arg2 = 0 ;
  OpenBabel::OBBond *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NextBond" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "NextBond" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "NextBond" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2);
  result = (OpenBabel::OBBond *)(arg1)->NextBond(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_begin_nbr_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBBondIterator *arg2 = 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginNbrAtom" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "BeginNbrAtom" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "BeginNbrAtom" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2);
  result = (OpenBabel::OBAtom *)(arg1)->BeginNbrAtom(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_next_nbr_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBBondIterator *arg2 = 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NextNbrAtom" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "NextNbrAtom" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "NextNbrAtom" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2);
  result = (OpenBabel::OBAtom *)(arg1)->NextNbrAtom(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_get_distance__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  int arg2 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetDistance" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetDistance" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (double)(arg1)->GetDistance(arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_get_distance__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetDistance" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetDistance" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (double)(arg1)->GetDistance(arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBAtom_get_distance(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBAtom_get_distance__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBAtom_get_distance__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBAtom_get_distance'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_get_angle__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  int arg2 ;
  int arg3 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAngle" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetAngle" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "GetAngle" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  result = (double)(arg1)->GetAngle(arg2,arg3);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_get_angle__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg3 = (OpenBabel::OBAtom *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAngle" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetAngle" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "GetAngle" "', argument " "3"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBAtom * >(argp3);
  result = (double)(arg1)->GetAngle(arg2,arg3);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBAtom_get_angle(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_OBAtom_get_angle__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_OBAtom_get_angle__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBAtom_get_angle'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_new_residue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NewResidue" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  (arg1)->NewResidue();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_add_residue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBResidue *arg2 = (OpenBabel::OBResidue *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AddResidue" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AddResidue" "', argument " "2"" of type '" "OpenBabel::OBResidue *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBResidue * >(argp2);
  (arg1)->AddResidue(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_delete_residue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteResidue" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  (arg1)->DeleteResidue();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_add_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBBond *arg2 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AddBond" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AddBond" "', argument " "2"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBond * >(argp2);
  (arg1)->AddBond(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_insert_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBBondIterator *arg2 = 0 ;
  OpenBabel::OBBond *arg3 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InsertBond" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InsertBond" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InsertBond" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "InsertBond" "', argument " "3"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBBond * >(argp3);
  (arg1)->InsertBond(*arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_delete_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBBond *arg2 = (OpenBabel::OBBond *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteBond" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DeleteBond" "', argument " "2"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBond * >(argp2);
  result = (bool)(arg1)->DeleteBond(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_clear_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ClearBond" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  (arg1)->ClearBond();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_hto_methyl(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HtoMethyl" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (bool)(arg1)->HtoMethyl();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_set_hyb_and_geom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetHybAndGeom" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetHybAndGeom" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (bool)(arg1)->SetHybAndGeom(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_force_no_h(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ForceNoH" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  (arg1)->ForceNoH();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_has_no_hforced(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasNoHForced" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (bool)(arg1)->HasNoHForced();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_count_free_oxygens(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CountFreeOxygens" "', argument " "1"" of type '" "OpenBabel::OBAtom const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (unsigned int)((OpenBabel::OBAtom const *)arg1)->CountFreeOxygens();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_implicit_hydrogen_count(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ImplicitHydrogenCount" "', argument " "1"" of type '" "OpenBabel::OBAtom const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (unsigned int)((OpenBabel::OBAtom const *)arg1)->ImplicitHydrogenCount();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_explicit_hydrogen_count__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool arg2 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ExplicitHydrogenCount" "', argument " "1"" of type '" "OpenBabel::OBAtom const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ExplicitHydrogenCount" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (unsigned int)((OpenBabel::OBAtom const *)arg1)->ExplicitHydrogenCount(arg2);
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_explicit_hydrogen_count__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ExplicitHydrogenCount" "', argument " "1"" of type '" "OpenBabel::OBAtom const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (unsigned int)((OpenBabel::OBAtom const *)arg1)->ExplicitHydrogenCount();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBAtom_explicit_hydrogen_count(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBAtom_explicit_hydrogen_count__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBAtom_explicit_hydrogen_count__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBAtom_explicit_hydrogen_count'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_member_of_ring_count(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MemberOfRingCount" "', argument " "1"" of type '" "OpenBabel::OBAtom const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (unsigned int)((OpenBabel::OBAtom const *)arg1)->MemberOfRingCount();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_member_of_ring_size(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MemberOfRingSize" "', argument " "1"" of type '" "OpenBabel::OBAtom const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (unsigned int)((OpenBabel::OBAtom const *)arg1)->MemberOfRingSize();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_count_ring_bonds(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CountRingBonds" "', argument " "1"" of type '" "OpenBabel::OBAtom const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (unsigned int)((OpenBabel::OBAtom const *)arg1)->CountRingBonds();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_smallest_bond_angle(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SmallestBondAngle" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (double)(arg1)->SmallestBondAngle();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_average_bond_angle(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AverageBondAngle" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (double)(arg1)->AverageBondAngle();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_bosum(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BOSum" "', argument " "1"" of type '" "OpenBabel::OBAtom const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (unsigned int)((OpenBabel::OBAtom const *)arg1)->BOSum();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_kbosum(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KBOSum" "', argument " "1"" of type '" "OpenBabel::OBAtom const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (unsigned int)((OpenBabel::OBAtom const *)arg1)->KBOSum();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_has_residue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasResidue" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (bool)(arg1)->HasResidue();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_is_hydrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsHydrogen" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (bool)(arg1)->IsHydrogen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_is_carbon(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsCarbon" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (bool)(arg1)->IsCarbon();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_is_nitrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsNitrogen" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (bool)(arg1)->IsNitrogen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_is_oxygen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsOxygen" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (bool)(arg1)->IsOxygen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_is_sulfur(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsSulfur" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (bool)(arg1)->IsSulfur();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_is_phosphorus(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsPhosphorus" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (bool)(arg1)->IsPhosphorus();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_is_aromatic(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsAromatic" "', argument " "1"" of type '" "OpenBabel::OBAtom const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (bool)((OpenBabel::OBAtom const *)arg1)->IsAromatic();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_is_in_ring(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsInRing" "', argument " "1"" of type '" "OpenBabel::OBAtom const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (bool)((OpenBabel::OBAtom const *)arg1)->IsInRing();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_is_in_ring_size(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsInRingSize" "', argument " "1"" of type '" "OpenBabel::OBAtom const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IsInRingSize" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (bool)((OpenBabel::OBAtom const *)arg1)->IsInRingSize(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_is_heteroatom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsHeteroatom" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (bool)(arg1)->IsHeteroatom();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_is_not_cor_h(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsNotCorH" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (bool)(arg1)->IsNotCorH();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_is_connected(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsConnected" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "IsConnected" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (bool)(arg1)->IsConnected(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_is_one_three(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsOneThree" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "IsOneThree" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (bool)(arg1)->IsOneThree(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_is_one_four(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsOneFour" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "IsOneFour" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (bool)(arg1)->IsOneFour(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_is_carboxyl_oxygen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsCarboxylOxygen" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (bool)(arg1)->IsCarboxylOxygen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_is_phosphate_oxygen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsPhosphateOxygen" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (bool)(arg1)->IsPhosphateOxygen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_is_sulfate_oxygen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsSulfateOxygen" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (bool)(arg1)->IsSulfateOxygen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_is_nitro_oxygen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsNitroOxygen" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (bool)(arg1)->IsNitroOxygen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_is_amide_nitrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsAmideNitrogen" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (bool)(arg1)->IsAmideNitrogen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_is_polar_hydrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsPolarHydrogen" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (bool)(arg1)->IsPolarHydrogen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_is_non_polar_hydrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsNonPolarHydrogen" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (bool)(arg1)->IsNonPolarHydrogen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_is_aromatic_noxide(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsAromaticNOxide" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (bool)(arg1)->IsAromaticNOxide();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_is_chiral(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsChiral" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (bool)(arg1)->IsChiral();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_is_axial(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsAxial" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (bool)(arg1)->IsAxial();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_is_clockwise(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsClockwise" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (bool)(arg1)->IsClockwise();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_is_anti_clockwise(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsAntiClockwise" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (bool)(arg1)->IsAntiClockwise();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_is_positive_stereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsPositiveStereo" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (bool)(arg1)->IsPositiveStereo();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_is_negative_stereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsNegativeStereo" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (bool)(arg1)->IsNegativeStereo();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_has_chirality_specified(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasChiralitySpecified" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (bool)(arg1)->HasChiralitySpecified();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_has_chiral_volume(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasChiralVolume" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (bool)(arg1)->HasChiralVolume();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_is_hbond_acceptor(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsHbondAcceptor" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (bool)(arg1)->IsHbondAcceptor();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_is_hbond_donor(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsHbondDonor" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (bool)(arg1)->IsHbondDonor();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_is_hbond_donor_h(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsHbondDonorH" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (bool)(arg1)->IsHbondDonorH();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_has_alpha_beta_unsat__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasAlphaBetaUnsat" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "HasAlphaBetaUnsat" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (bool)(arg1)->HasAlphaBetaUnsat(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_has_alpha_beta_unsat__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasAlphaBetaUnsat" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (bool)(arg1)->HasAlphaBetaUnsat();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBAtom_has_alpha_beta_unsat(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBAtom_has_alpha_beta_unsat__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBAtom_has_alpha_beta_unsat__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBAtom_has_alpha_beta_unsat'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_has_bond_of_order(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  unsigned int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasBondOfOrder" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "HasBondOfOrder" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (bool)(arg1)->HasBondOfOrder(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_count_bonds_of_order(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  unsigned int arg2 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CountBondsOfOrder" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CountBondsOfOrder" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (int)(arg1)->CountBondsOfOrder(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_has_non_single_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasNonSingleBond" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (bool)(arg1)->HasNonSingleBond();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_has_single_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasSingleBond" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (bool)(arg1)->HasSingleBond();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_has_double_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasDoubleBond" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (bool)(arg1)->HasDoubleBond();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_has_aromatic_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasAromaticBond" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (bool)(arg1)->HasAromaticBond();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtom_matches_smarts(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  char *arg2 = (char *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MatchesSMARTS" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MatchesSMARTS" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (bool)(arg1)->MatchesSMARTS((char const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


swig_class cOBBond;

SWIGINTERN VALUE
_wrap_OBBond_Visit_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Visit" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Visit" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  if (arg1) (arg1)->Visit = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_Visit_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Visit" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  result = (bool) ((arg1)->Visit);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBBond_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBBond_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBBond);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBBond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBBond *)new OpenBabel::OBBond();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBBond(OpenBabel::OBBond *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_OBBond_set_idx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetIdx" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetIdx" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->SetIdx(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_set_bo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetBO" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetBO" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->SetBO(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_set_bond_order(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetBondOrder" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetBondOrder" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->SetBondOrder(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_set_begin(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetBegin" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetBegin" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  (arg1)->SetBegin(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_set_end(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetEnd" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetEnd" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  (arg1)->SetEnd(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_set_parent(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  OpenBabel::OBMol *arg2 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetParent" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetParent" "', argument " "2"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2);
  (arg1)->SetParent(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_set_length(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetLength" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetLength" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  ecode3 = SWIG_AsVal_double(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SetLength" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  (arg1)->SetLength(arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  int arg2 ;
  OpenBabel::OBAtom *arg3 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg4 = (OpenBabel::OBAtom *) 0 ;
  int arg5 ;
  int arg6 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  
  if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Set" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Set" "', argument " "3"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBAtom * >(argp3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Set" "', argument " "4"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg4 = reinterpret_cast< OpenBabel::OBAtom * >(argp4);
  ecode5 = SWIG_AsVal_int(argv[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Set" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = static_cast< int >(val5);
  ecode6 = SWIG_AsVal_int(argv[4], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "Set" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = static_cast< int >(val6);
  (arg1)->Set(arg2,arg3,arg4,arg5,arg6);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_set_ksingle(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetKSingle" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  (arg1)->SetKSingle();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_set_kdouble(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetKDouble" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  (arg1)->SetKDouble();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_set_ktriple(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetKTriple" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  (arg1)->SetKTriple();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_set_aromatic(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetAromatic" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  (arg1)->SetAromatic();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_set_hash(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetHash" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  (arg1)->SetHash();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_set_wedge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetWedge" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  (arg1)->SetWedge();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_set_up(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetUp" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  (arg1)->SetUp();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_set_down(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetDown" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  (arg1)->SetDown();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_set_in_ring(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetInRing" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  (arg1)->SetInRing();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_set_closure(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetClosure" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  (arg1)->SetClosure();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_unset_hash(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnsetHash" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  (arg1)->UnsetHash();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_unset_wedge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnsetWedge" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  (arg1)->UnsetWedge();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_unset_up(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnsetUp" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  (arg1)->UnsetUp();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_unset_down(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnsetDown" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  (arg1)->UnsetDown();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_unset_aromatic(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnsetAromatic" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  (arg1)->UnsetAromatic();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_unset_kekule(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnsetKekule" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  (arg1)->UnsetKekule();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_get_idx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetIdx" "', argument " "1"" of type '" "OpenBabel::OBBond const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  result = (unsigned int)((OpenBabel::OBBond const *)arg1)->GetIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_get_bo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetBO" "', argument " "1"" of type '" "OpenBabel::OBBond const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  result = (unsigned int)((OpenBabel::OBBond const *)arg1)->GetBO();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_get_bond_order(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetBondOrder" "', argument " "1"" of type '" "OpenBabel::OBBond const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  result = (unsigned int)((OpenBabel::OBBond const *)arg1)->GetBondOrder();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_get_flags(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetFlags" "', argument " "1"" of type '" "OpenBabel::OBBond const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  result = (unsigned int)((OpenBabel::OBBond const *)arg1)->GetFlags();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_get_begin_atom_idx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetBeginAtomIdx" "', argument " "1"" of type '" "OpenBabel::OBBond const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  result = (unsigned int)((OpenBabel::OBBond const *)arg1)->GetBeginAtomIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_get_end_atom_idx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetEndAtomIdx" "', argument " "1"" of type '" "OpenBabel::OBBond const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  result = (unsigned int)((OpenBabel::OBBond const *)arg1)->GetEndAtomIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_get_begin_atom__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetBeginAtom" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  result = (OpenBabel::OBAtom *)(arg1)->GetBeginAtom();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_get_begin_atom__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetBeginAtom" "', argument " "1"" of type '" "OpenBabel::OBBond const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  result = (OpenBabel::OBAtom *)((OpenBabel::OBBond const *)arg1)->GetBeginAtom();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBBond_get_begin_atom(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBBond, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBBond_get_begin_atom__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBBond, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBBond_get_begin_atom__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBBond_get_begin_atom'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_get_end_atom__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetEndAtom" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  result = (OpenBabel::OBAtom *)(arg1)->GetEndAtom();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_get_end_atom__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetEndAtom" "', argument " "1"" of type '" "OpenBabel::OBBond const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  result = (OpenBabel::OBAtom *)((OpenBabel::OBBond const *)arg1)->GetEndAtom();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBBond_get_end_atom(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBBond, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBBond_get_end_atom__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBBond, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBBond_get_end_atom__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBBond_get_end_atom'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_get_nbr_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetNbrAtom" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetNbrAtom" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (OpenBabel::OBAtom *)(arg1)->GetNbrAtom(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_get_parent(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  OpenBabel::OBMol *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetParent" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  result = (OpenBabel::OBMol *)(arg1)->GetParent();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_get_equib_length(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetEquibLength" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  result = (double)(arg1)->GetEquibLength();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_get_length(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetLength" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  result = (double)(arg1)->GetLength();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_get_nbr_atom_idx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetNbrAtomIdx" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetNbrAtomIdx" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (unsigned int)(arg1)->GetNbrAtomIdx(arg2);
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_is_aromatic(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsAromatic" "', argument " "1"" of type '" "OpenBabel::OBBond const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  result = (bool)((OpenBabel::OBBond const *)arg1)->IsAromatic();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_is_in_ring(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsInRing" "', argument " "1"" of type '" "OpenBabel::OBBond const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  result = (bool)((OpenBabel::OBBond const *)arg1)->IsInRing();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_is_rotor(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsRotor" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  result = (bool)(arg1)->IsRotor();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_is_amide(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsAmide" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  result = (bool)(arg1)->IsAmide();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_is_primary_amide(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsPrimaryAmide" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  result = (bool)(arg1)->IsPrimaryAmide();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_is_secondary_amide(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsSecondaryAmide" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  result = (bool)(arg1)->IsSecondaryAmide();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_is_ester(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsEster" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  result = (bool)(arg1)->IsEster();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_is_carbonyl(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsCarbonyl" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  result = (bool)(arg1)->IsCarbonyl();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_is_single(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsSingle" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  result = (bool)(arg1)->IsSingle();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_is_double(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsDouble" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  result = (bool)(arg1)->IsDouble();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_is_triple(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsTriple" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  result = (bool)(arg1)->IsTriple();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_is_ksingle(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsKSingle" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  result = (bool)(arg1)->IsKSingle();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_is_kdouble(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsKDouble" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  result = (bool)(arg1)->IsKDouble();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_is_ktriple(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsKTriple" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  result = (bool)(arg1)->IsKTriple();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_is_closure(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsClosure" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  result = (bool)(arg1)->IsClosure();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_is_up(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsUp" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  result = (bool)(arg1)->IsUp();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_is_down(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsDown" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  result = (bool)(arg1)->IsDown();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_is_wedge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsWedge" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  result = (bool)(arg1)->IsWedge();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_is_hash(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsHash" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  result = (bool)(arg1)->IsHash();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBBond_is_double_bond_geometry(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsDoubleBondGeometry" "', argument " "1"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  result = (bool)(arg1)->IsDoubleBondGeometry();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


swig_class cOBMol;

SWIGINTERN VALUE
_wrap_new_OBMol__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBMol *)new OpenBabel::OBMol();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBMol_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBMol_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBMol);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBMol__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = 0 ;
  OpenBabel::OBMol *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBMol,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBMol" "', argument " "1"" of type '" "OpenBabel::OBMol const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBMol" "', argument " "1"" of type '" "OpenBabel::OBMol const &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (OpenBabel::OBMol *)new OpenBabel::OBMol((OpenBabel::OBMol const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_OBMol(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_OBMol__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBMol__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_OBMol'");
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBMol(OpenBabel::OBMol *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_OBMol_reserve_atoms(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ReserveAtoms" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ReserveAtoms" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->ReserveAtoms(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_create_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CreateAtom" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (OpenBabel::OBAtom *)(arg1)->CreateAtom();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_create_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBBond *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CreateBond" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (OpenBabel::OBBond *)(arg1)->CreateBond();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_create_residue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBResidue *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CreateResidue" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (OpenBabel::OBResidue *)(arg1)->CreateResidue();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_destroy_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DestroyAtom" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DestroyAtom" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  (arg1)->DestroyAtom(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_destroy_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBBond *arg2 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DestroyBond" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DestroyBond" "', argument " "2"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBond * >(argp2);
  (arg1)->DestroyBond(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_destroy_residue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBResidue *arg2 = (OpenBabel::OBResidue *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DestroyResidue" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DestroyResidue" "', argument " "2"" of type '" "OpenBabel::OBResidue *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBResidue * >(argp2);
  (arg1)->DestroyResidue(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_add_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBAtom *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AddAtom" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBAtom,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AddAtom" "', argument " "2"" of type '" "OpenBabel::OBAtom &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "AddAtom" "', argument " "2"" of type '" "OpenBabel::OBAtom &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (bool)(arg1)->AddAtom(*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_insert_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBAtom *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InsertAtom" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBAtom,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InsertAtom" "', argument " "2"" of type '" "OpenBabel::OBAtom &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InsertAtom" "', argument " "2"" of type '" "OpenBabel::OBAtom &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (bool)(arg1)->InsertAtom(*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_add_bond__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  int arg5 ;
  int arg6 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AddBond" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "AddBond" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "AddBond" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  ecode4 = SWIG_AsVal_int(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "AddBond" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = static_cast< int >(val4);
  ecode5 = SWIG_AsVal_int(argv[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "AddBond" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = static_cast< int >(val5);
  ecode6 = SWIG_AsVal_int(argv[4], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "AddBond" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = static_cast< int >(val6);
  result = (bool)(arg1)->AddBond(arg2,arg3,arg4,arg5,arg6);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_add_bond__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  int arg5 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AddBond" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "AddBond" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "AddBond" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  ecode4 = SWIG_AsVal_int(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "AddBond" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = static_cast< int >(val4);
  ecode5 = SWIG_AsVal_int(argv[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "AddBond" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = static_cast< int >(val5);
  result = (bool)(arg1)->AddBond(arg2,arg3,arg4,arg5);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_add_bond__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AddBond" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "AddBond" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "AddBond" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  ecode4 = SWIG_AsVal_int(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "AddBond" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = static_cast< int >(val4);
  result = (bool)(arg1)->AddBond(arg2,arg3,arg4);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_add_bond__SWIG_3(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBBond *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AddBond" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBBond,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AddBond" "', argument " "2"" of type '" "OpenBabel::OBBond &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "AddBond" "', argument " "2"" of type '" "OpenBabel::OBBond &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBond * >(argp2);
  result = (bool)(arg1)->AddBond(*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMol_add_bond(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[7];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 7) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBBond, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMol_add_bond__SWIG_3(nargs, args, self);
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_OBMol_add_bond__SWIG_2(nargs, args, self);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            {
              int res = SWIG_AsVal_int(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              return _wrap_OBMol_add_bond__SWIG_1(nargs, args, self);
            }
          }
        }
      }
    }
  }
  if (argc == 6) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            {
              int res = SWIG_AsVal_int(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              {
                int res = SWIG_AsVal_int(argv[5], NULL);
                _v = SWIG_CheckState(res);
              }
              if (_v) {
                return _wrap_OBMol_add_bond__SWIG_0(nargs, args, self);
              }
            }
          }
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMol_add_bond'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_add_residue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBResidue *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AddResidue" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBResidue,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AddResidue" "', argument " "2"" of type '" "OpenBabel::OBResidue &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "AddResidue" "', argument " "2"" of type '" "OpenBabel::OBResidue &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBResidue * >(argp2);
  result = (bool)(arg1)->AddResidue(*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_new_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NewAtom" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (OpenBabel::OBAtom *)(arg1)->NewAtom();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_new_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBBond *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NewBond" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (OpenBabel::OBBond *)(arg1)->NewBond();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_new_residue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBResidue *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NewResidue" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (OpenBabel::OBResidue *)(arg1)->NewResidue();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_delete_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteAtom" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DeleteAtom" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (bool)(arg1)->DeleteAtom(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_delete_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBBond *arg2 = (OpenBabel::OBBond *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteBond" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DeleteBond" "', argument " "2"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBond * >(argp2);
  result = (bool)(arg1)->DeleteBond(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_delete_residue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBResidue *arg2 = (OpenBabel::OBResidue *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteResidue" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DeleteResidue" "', argument " "2"" of type '" "OpenBabel::OBResidue *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBResidue * >(argp2);
  result = (bool)(arg1)->DeleteResidue(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_begin_modify(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginModify" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  (arg1)->BeginModify();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_end_modify__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EndModify" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "EndModify" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  (arg1)->EndModify(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_end_modify__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EndModify" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  (arg1)->EndModify();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMol_end_modify(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBMol_end_modify__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBMol_end_modify__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMol_end_modify'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_get_mod(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetMod" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (int)(arg1)->GetMod();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_increment_mod(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IncrementMod" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  (arg1)->IncrementMod();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_decrement_mod(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DecrementMod" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  (arg1)->DecrementMod();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_get_flags(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetFlags" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (int)(arg1)->GetFlags();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_get_title(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  char *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetTitle" "', argument " "1"" of type '" "OpenBabel::OBMol const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (char *)((OpenBabel::OBMol const *)arg1)->GetTitle();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_num_atoms(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NumAtoms" "', argument " "1"" of type '" "OpenBabel::OBMol const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (unsigned int)((OpenBabel::OBMol const *)arg1)->NumAtoms();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_num_bonds(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NumBonds" "', argument " "1"" of type '" "OpenBabel::OBMol const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (unsigned int)((OpenBabel::OBMol const *)arg1)->NumBonds();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_num_hvy_atoms(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NumHvyAtoms" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (unsigned int)(arg1)->NumHvyAtoms();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_num_residues(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NumResidues" "', argument " "1"" of type '" "OpenBabel::OBMol const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (unsigned int)((OpenBabel::OBMol const *)arg1)->NumResidues();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_num_rotors(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NumRotors" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (unsigned int)(arg1)->NumRotors();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_get_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  int arg2 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAtom" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetAtom" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (OpenBabel::OBAtom *)(arg1)->GetAtom(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_get_first_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetFirstAtom" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (OpenBabel::OBAtom *)(arg1)->GetFirstAtom();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_get_bond__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  int arg2 ;
  OpenBabel::OBBond *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetBond" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetBond" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (OpenBabel::OBBond *)(arg1)->GetBond(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_get_bond__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  int arg2 ;
  int arg3 ;
  OpenBabel::OBBond *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetBond" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetBond" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "GetBond" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  result = (OpenBabel::OBBond *)(arg1)->GetBond(arg2,arg3);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_get_bond__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg3 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBBond *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetBond" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetBond" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "GetBond" "', argument " "3"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBAtom * >(argp3);
  result = (OpenBabel::OBBond *)(arg1)->GetBond(arg2,arg3);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMol_get_bond(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBMol_get_bond__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_OBMol_get_bond__SWIG_2(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_OBMol_get_bond__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMol_get_bond'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_get_residue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  int arg2 ;
  OpenBabel::OBResidue *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetResidue" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetResidue" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (OpenBabel::OBResidue *)(arg1)->GetResidue(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_get_internal_coord(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBInternalCoord * > > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetInternalCoord" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (arg1)->GetInternalCoord();
  vresult = SWIG_NewPointerObj((new std::vector<OpenBabel::OBInternalCoord * >(static_cast< const std::vector<OpenBabel::OBInternalCoord * >& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBInternalCoord_p_t, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_get_torsion__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  int arg5 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetTorsion" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetTorsion" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "GetTorsion" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  ecode4 = SWIG_AsVal_int(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "GetTorsion" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = static_cast< int >(val4);
  ecode5 = SWIG_AsVal_int(argv[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "GetTorsion" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = static_cast< int >(val5);
  result = (double)(arg1)->GetTorsion(arg2,arg3,arg4,arg5);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_get_torsion__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg3 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg4 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg5 = (OpenBabel::OBAtom *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetTorsion" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetTorsion" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "GetTorsion" "', argument " "3"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBAtom * >(argp3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "GetTorsion" "', argument " "4"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg4 = reinterpret_cast< OpenBabel::OBAtom * >(argp4);
  res5 = SWIG_ConvertPtr(argv[3], &argp5,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "GetTorsion" "', argument " "5"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg5 = reinterpret_cast< OpenBabel::OBAtom * >(argp5);
  result = (double)(arg1)->GetTorsion(arg2,arg3,arg4,arg5);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMol_get_torsion(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[6];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 6) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 5) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            void *vptr = 0;
            int res = SWIG_ConvertPtr(argv[4], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
            _v = SWIG_CheckState(res);
            if (_v) {
              return _wrap_OBMol_get_torsion__SWIG_1(nargs, args, self);
            }
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            {
              int res = SWIG_AsVal_int(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              return _wrap_OBMol_get_torsion__SWIG_0(nargs, args, self);
            }
          }
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMol_get_torsion'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_get_angle(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg3 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg4 = (OpenBabel::OBAtom *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAngle" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetAngle" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "GetAngle" "', argument " "3"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBAtom * >(argp3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "GetAngle" "', argument " "4"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg4 = reinterpret_cast< OpenBabel::OBAtom * >(argp4);
  result = (double)(arg1)->GetAngle(arg2,arg3,arg4);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_get_formula(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetFormula" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (arg1)->GetFormula();
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_get_spaced_formula__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  int arg2 ;
  char *arg3 = (char *) 0 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetSpacedFormula" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetSpacedFormula" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  res3 = SWIG_AsCharPtrAndSize(argv[1], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "GetSpacedFormula" "', argument " "3"" of type '" "char const *""'");
  }
  arg3 = reinterpret_cast< char * >(buf3);
  result = (arg1)->GetSpacedFormula(arg2,(char const *)arg3);
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return vresult;
fail:
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_get_spaced_formula__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  int arg2 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetSpacedFormula" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetSpacedFormula" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (arg1)->GetSpacedFormula(arg2);
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_get_spaced_formula__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetSpacedFormula" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (arg1)->GetSpacedFormula();
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMol_get_spaced_formula(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBMol_get_spaced_formula__SWIG_2(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBMol_get_spaced_formula__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_OBMol_get_spaced_formula__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMol_get_spaced_formula'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_get_energy(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetEnergy" "', argument " "1"" of type '" "OpenBabel::OBMol const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (double)((OpenBabel::OBMol const *)arg1)->GetEnergy();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_get_mol_wt(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetMolWt" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (double)(arg1)->GetMolWt();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_get_exact_mass(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetExactMass" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (double)(arg1)->GetExactMass();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_get_total_charge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetTotalCharge" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (int)(arg1)->GetTotalCharge();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_get_total_spin_multiplicity(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetTotalSpinMultiplicity" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (unsigned int)(arg1)->GetTotalSpinMultiplicity();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_get_dimension(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  unsigned short result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetDimension" "', argument " "1"" of type '" "OpenBabel::OBMol const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (unsigned short)((OpenBabel::OBMol const *)arg1)->GetDimension();
  vresult = SWIG_From_unsigned_SS_short(static_cast< unsigned short >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_get_coordinates(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  double *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetCoordinates" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (double *)(arg1)->GetCoordinates();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_get_sssr(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  std::vector<OpenBabel::OBRing * > *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetSSSR" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  {
    std::vector<OpenBabel::OBRing * > &_result_ref = (arg1)->GetSSSR();
    result = (std::vector<OpenBabel::OBRing * > *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorTOpenBabel__OBRing_p_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_automatic_formal_charge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AutomaticFormalCharge" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (bool)(arg1)->AutomaticFormalCharge();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_automatic_partial_charge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AutomaticPartialCharge" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (bool)(arg1)->AutomaticPartialCharge();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_set_title__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetTitle" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetTitle" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  (arg1)->SetTitle((char const *)arg2);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_set_title__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetTitle" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__string,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetTitle" "', argument " "2"" of type '" "std::string &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetTitle" "', argument " "2"" of type '" "std::string &""'"); 
  }
  arg2 = reinterpret_cast< std::string * >(argp2);
  (arg1)->SetTitle(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMol_set_title(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__string, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMol_set_title__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMol_set_title__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMol_set_title'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_set_formula(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  std::string arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetFormula" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "SetFormula" "', argument " "2"" of type '" "std::string""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  (arg1)->SetFormula(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_set_energy(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetEnergy" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetEnergy" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  (arg1)->SetEnergy(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_set_dimension(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  unsigned short arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned short val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetDimension" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_short(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetDimension" "', argument " "2"" of type '" "unsigned short""'");
  } 
  arg2 = static_cast< unsigned short >(val2);
  (arg1)->SetDimension(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_set_total_charge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetTotalCharge" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetTotalCharge" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->SetTotalCharge(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_set_total_spin_multiplicity(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetTotalSpinMultiplicity" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetTotalSpinMultiplicity" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  (arg1)->SetTotalSpinMultiplicity(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_set_internal_coord(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBInternalCoord * > > arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetInternalCoord" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBInternalCoord_p_t,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetInternalCoord" "', argument " "2"" of type '" "std::vector<OpenBabel::OBInternalCoord * >""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetInternalCoord" "', argument " "2"" of type '" "std::vector<OpenBabel::OBInternalCoord * >""'");
    } else {
      arg2 = *(reinterpret_cast< std::vector<OpenBabel::OBInternalCoord * > * >(argp2));
    }
  }
  (arg1)->SetInternalCoord(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_set_automatic_formal_charge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetAutomaticFormalCharge" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetAutomaticFormalCharge" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  (arg1)->SetAutomaticFormalCharge(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_set_automatic_partial_charge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetAutomaticPartialCharge" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetAutomaticPartialCharge" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  (arg1)->SetAutomaticPartialCharge(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_set_aromatic_perceived(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetAromaticPerceived" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  (arg1)->SetAromaticPerceived();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_set_sssrperceived(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetSSSRPerceived" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  (arg1)->SetSSSRPerceived();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_set_ring_atoms_and_bonds_perceived(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetRingAtomsAndBondsPerceived" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  (arg1)->SetRingAtomsAndBondsPerceived();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_set_atom_types_perceived(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetAtomTypesPerceived" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  (arg1)->SetAtomTypesPerceived();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_set_chains_perceived(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetChainsPerceived" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  (arg1)->SetChainsPerceived();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_set_chirality_perceived(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetChiralityPerceived" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  (arg1)->SetChiralityPerceived();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_set_partial_charges_perceived(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetPartialChargesPerceived" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  (arg1)->SetPartialChargesPerceived();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_set_hybridization_perceived(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetHybridizationPerceived" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  (arg1)->SetHybridizationPerceived();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_set_implicit_valence_perceived(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetImplicitValencePerceived" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  (arg1)->SetImplicitValencePerceived();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_set_kekule_perceived(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetKekulePerceived" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  (arg1)->SetKekulePerceived();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_set_closure_bonds_perceived(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetClosureBondsPerceived" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  (arg1)->SetClosureBondsPerceived();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_set_hydrogens_added(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetHydrogensAdded" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  (arg1)->SetHydrogensAdded();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_set_corrected_for_ph(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetCorrectedForPH" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  (arg1)->SetCorrectedForPH();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_set_aromatic_corrected(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetAromaticCorrected" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  (arg1)->SetAromaticCorrected();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_set_spin_multiplicity_assigned(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetSpinMultiplicityAssigned" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  (arg1)->SetSpinMultiplicityAssigned();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_set_flags(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetFlags" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetFlags" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->SetFlags(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_unset_aromatic_perceived(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnsetAromaticPerceived" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  (arg1)->UnsetAromaticPerceived();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_unset_partial_charges_perceived(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnsetPartialChargesPerceived" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  (arg1)->UnsetPartialChargesPerceived();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_unset_implicit_valence_perceived(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnsetImplicitValencePerceived" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  (arg1)->UnsetImplicitValencePerceived();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_unset_hydrogens_added(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnsetHydrogensAdded" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  (arg1)->UnsetHydrogensAdded();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_unset_flag(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnsetFlag" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "UnsetFlag" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->UnsetFlag(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_do_transformations(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  std::map<std::string,std::string > *arg2 = (std::map<std::string,std::string > *) 0 ;
  OpenBabel::OBBase *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DoTransformations" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_std__mapTstd__string_std__string_t, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DoTransformations" "', argument " "2"" of type '" "std::map<std::string,std::string > const *""'"); 
  }
  arg2 = reinterpret_cast< std::map<std::string,std::string > * >(argp2);
  result = (OpenBabel::OBBase *)(arg1)->DoTransformations((std::map<std::string,std::string > const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_class_description(int argc, VALUE *argv, VALUE self) {
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (char *)OpenBabel::OBMol::ClassDescription();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_clear(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Clear" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (bool)(arg1)->Clear();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_renumber_atoms(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  std::vector<OpenBabel::OBAtom * > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RenumberAtoms" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBAtom_p_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "RenumberAtoms" "', argument " "2"" of type '" "std::vector<OpenBabel::OBAtom * > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "RenumberAtoms" "', argument " "2"" of type '" "std::vector<OpenBabel::OBAtom * > &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<OpenBabel::OBAtom * > * >(argp2);
  (arg1)->RenumberAtoms(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_to_inertial_frame__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  int arg2 ;
  double *arg3 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ToInertialFrame" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ToInertialFrame" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "ToInertialFrame" "', argument " "3"" of type '" "double *""'"); 
  }
  arg3 = reinterpret_cast< double * >(argp3);
  (arg1)->ToInertialFrame(arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_to_inertial_frame__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ToInertialFrame" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  (arg1)->ToInertialFrame();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMol_to_inertial_frame(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBMol_to_inertial_frame__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_double, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_OBMol_to_inertial_frame__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMol_to_inertial_frame'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_translate__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Translate" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Translate" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Translate" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  (arg1)->Translate((OpenBabel::vector3 const &)*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_translate__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Translate" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Translate" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Translate" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Translate" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  (arg1)->Translate((OpenBabel::vector3 const &)*arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMol_translate(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__vector3, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMol_translate__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__vector3, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_OBMol_translate__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMol_translate'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_rotate__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  double (*arg2)[3] ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Rotate" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_a_3__double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Rotate" "', argument " "2"" of type '" "double const [3][3]""'"); 
  } 
  arg2 = reinterpret_cast< double (*)[3] >(argp2);
  (arg1)->Rotate((double const (*)[3])arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_rotate__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  double *arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Rotate" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Rotate" "', argument " "2"" of type '" "double const [9]""'"); 
  } 
  arg2 = reinterpret_cast< double * >(argp2);
  (arg1)->Rotate((double const (*))arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_rotate__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  double *arg2 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Rotate" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Rotate" "', argument " "2"" of type '" "double const [9]""'"); 
  } 
  arg2 = reinterpret_cast< double * >(argp2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Rotate" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  (arg1)->Rotate((double const (*))arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMol_rotate(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_a_3__double, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMol_rotate__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_double, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMol_rotate__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_double, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_OBMol_rotate__SWIG_2(nargs, args, self);
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMol_rotate'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_center__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Center" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  (arg1)->Center();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_kekulize(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Kekulize" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (bool)(arg1)->Kekulize();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_perceive_kekule_bonds(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PerceiveKekuleBonds" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (bool)(arg1)->PerceiveKekuleBonds();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_new_perceive_kekule_bonds(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NewPerceiveKekuleBonds" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  (arg1)->NewPerceiveKekuleBonds();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_delete_hydrogens__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteHydrogens" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (bool)(arg1)->DeleteHydrogens();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_delete_hydrogens__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteHydrogens" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DeleteHydrogens" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (bool)(arg1)->DeleteHydrogens(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMol_delete_hydrogens(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBMol_delete_hydrogens__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMol_delete_hydrogens__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMol_delete_hydrogens'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_delete_non_polar_hydrogens(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteNonPolarHydrogens" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (bool)(arg1)->DeleteNonPolarHydrogens();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_delete_hydrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteHydrogen" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DeleteHydrogen" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (bool)(arg1)->DeleteHydrogen(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_add_hydrogens__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  bool arg2 ;
  bool arg3 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AddHydrogens" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "AddHydrogens" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  ecode3 = SWIG_AsVal_bool(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "AddHydrogens" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  result = (bool)(arg1)->AddHydrogens(arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_add_hydrogens__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  bool arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AddHydrogens" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "AddHydrogens" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (bool)(arg1)->AddHydrogens(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_add_hydrogens__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AddHydrogens" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (bool)(arg1)->AddHydrogens();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_add_hydrogens__SWIG_3(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AddHydrogens" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AddHydrogens" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (bool)(arg1)->AddHydrogens(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMol_add_hydrogens(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBMol_add_hydrogens__SWIG_2(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMol_add_hydrogens__SWIG_3(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBMol_add_hydrogens__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_bool(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_OBMol_add_hydrogens__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMol_add_hydrogens'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_add_polar_hydrogens(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AddPolarHydrogens" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (bool)(arg1)->AddPolarHydrogens();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_strip_salts(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StripSalts" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (bool)(arg1)->StripSalts();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_separate__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  int arg2 ;
  std::vector<OpenBabel::OBMol > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Separate" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Separate" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (arg1)->Separate(arg2);
  {
    vresult = rb_ary_new2((&result)->size());
    for (unsigned int i=0; i<(&result)->size(); i++) {
      OpenBabel::OBMol* x = new OpenBabel::OBMol(((std::vector<OpenBabel::OBMol > &)result)[i]);
      rb_ary_store(vresult,i,
        SWIG_NewPointerObj((void *) x, 
          SWIGTYPE_p_OpenBabel__OBMol, 1));
    }
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_separate__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  std::vector<OpenBabel::OBMol > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Separate" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (arg1)->Separate();
  {
    vresult = rb_ary_new2((&result)->size());
    for (unsigned int i=0; i<(&result)->size(); i++) {
      OpenBabel::OBMol* x = new OpenBabel::OBMol(((std::vector<OpenBabel::OBMol > &)result)[i]);
      rb_ary_store(vresult,i,
        SWIG_NewPointerObj((void *) x, 
          SWIGTYPE_p_OpenBabel__OBMol, 1));
    }
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMol_separate(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBMol_separate__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBMol_separate__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMol_separate'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_convert_dative_bonds(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConvertDativeBonds" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (bool)(arg1)->ConvertDativeBonds();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_correct_for_ph(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CorrectForPH" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (bool)(arg1)->CorrectForPH();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_assign_spin_multiplicity(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AssignSpinMultiplicity" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (bool)(arg1)->AssignSpinMultiplicity();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_center__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  int arg2 ;
  OpenBabel::vector3 result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Center" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Center" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (arg1)->Center(arg2);
  vresult = SWIG_NewPointerObj((new OpenBabel::vector3(static_cast< const OpenBabel::vector3& >(result))), SWIGTYPE_p_OpenBabel__vector3, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMol_center(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBMol_center__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBMol_center__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMol_center'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_set_torsion(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg3 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg4 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg5 = (OpenBabel::OBAtom *) 0 ;
  double arg6 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  double val6 ;
  int ecode6 = 0 ;
  
  if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetTorsion" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetTorsion" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SetTorsion" "', argument " "3"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBAtom * >(argp3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "SetTorsion" "', argument " "4"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg4 = reinterpret_cast< OpenBabel::OBAtom * >(argp4);
  res5 = SWIG_ConvertPtr(argv[3], &argp5,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "SetTorsion" "', argument " "5"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg5 = reinterpret_cast< OpenBabel::OBAtom * >(argp5);
  ecode6 = SWIG_AsVal_double(argv[4], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "SetTorsion" "', argument " "6"" of type '" "double""'");
  } 
  arg6 = static_cast< double >(val6);
  (arg1)->SetTorsion(arg2,arg3,arg4,arg5,arg6);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_find_sssr(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FindSSSR" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  (arg1)->FindSSSR();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_find_ring_atoms_and_bonds(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FindRingAtomsAndBonds" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  (arg1)->FindRingAtomsAndBonds();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_find_chiral_centers(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FindChiralCenters" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  (arg1)->FindChiralCenters();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_find_children__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  std::vector<int > *arg2 = 0 ;
  int arg3 ;
  int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FindChildren" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTint_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "FindChildren" "', argument " "2"" of type '" "std::vector<int > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "FindChildren" "', argument " "2"" of type '" "std::vector<int > &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<int > * >(argp2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "FindChildren" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  ecode4 = SWIG_AsVal_int(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "FindChildren" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = static_cast< int >(val4);
  (arg1)->FindChildren(*arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_find_children__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  std::vector<OpenBabel::OBAtom * > *arg2 = 0 ;
  OpenBabel::OBAtom *arg3 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg4 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FindChildren" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBAtom_p_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "FindChildren" "', argument " "2"" of type '" "std::vector<OpenBabel::OBAtom * > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "FindChildren" "', argument " "2"" of type '" "std::vector<OpenBabel::OBAtom * > &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<OpenBabel::OBAtom * > * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "FindChildren" "', argument " "3"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBAtom * >(argp3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "FindChildren" "', argument " "4"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg4 = reinterpret_cast< OpenBabel::OBAtom * >(argp4);
  (arg1)->FindChildren(*arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMol_find_children(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__vectorTint_t, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_OBMol_find_children__SWIG_0(nargs, args, self);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__vectorTOpenBabel__OBAtom_p_t, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_OBMol_find_children__SWIG_1(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMol_find_children'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_find_largest_fragment(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBBitVec *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FindLargestFragment" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBBitVec,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "FindLargestFragment" "', argument " "2"" of type '" "OpenBabel::OBBitVec &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "FindLargestFragment" "', argument " "2"" of type '" "OpenBabel::OBBitVec &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBitVec * >(argp2);
  (arg1)->FindLargestFragment(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_contig_frag_list(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  std::vector<std::vector<int > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ContigFragList" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTstd__vectorTint_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ContigFragList" "', argument " "2"" of type '" "std::vector<std::vector<int > > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ContigFragList" "', argument " "2"" of type '" "std::vector<std::vector<int > > &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<std::vector<int > > * >(argp2);
  (arg1)->ContigFragList(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_align(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg3 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::vector3 *arg4 = 0 ;
  OpenBabel::vector3 *arg5 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Align" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Align" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Align" "', argument " "3"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBAtom * >(argp3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Align" "', argument " "4"" of type '" "OpenBabel::vector3 &""'"); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Align" "', argument " "4"" of type '" "OpenBabel::vector3 &""'"); 
  }
  arg4 = reinterpret_cast< OpenBabel::vector3 * >(argp4);
  res5 = SWIG_ConvertPtr(argv[3], &argp5, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "Align" "', argument " "5"" of type '" "OpenBabel::vector3 &""'"); 
  }
  if (!argp5) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Align" "', argument " "5"" of type '" "OpenBabel::vector3 &""'"); 
  }
  arg5 = reinterpret_cast< OpenBabel::vector3 * >(argp5);
  (arg1)->Align(arg2,arg3,*arg4,*arg5);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_connect_the_dots(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConnectTheDots" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  (arg1)->ConnectTheDots();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_perceive_bond_orders(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PerceiveBondOrders" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  (arg1)->PerceiveBondOrders();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_find_angles(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FindAngles" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  (arg1)->FindAngles();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_find_torsions(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FindTorsions" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  (arg1)->FindTorsions();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_get_gtdvector(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  std::vector<int > *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetGTDVector" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTint_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetGTDVector" "', argument " "2"" of type '" "std::vector<int > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GetGTDVector" "', argument " "2"" of type '" "std::vector<int > &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<int > * >(argp2);
  result = (bool)(arg1)->GetGTDVector(*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_get_givector(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  std::vector<unsigned int > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetGIVector" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTunsigned_int_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetGIVector" "', argument " "2"" of type '" "std::vector<unsigned int > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GetGIVector" "', argument " "2"" of type '" "std::vector<unsigned int > &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<unsigned int > * >(argp2);
  (arg1)->GetGIVector(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_get_gidvector(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  std::vector<unsigned int > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetGIDVector" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTunsigned_int_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetGIDVector" "', argument " "2"" of type '" "std::vector<unsigned int > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GetGIDVector" "', argument " "2"" of type '" "std::vector<unsigned int > &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<unsigned int > * >(argp2);
  (arg1)->GetGIDVector(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_has_2d(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Has2D" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (bool)(arg1)->Has2D();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_has_3d(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Has3D" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (bool)(arg1)->Has3D();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_has_non_zero_coords(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasNonZeroCoords" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (bool)(arg1)->HasNonZeroCoords();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_has_aromatic_perceived(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasAromaticPerceived" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (bool)(arg1)->HasAromaticPerceived();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_has_sssrperceived(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasSSSRPerceived" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (bool)(arg1)->HasSSSRPerceived();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_has_ring_atoms_and_bonds_perceived(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasRingAtomsAndBondsPerceived" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (bool)(arg1)->HasRingAtomsAndBondsPerceived();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_has_atom_types_perceived(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasAtomTypesPerceived" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (bool)(arg1)->HasAtomTypesPerceived();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_has_chirality_perceived(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasChiralityPerceived" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (bool)(arg1)->HasChiralityPerceived();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_has_partial_charges_perceived(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasPartialChargesPerceived" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (bool)(arg1)->HasPartialChargesPerceived();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_has_hybridization_perceived(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasHybridizationPerceived" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (bool)(arg1)->HasHybridizationPerceived();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_has_implicit_valence_perceived(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasImplicitValencePerceived" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (bool)(arg1)->HasImplicitValencePerceived();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_has_kekule_perceived(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasKekulePerceived" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (bool)(arg1)->HasKekulePerceived();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_has_closure_bonds_perceived(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasClosureBondsPerceived" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (bool)(arg1)->HasClosureBondsPerceived();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_has_chains_perceived(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasChainsPerceived" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (bool)(arg1)->HasChainsPerceived();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_has_hydrogens_added(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasHydrogensAdded" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (bool)(arg1)->HasHydrogensAdded();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_has_aromatic_corrected(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasAromaticCorrected" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (bool)(arg1)->HasAromaticCorrected();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_is_corrected_for_ph(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsCorrectedForPH" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (bool)(arg1)->IsCorrectedForPH();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_has_spin_multiplicity_assigned(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasSpinMultiplicityAssigned" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (bool)(arg1)->HasSpinMultiplicityAssigned();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_is_chiral(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsChiral" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (bool)(arg1)->IsChiral();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_empty(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Empty" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (bool)(arg1)->Empty();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_num_conformers(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NumConformers" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (int)(arg1)->NumConformers();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_set_conformers(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  std::vector<double * > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetConformers" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTdouble_p_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetConformers" "', argument " "2"" of type '" "std::vector<double * > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetConformers" "', argument " "2"" of type '" "std::vector<double * > &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<double * > * >(argp2);
  (arg1)->SetConformers(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_add_conformer(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  double *arg2 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AddConformer" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AddConformer" "', argument " "2"" of type '" "double *""'"); 
  }
  arg2 = reinterpret_cast< double * >(argp2);
  (arg1)->AddConformer(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_set_conformer(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetConformer" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetConformer" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->SetConformer(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_copy_conformer(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  double *arg2 = (double *) 0 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CopyConformer" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CopyConformer" "', argument " "2"" of type '" "double *""'"); 
  }
  arg2 = reinterpret_cast< double * >(argp2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "CopyConformer" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  (arg1)->CopyConformer(arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_delete_conformer(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteConformer" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DeleteConformer" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->DeleteConformer(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_get_conformer(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  int arg2 ;
  double *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetConformer" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetConformer" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (double *)(arg1)->GetConformer(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_begin_conformer(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  std::vector<double * >::iterator *arg2 = 0 ;
  double *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginConformer" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTdouble_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "BeginConformer" "', argument " "2"" of type '" "std::vector<double * >::iterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "BeginConformer" "', argument " "2"" of type '" "std::vector<double * >::iterator &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<double * >::iterator * >(argp2);
  result = (double *)(arg1)->BeginConformer(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_next_conformer(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  std::vector<double * >::iterator *arg2 = 0 ;
  double *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NextConformer" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTdouble_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "NextConformer" "', argument " "2"" of type '" "std::vector<double * >::iterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "NextConformer" "', argument " "2"" of type '" "std::vector<double * >::iterator &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<double * >::iterator * >(argp2);
  result = (double *)(arg1)->NextConformer(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_get_conformers(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  std::vector<double * > *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetConformers" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  {
    std::vector<double * > &_result_ref = (arg1)->GetConformers();
    result = (std::vector<double * > *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorTdouble_p_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_begin_atoms(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBAtom * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginAtoms" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (arg1)->BeginAtoms();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBAtomIterator(static_cast< const OpenBabel::OBAtomIterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBAtom_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_end_atoms(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBAtom * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EndAtoms" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (arg1)->EndAtoms();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBAtomIterator(static_cast< const OpenBabel::OBAtomIterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBAtom_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_begin_bonds(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBBond * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginBonds" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (arg1)->BeginBonds();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBBondIterator(static_cast< const OpenBabel::OBBondIterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_end_bonds(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBBond * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EndBonds" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (arg1)->EndBonds();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBBondIterator(static_cast< const OpenBabel::OBBondIterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_begin_residues(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBResidue * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginResidues" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (arg1)->BeginResidues();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBResidueIterator(static_cast< const OpenBabel::OBResidueIterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBResidue_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_end_residues(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBResidue * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EndResidues" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (arg1)->EndResidues();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBResidueIterator(static_cast< const OpenBabel::OBResidueIterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBResidue_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_begin_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBAtomIterator *arg2 = 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginAtom" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBAtom_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "BeginAtom" "', argument " "2"" of type '" "OpenBabel::OBAtomIterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "BeginAtom" "', argument " "2"" of type '" "OpenBabel::OBAtomIterator &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtomIterator * >(argp2);
  result = (OpenBabel::OBAtom *)(arg1)->BeginAtom(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_next_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBAtomIterator *arg2 = 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NextAtom" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBAtom_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "NextAtom" "', argument " "2"" of type '" "OpenBabel::OBAtomIterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "NextAtom" "', argument " "2"" of type '" "OpenBabel::OBAtomIterator &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtomIterator * >(argp2);
  result = (OpenBabel::OBAtom *)(arg1)->NextAtom(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_begin_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBBondIterator *arg2 = 0 ;
  OpenBabel::OBBond *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginBond" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "BeginBond" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "BeginBond" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2);
  result = (OpenBabel::OBBond *)(arg1)->BeginBond(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_next_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBBondIterator *arg2 = 0 ;
  OpenBabel::OBBond *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NextBond" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "NextBond" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "NextBond" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2);
  result = (OpenBabel::OBBond *)(arg1)->NextBond(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_begin_residue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBResidueIterator *arg2 = 0 ;
  OpenBabel::OBResidue *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginResidue" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBResidue_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "BeginResidue" "', argument " "2"" of type '" "OpenBabel::OBResidueIterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "BeginResidue" "', argument " "2"" of type '" "OpenBabel::OBResidueIterator &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBResidueIterator * >(argp2);
  result = (OpenBabel::OBResidue *)(arg1)->BeginResidue(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_next_residue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBResidueIterator *arg2 = 0 ;
  OpenBabel::OBResidue *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NextResidue" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBResidue_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "NextResidue" "', argument " "2"" of type '" "OpenBabel::OBResidueIterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "NextResidue" "', argument " "2"" of type '" "OpenBabel::OBResidueIterator &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBResidueIterator * >(argp2);
  result = (OpenBabel::OBResidue *)(arg1)->NextResidue(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_begin_internal_coord(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  std::vector<OpenBabel::OBInternalCoord * >::iterator *arg2 = 0 ;
  OpenBabel::OBInternalCoord *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginInternalCoord" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBInternalCoord_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "BeginInternalCoord" "', argument " "2"" of type '" "std::vector<OpenBabel::OBInternalCoord * >::iterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "BeginInternalCoord" "', argument " "2"" of type '" "std::vector<OpenBabel::OBInternalCoord * >::iterator &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<OpenBabel::OBInternalCoord * >::iterator * >(argp2);
  result = (OpenBabel::OBInternalCoord *)(arg1)->BeginInternalCoord(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBInternalCoord, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMol_next_internal_coord(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  std::vector<OpenBabel::OBInternalCoord * >::iterator *arg2 = 0 ;
  OpenBabel::OBInternalCoord *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NextInternalCoord" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBInternalCoord_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "NextInternalCoord" "', argument " "2"" of type '" "std::vector<OpenBabel::OBInternalCoord * >::iterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "NextInternalCoord" "', argument " "2"" of type '" "std::vector<OpenBabel::OBInternalCoord * >::iterator &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<OpenBabel::OBInternalCoord * >::iterator * >(argp2);
  result = (OpenBabel::OBInternalCoord *)(arg1)->NextInternalCoord(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBInternalCoord, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_tokenize__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector<std::string > *arg1 = 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_std__vectorTstd__string_t,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::tokenize" "', argument " "1"" of type '" "std::vector<std::string > &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::tokenize" "', argument " "1"" of type '" "std::vector<std::string > &""'"); 
  }
  arg1 = reinterpret_cast< std::vector<std::string > * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::tokenize" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "OpenBabel::tokenize" "', argument " "3"" of type '" "char const *""'");
  }
  arg3 = reinterpret_cast< char * >(buf3);
  result = (bool)OpenBabel::tokenize(*arg1,(char const *)arg2,(char const *)arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_tokenize__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::vector<std::string > *arg1 = 0 ;
  char *arg2 = (char *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_std__vectorTstd__string_t,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::tokenize" "', argument " "1"" of type '" "std::vector<std::string > &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::tokenize" "', argument " "1"" of type '" "std::vector<std::string > &""'"); 
  }
  arg1 = reinterpret_cast< std::vector<std::string > * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::tokenize" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (bool)OpenBabel::tokenize(*arg1,(char const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_tokenize__SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::vector<std::string > *arg1 = 0 ;
  std::string *arg2 = 0 ;
  char *arg3 = (char *) 0 ;
  int arg4 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_std__vectorTstd__string_t,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::tokenize" "', argument " "1"" of type '" "std::vector<std::string > &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::tokenize" "', argument " "1"" of type '" "std::vector<std::string > &""'"); 
  }
  arg1 = reinterpret_cast< std::vector<std::string > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_std__string,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::tokenize" "', argument " "2"" of type '" "std::string &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::tokenize" "', argument " "2"" of type '" "std::string &""'"); 
  }
  arg2 = reinterpret_cast< std::string * >(argp2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "OpenBabel::tokenize" "', argument " "3"" of type '" "char const *""'");
  }
  arg3 = reinterpret_cast< char * >(buf3);
  ecode4 = SWIG_AsVal_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "OpenBabel::tokenize" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = static_cast< int >(val4);
  result = (bool)OpenBabel::tokenize(*arg1,*arg2,(char const *)arg3,arg4);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return vresult;
fail:
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_tokenize__SWIG_3(int argc, VALUE *argv, VALUE self) {
  std::vector<std::string > *arg1 = 0 ;
  std::string *arg2 = 0 ;
  char *arg3 = (char *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_std__vectorTstd__string_t,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::tokenize" "', argument " "1"" of type '" "std::vector<std::string > &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::tokenize" "', argument " "1"" of type '" "std::vector<std::string > &""'"); 
  }
  arg1 = reinterpret_cast< std::vector<std::string > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_std__string,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::tokenize" "', argument " "2"" of type '" "std::string &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::tokenize" "', argument " "2"" of type '" "std::string &""'"); 
  }
  arg2 = reinterpret_cast< std::string * >(argp2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "OpenBabel::tokenize" "', argument " "3"" of type '" "char const *""'");
  }
  arg3 = reinterpret_cast< char * >(buf3);
  result = (bool)OpenBabel::tokenize(*arg1,*arg2,(char const *)arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return vresult;
fail:
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_tokenize__SWIG_4(int argc, VALUE *argv, VALUE self) {
  std::vector<std::string > *arg1 = 0 ;
  std::string *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_std__vectorTstd__string_t,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::tokenize" "', argument " "1"" of type '" "std::vector<std::string > &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::tokenize" "', argument " "1"" of type '" "std::vector<std::string > &""'"); 
  }
  arg1 = reinterpret_cast< std::vector<std::string > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_std__string,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::tokenize" "', argument " "2"" of type '" "std::string &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::tokenize" "', argument " "2"" of type '" "std::string &""'"); 
  }
  arg2 = reinterpret_cast< std::string * >(argp2);
  result = (bool)OpenBabel::tokenize(*arg1,*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_tokenize(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs;
  if (argc > 4) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__vectorTstd__string_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__string, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_tokenize__SWIG_4(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__vectorTstd__string_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_tokenize__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__vectorTstd__string_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__string, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_tokenize__SWIG_3(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__vectorTstd__string_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_tokenize__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__vectorTstd__string_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__string, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_tokenize__SWIG_2(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'tokenize'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_throw_error__SWIG_0(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::ThrowError" "', argument " "1"" of type '" "char *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  OpenBabel::ThrowError(arg1);
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_throw_error__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_std__string,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::ThrowError" "', argument " "1"" of type '" "std::string &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::ThrowError" "', argument " "1"" of type '" "std::string &""'"); 
  }
  arg1 = reinterpret_cast< std::string * >(argp1);
  OpenBabel::ThrowError(*arg1);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_throw_error(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__string, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_throw_error__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_throw_error__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'throw_error'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_cartesian_to_internal(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBInternalCoord * > *arg1 = 0 ;
  OpenBabel::OBMol *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_std__vectorTOpenBabel__OBInternalCoord_p_t,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::CartesianToInternal" "', argument " "1"" of type '" "std::vector<OpenBabel::OBInternalCoord * > &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::CartesianToInternal" "', argument " "1"" of type '" "std::vector<OpenBabel::OBInternalCoord * > &""'"); 
  }
  arg1 = reinterpret_cast< std::vector<OpenBabel::OBInternalCoord * > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_OpenBabel__OBMol,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::CartesianToInternal" "', argument " "2"" of type '" "OpenBabel::OBMol &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::CartesianToInternal" "', argument " "2"" of type '" "OpenBabel::OBMol &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2);
  OpenBabel::CartesianToInternal(*arg1,*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_internal_to_cartesian(int argc, VALUE *argv, VALUE self) {
  std::vector<OpenBabel::OBInternalCoord * > *arg1 = 0 ;
  OpenBabel::OBMol *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_std__vectorTOpenBabel__OBInternalCoord_p_t,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::InternalToCartesian" "', argument " "1"" of type '" "std::vector<OpenBabel::OBInternalCoord * > &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::InternalToCartesian" "', argument " "1"" of type '" "std::vector<OpenBabel::OBInternalCoord * > &""'"); 
  }
  arg1 = reinterpret_cast< std::vector<OpenBabel::OBInternalCoord * > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_OpenBabel__OBMol,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::InternalToCartesian" "', argument " "2"" of type '" "OpenBabel::OBMol &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::InternalToCartesian" "', argument " "2"" of type '" "OpenBabel::OBMol &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2);
  OpenBabel::InternalToCartesian(*arg1,*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_extension(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  char *arg2 = (char *) 0 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_std__string,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::NewExtension" "', argument " "1"" of type '" "std::string &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::NewExtension" "', argument " "1"" of type '" "std::string &""'"); 
  }
  arg1 = reinterpret_cast< std::string * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::NewExtension" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = OpenBabel::NewExtension(*arg1,arg2);
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
etab_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_NewPointerObj(SWIG_as_voidptr(&OpenBabel::etab), SWIGTYPE_p_OpenBabel__OBElementTable,  0 );
  return _val;
}


SWIGINTERN VALUE
etab_set(VALUE self, VALUE _val) {
  {
    void *argp = 0;
    int res = SWIG_ConvertPtr(_val, &argp, SWIGTYPE_p_OpenBabel__OBElementTable,  0 );
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""OpenBabel::etab""' of type '""OpenBabel::OBElementTable""'");
    }
    if (!argp) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""OpenBabel::etab""' of type '""OpenBabel::OBElementTable""'");
    } else {
      OpenBabel::etab = *(reinterpret_cast< OpenBabel::OBElementTable * >(argp));
    }
  }
  return _val;
fail:
  return Qnil;
}


SWIGINTERN VALUE
ttab_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_NewPointerObj(SWIG_as_voidptr(&OpenBabel::ttab), SWIGTYPE_p_OpenBabel__OBTypeTable,  0 );
  return _val;
}


SWIGINTERN VALUE
ttab_set(VALUE self, VALUE _val) {
  {
    void *argp = 0;
    int res = SWIG_ConvertPtr(_val, &argp, SWIGTYPE_p_OpenBabel__OBTypeTable,  0 );
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""OpenBabel::ttab""' of type '""OpenBabel::OBTypeTable""'");
    }
    if (!argp) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""OpenBabel::ttab""' of type '""OpenBabel::OBTypeTable""'");
    } else {
      OpenBabel::ttab = *(reinterpret_cast< OpenBabel::OBTypeTable * >(argp));
    }
  }
  return _val;
fail:
  return Qnil;
}


SWIGINTERN VALUE
isotab_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_NewPointerObj(SWIG_as_voidptr(&OpenBabel::isotab), SWIGTYPE_p_OpenBabel__OBIsotopeTable,  0 );
  return _val;
}


SWIGINTERN VALUE
isotab_set(VALUE self, VALUE _val) {
  {
    void *argp = 0;
    int res = SWIG_ConvertPtr(_val, &argp, SWIGTYPE_p_OpenBabel__OBIsotopeTable,  0 );
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""OpenBabel::isotab""' of type '""OpenBabel::OBIsotopeTable""'");
    }
    if (!argp) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""OpenBabel::isotab""' of type '""OpenBabel::OBIsotopeTable""'");
    } else {
      OpenBabel::isotab = *(reinterpret_cast< OpenBabel::OBIsotopeTable * >(argp));
    }
  }
  return _val;
fail:
  return Qnil;
}


SWIGINTERN VALUE
aromtyper_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_NewPointerObj(SWIG_as_voidptr(&OpenBabel::aromtyper), SWIGTYPE_p_OpenBabel__OBAromaticTyper,  0 );
  return _val;
}


SWIGINTERN VALUE
aromtyper_set(VALUE self, VALUE _val) {
  {
    void *argp = 0;
    int res = SWIG_ConvertPtr(_val, &argp, SWIGTYPE_p_OpenBabel__OBAromaticTyper,  0 );
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""OpenBabel::aromtyper""' of type '""OpenBabel::OBAromaticTyper""'");
    }
    if (!argp) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""OpenBabel::aromtyper""' of type '""OpenBabel::OBAromaticTyper""'");
    } else {
      OpenBabel::aromtyper = *(reinterpret_cast< OpenBabel::OBAromaticTyper * >(argp));
    }
  }
  return _val;
fail:
  return Qnil;
}


SWIGINTERN VALUE
atomtyper_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_NewPointerObj(SWIG_as_voidptr(&OpenBabel::atomtyper), SWIGTYPE_p_OpenBabel__OBAtomTyper,  0 );
  return _val;
}


SWIGINTERN VALUE
atomtyper_set(VALUE self, VALUE _val) {
  {
    void *argp = 0;
    int res = SWIG_ConvertPtr(_val, &argp, SWIGTYPE_p_OpenBabel__OBAtomTyper,  0 );
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""OpenBabel::atomtyper""' of type '""OpenBabel::OBAtomTyper""'");
    }
    if (!argp) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""OpenBabel::atomtyper""' of type '""OpenBabel::OBAtomTyper""'");
    } else {
      OpenBabel::atomtyper = *(reinterpret_cast< OpenBabel::OBAtomTyper * >(argp));
    }
  }
  return _val;
fail:
  return Qnil;
}


SWIGINTERN VALUE
chainsparser_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_NewPointerObj(SWIG_as_voidptr(&OpenBabel::chainsparser), SWIGTYPE_p_OpenBabel__OBChainsParser,  0 );
  return _val;
}


SWIGINTERN VALUE
chainsparser_set(VALUE self, VALUE _val) {
  {
    void *argp = 0;
    int res = SWIG_ConvertPtr(_val, &argp, SWIGTYPE_p_OpenBabel__OBChainsParser,  0 );
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""OpenBabel::chainsparser""' of type '""OpenBabel::OBChainsParser""'");
    }
    if (!argp) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""OpenBabel::chainsparser""' of type '""OpenBabel::OBChainsParser""'");
    } else {
      OpenBabel::chainsparser = *(reinterpret_cast< OpenBabel::OBChainsParser * >(argp));
    }
  }
  return _val;
fail:
  return Qnil;
}


SWIGINTERN VALUE
resdat_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_NewPointerObj(SWIG_as_voidptr(&OpenBabel::resdat), SWIGTYPE_p_OpenBabel__OBResidueData,  0 );
  return _val;
}


SWIGINTERN VALUE
resdat_set(VALUE self, VALUE _val) {
  {
    void *argp = 0;
    int res = SWIG_ConvertPtr(_val, &argp, SWIGTYPE_p_OpenBabel__OBResidueData,  0 );
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""OpenBabel::resdat""' of type '""OpenBabel::OBResidueData""'");
    }
    if (!argp) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""OpenBabel::resdat""' of type '""OpenBabel::OBResidueData""'");
    } else {
      OpenBabel::resdat = *(reinterpret_cast< OpenBabel::OBResidueData * >(argp));
    }
  }
  return _val;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_get_rmat(int argc, VALUE *argv, VALUE self) {
  double *arg1 = (double *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::get_rmat" "', argument " "1"" of type '" "double *""'"); 
  }
  arg1 = reinterpret_cast< double * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::get_rmat" "', argument " "2"" of type '" "double *""'"); 
  }
  arg2 = reinterpret_cast< double * >(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "OpenBabel::get_rmat" "', argument " "3"" of type '" "double *""'"); 
  }
  arg3 = reinterpret_cast< double * >(argp3);
  ecode4 = SWIG_AsVal_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "OpenBabel::get_rmat" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = static_cast< int >(val4);
  OpenBabel::get_rmat(arg1,arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ob_make_rmat(int argc, VALUE *argv, VALUE self) {
  double (*arg1)[3] ;
  double *arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_a_3__double, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::ob_make_rmat" "', argument " "1"" of type '" "double [3][3]""'"); 
  } 
  arg1 = reinterpret_cast< double (*)[3] >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::ob_make_rmat" "', argument " "2"" of type '" "double [9]""'"); 
  } 
  arg2 = reinterpret_cast< double * >(argp2);
  OpenBabel::ob_make_rmat((double (*)[3])arg1,arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_qtrfit(int argc, VALUE *argv, VALUE self) {
  double *arg1 = (double *) 0 ;
  double *arg2 = (double *) 0 ;
  int arg3 ;
  double (*arg4)[3] ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::qtrfit" "', argument " "1"" of type '" "double *""'"); 
  }
  arg1 = reinterpret_cast< double * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::qtrfit" "', argument " "2"" of type '" "double *""'"); 
  }
  arg2 = reinterpret_cast< double * >(argp2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "OpenBabel::qtrfit" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  res4 = SWIG_ConvertPtr(argv[3], &argp4,SWIGTYPE_p_a_3__double, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "OpenBabel::qtrfit" "', argument " "4"" of type '" "double [3][3]""'"); 
  } 
  arg4 = reinterpret_cast< double (*)[3] >(argp4);
  OpenBabel::qtrfit(arg1,arg2,arg3,(double (*)[3])arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_superimpose(int argc, VALUE *argv, VALUE self) {
  double *arg1 = (double *) 0 ;
  double *arg2 = (double *) 0 ;
  int arg3 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::superimpose" "', argument " "1"" of type '" "double *""'"); 
  }
  arg1 = reinterpret_cast< double * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::superimpose" "', argument " "2"" of type '" "double *""'"); 
  }
  arg2 = reinterpret_cast< double * >(argp2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "OpenBabel::superimpose" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  result = (double)OpenBabel::superimpose(arg1,arg2,arg3);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


swig_class cOBRing;

SWIGINTERN VALUE
_wrap_OBRing__path_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRing *arg1 = (OpenBabel::OBRing *) 0 ;
  std::vector<int > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector<int > temp2 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRing, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_path" "', argument " "1"" of type '" "OpenBabel::OBRing *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBRing * >(argp1);
  {
    if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
      unsigned int size = RARRAY_LEN(argv[0]);
      temp2 = std::vector<int >(size);
      arg2 = &temp2;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(argv[0])[i];
        if (FIXNUM_P(o))
        temp2[i] = (int)(FIX2INT(o));
        else
        rb_raise(rb_eTypeError,
          "wrong argument type"
          " (expected vector<""int" ">)");
      }
    } else {
      SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_std__vectorTint_t, 1);
    }
  }
  if (arg1) (arg1)->_path = *arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBRing__path_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRing *arg1 = (OpenBabel::OBRing *) 0 ;
  std::vector<int > *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRing, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_path" "', argument " "1"" of type '" "OpenBabel::OBRing *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBRing * >(argp1);
  {
    std::vector<int > const &_result_ref =  ((arg1)->_path);
    result = (std::vector<int > *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorTint_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBRing__pathset_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRing *arg1 = (OpenBabel::OBRing *) 0 ;
  OpenBabel::OBBitVec *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRing, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_pathset" "', argument " "1"" of type '" "OpenBabel::OBRing *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBRing * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBBitVec,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "_pathset" "', argument " "2"" of type '" "OpenBabel::OBBitVec const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "_pathset" "', argument " "2"" of type '" "OpenBabel::OBBitVec const &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBitVec * >(argp2);
  if (arg1) (arg1)->_pathset = *arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBRing__pathset_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRing *arg1 = (OpenBabel::OBRing *) 0 ;
  OpenBabel::OBBitVec *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRing, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_pathset" "', argument " "1"" of type '" "OpenBabel::OBRing *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBRing * >(argp1);
  {
    OpenBabel::OBBitVec const &_result_ref =  ((arg1)->_pathset);
    result = (OpenBabel::OBBitVec *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBitVec, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_OBRing__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRing *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBRing *)new OpenBabel::OBRing();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_OBRing__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::vector<int > *arg1 = 0 ;
  int arg2 ;
  OpenBabel::OBRing *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_std__vectorTint_t,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBRing" "', argument " "1"" of type '" "std::vector<int > &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBRing" "', argument " "1"" of type '" "std::vector<int > &""'"); 
  }
  arg1 = reinterpret_cast< std::vector<int > * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "OpenBabel::OBRing" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (OpenBabel::OBRing *)new OpenBabel::OBRing(*arg1,arg2);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_OBRing__SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::vector<int > *arg1 = 0 ;
  OpenBabel::OBBitVec arg2 ;
  OpenBabel::OBRing *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_std__vectorTint_t,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBRing" "', argument " "1"" of type '" "std::vector<int > &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBRing" "', argument " "1"" of type '" "std::vector<int > &""'"); 
  }
  arg1 = reinterpret_cast< std::vector<int > * >(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_OpenBabel__OBBitVec,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::OBRing" "', argument " "2"" of type '" "OpenBabel::OBBitVec""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBRing" "', argument " "2"" of type '" "OpenBabel::OBBitVec""'");
    } else {
      arg2 = *(reinterpret_cast< OpenBabel::OBBitVec * >(argp2));
    }
  }
  result = (OpenBabel::OBRing *)new OpenBabel::OBRing(*arg1,arg2);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBRing_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBRing_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBRing);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBRing__SWIG_3(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRing *arg1 = 0 ;
  OpenBabel::OBRing *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBRing,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBRing" "', argument " "1"" of type '" "OpenBabel::OBRing const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBRing" "', argument " "1"" of type '" "OpenBabel::OBRing const &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBRing * >(argp1);
  result = (OpenBabel::OBRing *)new OpenBabel::OBRing((OpenBabel::OBRing const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_OBRing(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_OBRing__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBRing, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBRing__SWIG_3(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__vectorTint_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBBitVec, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_OBRing__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__vectorTint_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_OBRing__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_OBRing'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBRing_size(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRing *arg1 = (OpenBabel::OBRing *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRing, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Size" "', argument " "1"" of type '" "OpenBabel::OBRing const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBRing * >(argp1);
  result = (int)((OpenBabel::OBRing const *)arg1)->Size();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBRing_path_size(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRing *arg1 = (OpenBabel::OBRing *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRing, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathSize" "', argument " "1"" of type '" "OpenBabel::OBRing const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBRing * >(argp1);
  result = (int)((OpenBabel::OBRing const *)arg1)->PathSize();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBRing_is_aromatic(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRing *arg1 = (OpenBabel::OBRing *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRing, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsAromatic" "', argument " "1"" of type '" "OpenBabel::OBRing *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBRing * >(argp1);
  result = (bool)(arg1)->IsAromatic();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBRing_is_member__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRing *arg1 = (OpenBabel::OBRing *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRing, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsMember" "', argument " "1"" of type '" "OpenBabel::OBRing *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBRing * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "IsMember" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (bool)(arg1)->IsMember(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBRing_is_member__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRing *arg1 = (OpenBabel::OBRing *) 0 ;
  OpenBabel::OBBond *arg2 = (OpenBabel::OBBond *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRing, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsMember" "', argument " "1"" of type '" "OpenBabel::OBRing *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBRing * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "IsMember" "', argument " "2"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBond * >(argp2);
  result = (bool)(arg1)->IsMember(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBRing_is_member(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBRing, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBRing_is_member__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBRing, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBBond, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBRing_is_member__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBRing_is_member'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBRing_is_in_ring(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRing *arg1 = (OpenBabel::OBRing *) 0 ;
  int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRing, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsInRing" "', argument " "1"" of type '" "OpenBabel::OBRing *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBRing * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IsInRing" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (bool)(arg1)->IsInRing(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBRing_set_parent(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRing *arg1 = (OpenBabel::OBRing *) 0 ;
  OpenBabel::OBMol *arg2 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRing, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetParent" "', argument " "1"" of type '" "OpenBabel::OBRing *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBRing * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetParent" "', argument " "2"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2);
  (arg1)->SetParent(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBRing_get_parent(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRing *arg1 = (OpenBabel::OBRing *) 0 ;
  OpenBabel::OBMol *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRing, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetParent" "', argument " "1"" of type '" "OpenBabel::OBRing *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBRing * >(argp1);
  result = (OpenBabel::OBMol *)(arg1)->GetParent();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBRing_find_center_and_normal(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRing *arg1 = (OpenBabel::OBRing *) 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  OpenBabel::vector3 *arg3 = 0 ;
  OpenBabel::vector3 *arg4 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRing, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "findCenterAndNormal" "', argument " "1"" of type '" "OpenBabel::OBRing *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBRing * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "findCenterAndNormal" "', argument " "2"" of type '" "OpenBabel::vector3 &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "findCenterAndNormal" "', argument " "2"" of type '" "OpenBabel::vector3 &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "findCenterAndNormal" "', argument " "3"" of type '" "OpenBabel::vector3 &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "findCenterAndNormal" "', argument " "3"" of type '" "OpenBabel::vector3 &""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::vector3 * >(argp3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "findCenterAndNormal" "', argument " "4"" of type '" "OpenBabel::vector3 &""'"); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "findCenterAndNormal" "', argument " "4"" of type '" "OpenBabel::vector3 &""'"); 
  }
  arg4 = reinterpret_cast< OpenBabel::vector3 * >(argp4);
  result = (bool)(arg1)->findCenterAndNormal(*arg2,*arg3,*arg4);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBRing(OpenBabel::OBRing *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_compare_ring_size(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRing *arg1 = (OpenBabel::OBRing *) 0 ;
  OpenBabel::OBRing *arg2 = (OpenBabel::OBRing *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_OpenBabel__OBRing, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::CompareRingSize" "', argument " "1"" of type '" "OpenBabel::OBRing const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBRing * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_OpenBabel__OBRing, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::CompareRingSize" "', argument " "2"" of type '" "OpenBabel::OBRing const *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBRing * >(argp2);
  result = (bool)OpenBabel::CompareRingSize((OpenBabel::OBRing const *)arg1,(OpenBabel::OBRing const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


swig_class cOBRingSearch;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBRingSearch_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBRingSearch_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBRingSearch);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBRingSearch(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRingSearch *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBRingSearch *)new OpenBabel::OBRingSearch();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBRingSearch(OpenBabel::OBRingSearch *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_OBRingSearch_sort_rings(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRingSearch *arg1 = (OpenBabel::OBRingSearch *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRingSearch, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SortRings" "', argument " "1"" of type '" "OpenBabel::OBRingSearch *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBRingSearch * >(argp1);
  (arg1)->SortRings();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBRingSearch_remove_redundant(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRingSearch *arg1 = (OpenBabel::OBRingSearch *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRingSearch, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RemoveRedundant" "', argument " "1"" of type '" "OpenBabel::OBRingSearch *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBRingSearch * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "RemoveRedundant" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->RemoveRedundant(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBRingSearch_add_ring_from_closure(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRingSearch *arg1 = (OpenBabel::OBRingSearch *) 0 ;
  OpenBabel::OBMol *arg2 = 0 ;
  OpenBabel::OBBond *arg3 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRingSearch, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AddRingFromClosure" "', argument " "1"" of type '" "OpenBabel::OBRingSearch *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBRingSearch * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBMol,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AddRingFromClosure" "', argument " "2"" of type '" "OpenBabel::OBMol &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "AddRingFromClosure" "', argument " "2"" of type '" "OpenBabel::OBMol &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "AddRingFromClosure" "', argument " "3"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBBond * >(argp3);
  (arg1)->AddRingFromClosure(*arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBRingSearch_save_unique_ring(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRingSearch *arg1 = (OpenBabel::OBRingSearch *) 0 ;
  std::deque<int > *arg2 = 0 ;
  std::deque<int > *arg3 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRingSearch, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SaveUniqueRing" "', argument " "1"" of type '" "OpenBabel::OBRingSearch *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBRingSearch * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__dequeTint_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SaveUniqueRing" "', argument " "2"" of type '" "std::deque<int > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SaveUniqueRing" "', argument " "2"" of type '" "std::deque<int > &""'"); 
  }
  arg2 = reinterpret_cast< std::deque<int > * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_std__dequeTint_t,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SaveUniqueRing" "', argument " "3"" of type '" "std::deque<int > &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SaveUniqueRing" "', argument " "3"" of type '" "std::deque<int > &""'"); 
  }
  arg3 = reinterpret_cast< std::deque<int > * >(argp3);
  result = (bool)(arg1)->SaveUniqueRing(*arg2,*arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBRingSearch_write_rings(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRingSearch *arg1 = (OpenBabel::OBRingSearch *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRingSearch, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "WriteRings" "', argument " "1"" of type '" "OpenBabel::OBRingSearch *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBRingSearch * >(argp1);
  (arg1)->WriteRings();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBRingSearch_begin_rings(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRingSearch *arg1 = (OpenBabel::OBRingSearch *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBRing * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRingSearch, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginRings" "', argument " "1"" of type '" "OpenBabel::OBRingSearch *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBRingSearch * >(argp1);
  result = (arg1)->BeginRings();
  vresult = SWIG_NewPointerObj((new std::vector<OpenBabel::OBRing * >::iterator(static_cast< const std::vector<OpenBabel::OBRing * >::iterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBRing_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBRingSearch_end_rings(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRingSearch *arg1 = (OpenBabel::OBRingSearch *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBRing * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRingSearch, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EndRings" "', argument " "1"" of type '" "OpenBabel::OBRingSearch *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBRingSearch * >(argp1);
  result = (arg1)->EndRings();
  vresult = SWIG_NewPointerObj((new std::vector<OpenBabel::OBRing * >::iterator(static_cast< const std::vector<OpenBabel::OBRing * >::iterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBRing_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


swig_class cOBRTree;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBRTree_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBRTree_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBRTree);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBRTree(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBRTree *arg2 = (OpenBabel::OBRTree *) 0 ;
  OpenBabel::OBRTree *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBRTree" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_OpenBabel__OBRTree, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::OBRTree" "', argument " "2"" of type '" "OpenBabel::OBRTree *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBRTree * >(argp2);
  result = (OpenBabel::OBRTree *)new OpenBabel::OBRTree(arg1,arg2);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBRTree(OpenBabel::OBRTree *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_OBRTree_get_atom_idx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRTree *arg1 = (OpenBabel::OBRTree *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRTree, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAtomIdx" "', argument " "1"" of type '" "OpenBabel::OBRTree *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBRTree * >(argp1);
  result = (int)(arg1)->GetAtomIdx();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBRTree_path_to_root(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRTree *arg1 = (OpenBabel::OBRTree *) 0 ;
  std::vector<OpenBabel::OBAtom * > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRTree, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathToRoot" "', argument " "1"" of type '" "OpenBabel::OBRTree *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBRTree * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBAtom_p_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "PathToRoot" "', argument " "2"" of type '" "std::vector<OpenBabel::OBAtom * > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "PathToRoot" "', argument " "2"" of type '" "std::vector<OpenBabel::OBAtom * > &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<OpenBabel::OBAtom * > * >(argp2);
  (arg1)->PathToRoot(*arg2);
  return Qnil;
fail:
  return Qnil;
}


swig_class cOBSmartsPattern;

SWIGINTERN VALUE
_wrap_new_OBSmartsPattern__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSmartsPattern *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBSmartsPattern *)new OpenBabel::OBSmartsPattern();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBSmartsPattern(OpenBabel::OBSmartsPattern *arg1) {
    delete arg1;
}

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBSmartsPattern_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBSmartsPattern_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBSmartsPattern);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBSmartsPattern__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSmartsPattern *arg1 = 0 ;
  OpenBabel::OBSmartsPattern *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBSmartsPattern,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBSmartsPattern" "', argument " "1"" of type '" "OpenBabel::OBSmartsPattern const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBSmartsPattern" "', argument " "1"" of type '" "OpenBabel::OBSmartsPattern const &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSmartsPattern * >(argp1);
  result = (OpenBabel::OBSmartsPattern *)new OpenBabel::OBSmartsPattern((OpenBabel::OBSmartsPattern const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_OBSmartsPattern(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_OBSmartsPattern__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBSmartsPattern__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_OBSmartsPattern'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSmartsPattern_init__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSmartsPattern *arg1 = (OpenBabel::OBSmartsPattern *) 0 ;
  char *arg2 = (char *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Init" "', argument " "1"" of type '" "OpenBabel::OBSmartsPattern *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSmartsPattern * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Init" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (bool)(arg1)->Init((char const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSmartsPattern_init__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSmartsPattern *arg1 = (OpenBabel::OBSmartsPattern *) 0 ;
  std::string *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Init" "', argument " "1"" of type '" "OpenBabel::OBSmartsPattern *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSmartsPattern * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Init" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Init" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (bool)(arg1)->Init((std::string const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBSmartsPattern_init(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBSmartsPattern_init__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBSmartsPattern_init__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBSmartsPattern_init'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSmartsPattern_get_smarts__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSmartsPattern *arg1 = (OpenBabel::OBSmartsPattern *) 0 ;
  std::string *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetSMARTS" "', argument " "1"" of type '" "OpenBabel::OBSmartsPattern const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSmartsPattern * >(argp1);
  {
    std::string const &_result_ref = ((OpenBabel::OBSmartsPattern const *)arg1)->GetSMARTS();
    result = (std::string *) &_result_ref;
  }
  vresult = SWIG_From_std_string(static_cast< std::string >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSmartsPattern_get_smarts__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSmartsPattern *arg1 = (OpenBabel::OBSmartsPattern *) 0 ;
  std::string *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetSMARTS" "', argument " "1"" of type '" "OpenBabel::OBSmartsPattern *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSmartsPattern * >(argp1);
  {
    std::string &_result_ref = (arg1)->GetSMARTS();
    result = (std::string *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__string, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBSmartsPattern_get_smarts(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBSmartsPattern_get_smarts__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBSmartsPattern_get_smarts__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBSmartsPattern_get_smarts'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSmartsPattern_empty(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSmartsPattern *arg1 = (OpenBabel::OBSmartsPattern *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Empty" "', argument " "1"" of type '" "OpenBabel::OBSmartsPattern const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSmartsPattern * >(argp1);
  result = (bool)((OpenBabel::OBSmartsPattern const *)arg1)->Empty();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSmartsPattern_is_valid(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSmartsPattern *arg1 = (OpenBabel::OBSmartsPattern *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsValid" "', argument " "1"" of type '" "OpenBabel::OBSmartsPattern const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSmartsPattern * >(argp1);
  result = (bool)((OpenBabel::OBSmartsPattern const *)arg1)->IsValid();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSmartsPattern_num_atoms(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSmartsPattern *arg1 = (OpenBabel::OBSmartsPattern *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NumAtoms" "', argument " "1"" of type '" "OpenBabel::OBSmartsPattern const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSmartsPattern * >(argp1);
  result = (unsigned int)((OpenBabel::OBSmartsPattern const *)arg1)->NumAtoms();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSmartsPattern_num_bonds(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSmartsPattern *arg1 = (OpenBabel::OBSmartsPattern *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NumBonds" "', argument " "1"" of type '" "OpenBabel::OBSmartsPattern const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSmartsPattern * >(argp1);
  result = (unsigned int)((OpenBabel::OBSmartsPattern const *)arg1)->NumBonds();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSmartsPattern_get_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSmartsPattern *arg1 = (OpenBabel::OBSmartsPattern *) 0 ;
  int *arg2 = 0 ;
  int *arg3 = 0 ;
  int *arg4 = 0 ;
  int arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetBond" "', argument " "1"" of type '" "OpenBabel::OBSmartsPattern *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSmartsPattern * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_int,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetBond" "', argument " "2"" of type '" "int &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GetBond" "', argument " "2"" of type '" "int &""'"); 
  }
  arg2 = reinterpret_cast< int * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_int,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "GetBond" "', argument " "3"" of type '" "int &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GetBond" "', argument " "3"" of type '" "int &""'"); 
  }
  arg3 = reinterpret_cast< int * >(argp3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4, SWIGTYPE_p_int,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "GetBond" "', argument " "4"" of type '" "int &""'"); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GetBond" "', argument " "4"" of type '" "int &""'"); 
  }
  arg4 = reinterpret_cast< int * >(argp4);
  ecode5 = SWIG_AsVal_int(argv[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "GetBond" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = static_cast< int >(val5);
  (arg1)->GetBond(*arg2,*arg3,*arg4,arg5);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSmartsPattern_get_atomic_num(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSmartsPattern *arg1 = (OpenBabel::OBSmartsPattern *) 0 ;
  int arg2 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAtomicNum" "', argument " "1"" of type '" "OpenBabel::OBSmartsPattern *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSmartsPattern * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetAtomicNum" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (int)(arg1)->GetAtomicNum(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSmartsPattern_get_charge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSmartsPattern *arg1 = (OpenBabel::OBSmartsPattern *) 0 ;
  int arg2 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetCharge" "', argument " "1"" of type '" "OpenBabel::OBSmartsPattern *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSmartsPattern * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetCharge" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (int)(arg1)->GetCharge(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSmartsPattern_get_vector_binding(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSmartsPattern *arg1 = (OpenBabel::OBSmartsPattern *) 0 ;
  int arg2 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetVectorBinding" "', argument " "1"" of type '" "OpenBabel::OBSmartsPattern const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSmartsPattern * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetVectorBinding" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (int)((OpenBabel::OBSmartsPattern const *)arg1)->GetVectorBinding(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSmartsPattern_match__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSmartsPattern *arg1 = (OpenBabel::OBSmartsPattern *) 0 ;
  OpenBabel::OBMol *arg2 = 0 ;
  bool arg3 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Match" "', argument " "1"" of type '" "OpenBabel::OBSmartsPattern *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSmartsPattern * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBMol,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Match" "', argument " "2"" of type '" "OpenBabel::OBMol &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Match" "', argument " "2"" of type '" "OpenBabel::OBMol &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2);
  ecode3 = SWIG_AsVal_bool(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Match" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  result = (bool)(arg1)->Match(*arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSmartsPattern_match__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSmartsPattern *arg1 = (OpenBabel::OBSmartsPattern *) 0 ;
  OpenBabel::OBMol *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Match" "', argument " "1"" of type '" "OpenBabel::OBSmartsPattern *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSmartsPattern * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBMol,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Match" "', argument " "2"" of type '" "OpenBabel::OBMol &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Match" "', argument " "2"" of type '" "OpenBabel::OBMol &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2);
  result = (bool)(arg1)->Match(*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBSmartsPattern_match(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBSmartsPattern_match__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_bool(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_OBSmartsPattern_match__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBSmartsPattern_match'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSmartsPattern_restricted_match__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSmartsPattern *arg1 = (OpenBabel::OBSmartsPattern *) 0 ;
  OpenBabel::OBMol *arg2 = 0 ;
  std::vector<std::pair<int,int > > *arg3 = 0 ;
  bool arg4 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RestrictedMatch" "', argument " "1"" of type '" "OpenBabel::OBSmartsPattern *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSmartsPattern * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBMol,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "RestrictedMatch" "', argument " "2"" of type '" "OpenBabel::OBMol &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "RestrictedMatch" "', argument " "2"" of type '" "OpenBabel::OBMol &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_std__vectorTstd__pairTint_int_t_t,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "RestrictedMatch" "', argument " "3"" of type '" "std::vector<std::pair<int,int > > &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "RestrictedMatch" "', argument " "3"" of type '" "std::vector<std::pair<int,int > > &""'"); 
  }
  arg3 = reinterpret_cast< std::vector<std::pair<int,int > > * >(argp3);
  ecode4 = SWIG_AsVal_bool(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "RestrictedMatch" "', argument " "4"" of type '" "bool""'");
  } 
  arg4 = static_cast< bool >(val4);
  result = (bool)(arg1)->RestrictedMatch(*arg2,*arg3,arg4);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSmartsPattern_restricted_match__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSmartsPattern *arg1 = (OpenBabel::OBSmartsPattern *) 0 ;
  OpenBabel::OBMol *arg2 = 0 ;
  std::vector<std::pair<int,int > > *arg3 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RestrictedMatch" "', argument " "1"" of type '" "OpenBabel::OBSmartsPattern *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSmartsPattern * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBMol,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "RestrictedMatch" "', argument " "2"" of type '" "OpenBabel::OBMol &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "RestrictedMatch" "', argument " "2"" of type '" "OpenBabel::OBMol &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_std__vectorTstd__pairTint_int_t_t,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "RestrictedMatch" "', argument " "3"" of type '" "std::vector<std::pair<int,int > > &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "RestrictedMatch" "', argument " "3"" of type '" "std::vector<std::pair<int,int > > &""'"); 
  }
  arg3 = reinterpret_cast< std::vector<std::pair<int,int > > * >(argp3);
  result = (bool)(arg1)->RestrictedMatch(*arg2,*arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSmartsPattern_restricted_match__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSmartsPattern *arg1 = (OpenBabel::OBSmartsPattern *) 0 ;
  OpenBabel::OBMol *arg2 = 0 ;
  OpenBabel::OBBitVec *arg3 = 0 ;
  bool arg4 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RestrictedMatch" "', argument " "1"" of type '" "OpenBabel::OBSmartsPattern *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSmartsPattern * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBMol,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "RestrictedMatch" "', argument " "2"" of type '" "OpenBabel::OBMol &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "RestrictedMatch" "', argument " "2"" of type '" "OpenBabel::OBMol &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_OpenBabel__OBBitVec,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "RestrictedMatch" "', argument " "3"" of type '" "OpenBabel::OBBitVec &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "RestrictedMatch" "', argument " "3"" of type '" "OpenBabel::OBBitVec &""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBBitVec * >(argp3);
  ecode4 = SWIG_AsVal_bool(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "RestrictedMatch" "', argument " "4"" of type '" "bool""'");
  } 
  arg4 = static_cast< bool >(val4);
  result = (bool)(arg1)->RestrictedMatch(*arg2,*arg3,arg4);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSmartsPattern_restricted_match__SWIG_3(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSmartsPattern *arg1 = (OpenBabel::OBSmartsPattern *) 0 ;
  OpenBabel::OBMol *arg2 = 0 ;
  OpenBabel::OBBitVec *arg3 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RestrictedMatch" "', argument " "1"" of type '" "OpenBabel::OBSmartsPattern *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSmartsPattern * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBMol,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "RestrictedMatch" "', argument " "2"" of type '" "OpenBabel::OBMol &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "RestrictedMatch" "', argument " "2"" of type '" "OpenBabel::OBMol &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_OpenBabel__OBBitVec,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "RestrictedMatch" "', argument " "3"" of type '" "OpenBabel::OBBitVec &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "RestrictedMatch" "', argument " "3"" of type '" "OpenBabel::OBBitVec &""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBBitVec * >(argp3);
  result = (bool)(arg1)->RestrictedMatch(*arg2,*arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBSmartsPattern_restricted_match(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_std__vectorTstd__pairTint_int_t_t, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_OBSmartsPattern_restricted_match__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_OpenBabel__OBBitVec, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_OBSmartsPattern_restricted_match__SWIG_3(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_OpenBabel__OBBitVec, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_bool(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_OBSmartsPattern_restricted_match__SWIG_2(nargs, args, self);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_std__vectorTstd__pairTint_int_t_t, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_bool(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_OBSmartsPattern_restricted_match__SWIG_0(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBSmartsPattern_restricted_match'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSmartsPattern_num_matches(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSmartsPattern *arg1 = (OpenBabel::OBSmartsPattern *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NumMatches" "', argument " "1"" of type '" "OpenBabel::OBSmartsPattern const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSmartsPattern * >(argp1);
  result = (unsigned int)((OpenBabel::OBSmartsPattern const *)arg1)->NumMatches();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSmartsPattern_get_map_list(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSmartsPattern *arg1 = (OpenBabel::OBSmartsPattern *) 0 ;
  std::vector<std::vector<int > > *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetMapList" "', argument " "1"" of type '" "OpenBabel::OBSmartsPattern *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSmartsPattern * >(argp1);
  {
    std::vector<std::vector<int > > &_result_ref = (arg1)->GetMapList();
    result = (std::vector<std::vector<int > > *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorTstd__vectorTint_t_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSmartsPattern_begin_mlist(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSmartsPattern *arg1 = (OpenBabel::OBSmartsPattern *) 0 ;
  SwigValueWrapper<std::vector<std::vector<int > >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginMList" "', argument " "1"" of type '" "OpenBabel::OBSmartsPattern *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSmartsPattern * >(argp1);
  result = (arg1)->BeginMList();
  vresult = SWIG_NewPointerObj((new std::vector<std::vector<int > >::iterator(static_cast< const std::vector<std::vector<int > >::iterator& >(result))), SWIGTYPE_p_std__vectorTstd__vectorTint_t_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSmartsPattern_end_mlist(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSmartsPattern *arg1 = (OpenBabel::OBSmartsPattern *) 0 ;
  SwigValueWrapper<std::vector<std::vector<int > >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EndMList" "', argument " "1"" of type '" "OpenBabel::OBSmartsPattern *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSmartsPattern * >(argp1);
  result = (arg1)->EndMList();
  vresult = SWIG_NewPointerObj((new std::vector<std::vector<int > >::iterator(static_cast< const std::vector<std::vector<int > >::iterator& >(result))), SWIGTYPE_p_std__vectorTstd__vectorTint_t_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSmartsPattern_get_umap_list(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSmartsPattern *arg1 = (OpenBabel::OBSmartsPattern *) 0 ;
  std::vector<std::vector<int > > *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetUMapList" "', argument " "1"" of type '" "OpenBabel::OBSmartsPattern *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSmartsPattern * >(argp1);
  {
    std::vector<std::vector<int > > &_result_ref = (arg1)->GetUMapList();
    result = (std::vector<std::vector<int > > *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorTstd__vectorTint_t_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSmartsPattern_write_map_list(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSmartsPattern *arg1 = (OpenBabel::OBSmartsPattern *) 0 ;
  std::ostream *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "WriteMapList" "', argument " "1"" of type '" "OpenBabel::OBSmartsPattern *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSmartsPattern * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__ostream,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "WriteMapList" "', argument " "2"" of type '" "std::ostream &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "WriteMapList" "', argument " "2"" of type '" "std::ostream &""'"); 
  }
  arg2 = reinterpret_cast< std::ostream * >(argp2);
  (arg1)->WriteMapList(*arg2);
  return Qnil;
fail:
  return Qnil;
}


swig_class cOBSSMatch;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBSSMatch_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBSSMatch_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBSSMatch);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBSSMatch(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = 0 ;
  OpenBabel::Pattern *arg2 = (OpenBabel::Pattern *) 0 ;
  OpenBabel::OBSSMatch *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBMol,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBSSMatch" "', argument " "1"" of type '" "OpenBabel::OBMol &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBSSMatch" "', argument " "1"" of type '" "OpenBabel::OBMol &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_OpenBabel__Pattern, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::OBSSMatch" "', argument " "2"" of type '" "OpenBabel::Pattern *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::Pattern * >(argp2);
  result = (OpenBabel::OBSSMatch *)new OpenBabel::OBSSMatch(*arg1,arg2);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBSSMatch(OpenBabel::OBSSMatch *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_OBSSMatch_match__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSSMatch *arg1 = (OpenBabel::OBSSMatch *) 0 ;
  std::vector<std::vector<int > > *arg2 = 0 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSSMatch, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Match" "', argument " "1"" of type '" "OpenBabel::OBSSMatch *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSSMatch * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTstd__vectorTint_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Match" "', argument " "2"" of type '" "std::vector<std::vector<int > > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Match" "', argument " "2"" of type '" "std::vector<std::vector<int > > &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<std::vector<int > > * >(argp2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Match" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  (arg1)->Match(*arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBSSMatch_match__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSSMatch *arg1 = (OpenBabel::OBSSMatch *) 0 ;
  std::vector<std::vector<int > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSSMatch, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Match" "', argument " "1"" of type '" "OpenBabel::OBSSMatch *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBSSMatch * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTstd__vectorTint_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Match" "', argument " "2"" of type '" "std::vector<std::vector<int > > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Match" "', argument " "2"" of type '" "std::vector<std::vector<int > > &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<std::vector<int > > * >(argp2);
  (arg1)->Match(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBSSMatch_match(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBSSMatch, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__vectorTstd__vectorTint_t_t, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBSSMatch_match__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBSSMatch, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__vectorTstd__vectorTint_t_t, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_OBSSMatch_match__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBSSMatch_match'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_smarts_lex_replace(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  std::vector<std::pair<std::string,std::string > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_std__string,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::SmartsLexReplace" "', argument " "1"" of type '" "std::string &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::SmartsLexReplace" "', argument " "1"" of type '" "std::string &""'"); 
  }
  arg1 = reinterpret_cast< std::string * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_std__vectorTstd__pairTstd__string_std__string_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::SmartsLexReplace" "', argument " "2"" of type '" "std::vector<std::pair<std::string,std::string > > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::SmartsLexReplace" "', argument " "2"" of type '" "std::vector<std::pair<std::string,std::string > > &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<std::pair<std::string,std::string > > * >(argp2);
  OpenBabel::SmartsLexReplace(*arg1,*arg2);
  return Qnil;
fail:
  return Qnil;
}


swig_class cOBFingerprint;

SWIGINTERN VALUE
_wrap_OBFingerprint_iter(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBFingerprint > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    OpenBabel::PluginIter<OpenBabel::OBFingerprint > &_result_ref = OpenBabel::OBFingerprint::Iter();
    result = (OpenBabel::PluginIter<OpenBabel::OBFingerprint > *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBFingerprint_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFingerprint_find_default_type(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFingerprint *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBFingerprint *)OpenBabel::OBFingerprint::FindDefaultType();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBFingerprint, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFingerprint_find_type(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  OpenBabel::OBFingerprint *result = 0 ;
  int res1 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBFingerprint::FindType" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBFingerprint::FindType" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  result = (OpenBabel::OBFingerprint *)OpenBabel::OBFingerprint::FindType((std::string const &)*arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBFingerprint, 0 |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  return vresult;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBFingerprint(OpenBabel::OBFingerprint *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_OBFingerprint_set_bit(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFingerprint *arg1 = (OpenBabel::OBFingerprint *) 0 ;
  std::vector<unsigned int > *arg2 = 0 ;
  unsigned int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFingerprint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetBit" "', argument " "1"" of type '" "OpenBabel::OBFingerprint *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFingerprint * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTunsigned_int_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetBit" "', argument " "2"" of type '" "std::vector<unsigned int > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetBit" "', argument " "2"" of type '" "std::vector<unsigned int > &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<unsigned int > * >(argp2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SetBit" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  (arg1)->SetBit(*arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFingerprint_fold(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFingerprint *arg1 = (OpenBabel::OBFingerprint *) 0 ;
  std::vector<unsigned int > *arg2 = 0 ;
  unsigned int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFingerprint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Fold" "', argument " "1"" of type '" "OpenBabel::OBFingerprint *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFingerprint * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTunsigned_int_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Fold" "', argument " "2"" of type '" "std::vector<unsigned int > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Fold" "', argument " "2"" of type '" "std::vector<unsigned int > &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<unsigned int > * >(argp2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Fold" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  (arg1)->Fold(*arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFingerprint_get_fingerprint__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFingerprint *arg1 = (OpenBabel::OBFingerprint *) 0 ;
  OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  std::vector<unsigned int > *arg3 = 0 ;
  int arg4 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFingerprint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetFingerprint" "', argument " "1"" of type '" "OpenBabel::OBFingerprint *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFingerprint * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetFingerprint" "', argument " "2"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_std__vectorTunsigned_int_t,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "GetFingerprint" "', argument " "3"" of type '" "std::vector<unsigned int > &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GetFingerprint" "', argument " "3"" of type '" "std::vector<unsigned int > &""'"); 
  }
  arg3 = reinterpret_cast< std::vector<unsigned int > * >(argp3);
  ecode4 = SWIG_AsVal_int(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "GetFingerprint" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = static_cast< int >(val4);
  result = (bool)(arg1)->GetFingerprint(arg2,*arg3,arg4);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFingerprint_get_fingerprint__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFingerprint *arg1 = (OpenBabel::OBFingerprint *) 0 ;
  OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  std::vector<unsigned int > *arg3 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFingerprint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetFingerprint" "', argument " "1"" of type '" "OpenBabel::OBFingerprint *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFingerprint * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetFingerprint" "', argument " "2"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_std__vectorTunsigned_int_t,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "GetFingerprint" "', argument " "3"" of type '" "std::vector<unsigned int > &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GetFingerprint" "', argument " "3"" of type '" "std::vector<unsigned int > &""'"); 
  }
  arg3 = reinterpret_cast< std::vector<unsigned int > * >(argp3);
  result = (bool)(arg1)->GetFingerprint(arg2,*arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBFingerprint_get_fingerprint(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBFingerprint, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBBase, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_std__vectorTunsigned_int_t, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_OBFingerprint_get_fingerprint__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBFingerprint, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBBase, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_std__vectorTunsigned_int_t, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_OBFingerprint_get_fingerprint__SWIG_0(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBFingerprint_get_fingerprint'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFingerprint_description(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFingerprint *arg1 = (OpenBabel::OBFingerprint *) 0 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFingerprint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Description" "', argument " "1"" of type '" "OpenBabel::OBFingerprint *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFingerprint * >(argp1);
  result = (arg1)->Description();
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFingerprint_flags(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFingerprint *arg1 = (OpenBabel::OBFingerprint *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFingerprint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Flags" "', argument " "1"" of type '" "OpenBabel::OBFingerprint *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFingerprint * >(argp1);
  result = (unsigned int)(arg1)->Flags();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFingerprint_tanimoto__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector<unsigned int > *arg1 = 0 ;
  std::vector<unsigned int > *arg2 = 0 ;
  double result;
  std::vector<unsigned int > temp1 ;
  std::vector<unsigned int > temp2 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  {
    if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
      unsigned int size = RARRAY_LEN(argv[0]);
      temp1 = std::vector<unsigned int >(size);
      arg1 = &temp1;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(argv[0])[i];
        if (FIXNUM_P(o))
        temp1[i] = (unsigned int)(FIX2INT(o));
        else
        rb_raise(rb_eTypeError,
          "wrong argument type"
          " (expected vector<""unsigned int" ">)");
      }
    } else {
      SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_std__vectorTunsigned_int_t, 1);
    }
  }
  {
    if (rb_obj_is_kind_of(argv[1],rb_cArray)) {
      unsigned int size = RARRAY_LEN(argv[1]);
      temp2 = std::vector<unsigned int >(size);
      arg2 = &temp2;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(argv[1])[i];
        if (FIXNUM_P(o))
        temp2[i] = (unsigned int)(FIX2INT(o));
        else
        rb_raise(rb_eTypeError,
          "wrong argument type"
          " (expected vector<""unsigned int" ">)");
      }
    } else {
      SWIG_ConvertPtr(argv[1], (void **) &arg2, SWIGTYPE_p_std__vectorTunsigned_int_t, 1);
    }
  }
  result = (double)OpenBabel::OBFingerprint::Tanimoto((std::vector<unsigned int > const &)*arg1,(std::vector<unsigned int > const &)*arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFingerprint_tanimoto__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::vector<unsigned int > *arg1 = 0 ;
  unsigned int *arg2 = (unsigned int *) 0 ;
  double result;
  std::vector<unsigned int > temp1 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  {
    if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
      unsigned int size = RARRAY_LEN(argv[0]);
      temp1 = std::vector<unsigned int >(size);
      arg1 = &temp1;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(argv[0])[i];
        if (FIXNUM_P(o))
        temp1[i] = (unsigned int)(FIX2INT(o));
        else
        rb_raise(rb_eTypeError,
          "wrong argument type"
          " (expected vector<""unsigned int" ">)");
      }
    } else {
      SWIG_ConvertPtr(argv[0], (void **) &arg1, SWIGTYPE_p_std__vectorTunsigned_int_t, 1);
    }
  }
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_unsigned_int, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::OBFingerprint::Tanimoto" "', argument " "2"" of type '" "unsigned int const *""'"); 
  }
  arg2 = reinterpret_cast< unsigned int * >(argp2);
  result = (double)OpenBabel::OBFingerprint::Tanimoto((std::vector<unsigned int > const &)*arg1,(unsigned int const *)arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBFingerprint_tanimoto(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 2) {
    int _v;
    {
      /* native sequence? */
      if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
        unsigned int size = RARRAY_LEN(argv[0]);
        if (size == 0) {
          /* an empty sequence can be of any type */
          _v = 1;
        } else {
          /* check the first element only */
          VALUE o = RARRAY_PTR(argv[0])[0];
          if (FIXNUM_P(o))
          _v = 1;
          else
          _v = 0;
        }
      } else {
        /* wrapped vector? */
        std::vector<unsigned int >* v;
        if (SWIG_ConvertPtr(argv[0],(void **) &v, 
            SWIGTYPE_p_std__vectorTunsigned_int_t,0) != -1)
        _v = 1;
        else
        _v = 0;
      }
    }
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_unsigned_int, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBFingerprint_tanimoto__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      /* native sequence? */
      if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
        unsigned int size = RARRAY_LEN(argv[0]);
        if (size == 0) {
          /* an empty sequence can be of any type */
          _v = 1;
        } else {
          /* check the first element only */
          VALUE o = RARRAY_PTR(argv[0])[0];
          if (FIXNUM_P(o))
          _v = 1;
          else
          _v = 0;
        }
      } else {
        /* wrapped vector? */
        std::vector<unsigned int >* v;
        if (SWIG_ConvertPtr(argv[0],(void **) &v, 
            SWIGTYPE_p_std__vectorTunsigned_int_t,0) != -1)
        _v = 1;
        else
        _v = 0;
      }
    }
    if (_v) {
      {
        /* native sequence? */
        if (rb_obj_is_kind_of(argv[1],rb_cArray)) {
          unsigned int size = RARRAY_LEN(argv[1]);
          if (size == 0) {
            /* an empty sequence can be of any type */
            _v = 1;
          } else {
            /* check the first element only */
            VALUE o = RARRAY_PTR(argv[1])[0];
            if (FIXNUM_P(o))
            _v = 1;
            else
            _v = 0;
          }
        } else {
          /* wrapped vector? */
          std::vector<unsigned int >* v;
          if (SWIG_ConvertPtr(argv[1],(void **) &v, 
              SWIGTYPE_p_std__vectorTunsigned_int_t,0) != -1)
          _v = 1;
          else
          _v = 0;
        }
      }
      if (_v) {
        return _wrap_OBFingerprint_tanimoto__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBFingerprint_tanimoto'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFingerprint_getbitsperint(int argc, VALUE *argv, VALUE self) {
  unsigned int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (unsigned int)OpenBabel::OBFingerprint::Getbitsperint();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFingerprint_find_fingerprint(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  OpenBabel::OBFingerprint *result = 0 ;
  int res1 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBFingerprint::FindFingerprint" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBFingerprint::FindFingerprint" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  result = (OpenBabel::OBFingerprint *)OpenBabel::OBFingerprint::FindFingerprint((std::string const &)*arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBFingerprint, 0 |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  return vresult;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


swig_class cFptIndexHeader;

SWIGINTERN VALUE
_wrap_FptIndexHeader_headerlength_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FptIndexHeader *arg1 = (OpenBabel::FptIndexHeader *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FptIndexHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "headerlength" "', argument " "1"" of type '" "OpenBabel::FptIndexHeader *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::FptIndexHeader * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "headerlength" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  if (arg1) (arg1)->headerlength = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FptIndexHeader_headerlength_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FptIndexHeader *arg1 = (OpenBabel::FptIndexHeader *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FptIndexHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "headerlength" "', argument " "1"" of type '" "OpenBabel::FptIndexHeader *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::FptIndexHeader * >(argp1);
  result = (unsigned int) ((arg1)->headerlength);
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FptIndexHeader_nEntries_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FptIndexHeader *arg1 = (OpenBabel::FptIndexHeader *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FptIndexHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "nEntries" "', argument " "1"" of type '" "OpenBabel::FptIndexHeader *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::FptIndexHeader * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "nEntries" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  if (arg1) (arg1)->nEntries = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FptIndexHeader_nEntries_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FptIndexHeader *arg1 = (OpenBabel::FptIndexHeader *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FptIndexHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "nEntries" "', argument " "1"" of type '" "OpenBabel::FptIndexHeader *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::FptIndexHeader * >(argp1);
  result = (unsigned int) ((arg1)->nEntries);
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FptIndexHeader_words_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FptIndexHeader *arg1 = (OpenBabel::FptIndexHeader *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FptIndexHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "words" "', argument " "1"" of type '" "OpenBabel::FptIndexHeader *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::FptIndexHeader * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "words" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  if (arg1) (arg1)->words = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FptIndexHeader_words_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FptIndexHeader *arg1 = (OpenBabel::FptIndexHeader *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FptIndexHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "words" "', argument " "1"" of type '" "OpenBabel::FptIndexHeader *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::FptIndexHeader * >(argp1);
  result = (unsigned int) ((arg1)->words);
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FptIndexHeader_fpid_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FptIndexHeader *arg1 = (OpenBabel::FptIndexHeader *) 0 ;
  char *arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char temp2[16] ;
  int res2 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FptIndexHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fpid" "', argument " "1"" of type '" "OpenBabel::FptIndexHeader *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::FptIndexHeader * >(argp1);
  res2 = SWIG_AsCharArray(argv[0], temp2, 16);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "fpid" "', argument " "2"" of type '" "char [16]""'");
  }
  arg2 = reinterpret_cast< char * >(temp2);
  if (arg2) memcpy(arg1->fpid,arg2,16*sizeof(char));
  else memset(arg1->fpid,0,16*sizeof(char));
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FptIndexHeader_fpid_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FptIndexHeader *arg1 = (OpenBabel::FptIndexHeader *) 0 ;
  char *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FptIndexHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fpid" "', argument " "1"" of type '" "OpenBabel::FptIndexHeader *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::FptIndexHeader * >(argp1);
  result = (char *)(char *) ((arg1)->fpid);
  {
    size_t size = 16;
    
    while (size && (result[size - 1] == '\0')) --size;
    
    vresult = SWIG_FromCharPtrAndSize(result, size);
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FptIndexHeader_datafilename_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FptIndexHeader *arg1 = (OpenBabel::FptIndexHeader *) 0 ;
  char *arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char temp2[256] ;
  int res2 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FptIndexHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "datafilename" "', argument " "1"" of type '" "OpenBabel::FptIndexHeader *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::FptIndexHeader * >(argp1);
  res2 = SWIG_AsCharArray(argv[0], temp2, 256);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "datafilename" "', argument " "2"" of type '" "char [256]""'");
  }
  arg2 = reinterpret_cast< char * >(temp2);
  if (arg2) memcpy(arg1->datafilename,arg2,256*sizeof(char));
  else memset(arg1->datafilename,0,256*sizeof(char));
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FptIndexHeader_datafilename_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FptIndexHeader *arg1 = (OpenBabel::FptIndexHeader *) 0 ;
  char *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FptIndexHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "datafilename" "', argument " "1"" of type '" "OpenBabel::FptIndexHeader *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::FptIndexHeader * >(argp1);
  result = (char *)(char *) ((arg1)->datafilename);
  {
    size_t size = 256;
    
    while (size && (result[size - 1] == '\0')) --size;
    
    vresult = SWIG_FromCharPtrAndSize(result, size);
  }
  return vresult;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_FptIndexHeader_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_FptIndexHeader_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__FptIndexHeader);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_FptIndexHeader(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FptIndexHeader *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::FptIndexHeader *)new OpenBabel::FptIndexHeader();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_FptIndexHeader(OpenBabel::FptIndexHeader *arg1) {
    delete arg1;
}

swig_class cFptIndex;

SWIGINTERN VALUE
_wrap_FptIndex_header_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FptIndex *arg1 = (OpenBabel::FptIndex *) 0 ;
  OpenBabel::FptIndexHeader *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FptIndex, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "header" "', argument " "1"" of type '" "OpenBabel::FptIndex *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::FptIndex * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__FptIndexHeader,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "header" "', argument " "2"" of type '" "OpenBabel::FptIndexHeader const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "header" "', argument " "2"" of type '" "OpenBabel::FptIndexHeader const &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::FptIndexHeader * >(argp2);
  if (arg1) (arg1)->header = *arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FptIndex_header_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FptIndex *arg1 = (OpenBabel::FptIndex *) 0 ;
  OpenBabel::FptIndexHeader *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FptIndex, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "header" "', argument " "1"" of type '" "OpenBabel::FptIndex *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::FptIndex * >(argp1);
  {
    OpenBabel::FptIndexHeader const &_result_ref =  ((arg1)->header);
    result = (OpenBabel::FptIndexHeader *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__FptIndexHeader, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FptIndex_fptdata_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FptIndex *arg1 = (OpenBabel::FptIndex *) 0 ;
  std::vector<unsigned int > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector<unsigned int > temp2 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FptIndex, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fptdata" "', argument " "1"" of type '" "OpenBabel::FptIndex *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::FptIndex * >(argp1);
  {
    if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
      unsigned int size = RARRAY_LEN(argv[0]);
      temp2 = std::vector<unsigned int >(size);
      arg2 = &temp2;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(argv[0])[i];
        if (FIXNUM_P(o))
        temp2[i] = (unsigned int)(FIX2INT(o));
        else
        rb_raise(rb_eTypeError,
          "wrong argument type"
          " (expected vector<""unsigned int" ">)");
      }
    } else {
      SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_std__vectorTunsigned_int_t, 1);
    }
  }
  if (arg1) (arg1)->fptdata = *arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FptIndex_fptdata_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FptIndex *arg1 = (OpenBabel::FptIndex *) 0 ;
  std::vector<unsigned int > *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FptIndex, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "fptdata" "', argument " "1"" of type '" "OpenBabel::FptIndex *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::FptIndex * >(argp1);
  {
    std::vector<unsigned int > const &_result_ref =  ((arg1)->fptdata);
    result = (std::vector<unsigned int > *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorTunsigned_int_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FptIndex_seekdata_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FptIndex *arg1 = (OpenBabel::FptIndex *) 0 ;
  std::vector<unsigned int > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector<unsigned int > temp2 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FptIndex, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "seekdata" "', argument " "1"" of type '" "OpenBabel::FptIndex *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::FptIndex * >(argp1);
  {
    if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
      unsigned int size = RARRAY_LEN(argv[0]);
      temp2 = std::vector<unsigned int >(size);
      arg2 = &temp2;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(argv[0])[i];
        if (FIXNUM_P(o))
        temp2[i] = (unsigned int)(FIX2INT(o));
        else
        rb_raise(rb_eTypeError,
          "wrong argument type"
          " (expected vector<""unsigned int" ">)");
      }
    } else {
      SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_std__vectorTunsigned_int_t, 1);
    }
  }
  if (arg1) (arg1)->seekdata = *arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FptIndex_seekdata_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FptIndex *arg1 = (OpenBabel::FptIndex *) 0 ;
  std::vector<unsigned int > *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FptIndex, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "seekdata" "', argument " "1"" of type '" "OpenBabel::FptIndex *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::FptIndex * >(argp1);
  {
    std::vector<unsigned int > const &_result_ref =  ((arg1)->seekdata);
    result = (std::vector<unsigned int > *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorTunsigned_int_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FptIndex_read(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FptIndex *arg1 = (OpenBabel::FptIndex *) 0 ;
  std::istream *arg2 = (std::istream *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FptIndex, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Read" "', argument " "1"" of type '" "OpenBabel::FptIndex *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::FptIndex * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_std__istream, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Read" "', argument " "2"" of type '" "std::istream *""'"); 
  }
  arg2 = reinterpret_cast< std::istream * >(argp2);
  result = (bool)(arg1)->Read(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FptIndex_check_fp(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FptIndex *arg1 = (OpenBabel::FptIndex *) 0 ;
  OpenBabel::OBFingerprint *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FptIndex, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CheckFP" "', argument " "1"" of type '" "OpenBabel::FptIndex *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::FptIndex * >(argp1);
  result = (OpenBabel::OBFingerprint *)(arg1)->CheckFP();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBFingerprint, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_FptIndex_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_FptIndex_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__FptIndex);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_FptIndex(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FptIndex *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::FptIndex *)new OpenBabel::FptIndex();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_FptIndex(OpenBabel::FptIndex *arg1) {
    delete arg1;
}

swig_class cFastSearch;

SWIGINTERN VALUE
_wrap_FastSearch_read_index_file(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FastSearch *arg1 = (OpenBabel::FastSearch *) 0 ;
  std::string arg2 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FastSearch, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ReadIndexFile" "', argument " "1"" of type '" "OpenBabel::FastSearch *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::FastSearch * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "ReadIndexFile" "', argument " "2"" of type '" "std::string""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = (arg1)->ReadIndexFile(arg2);
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FastSearch_read_index(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FastSearch *arg1 = (OpenBabel::FastSearch *) 0 ;
  std::istream *arg2 = (std::istream *) 0 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FastSearch, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ReadIndex" "', argument " "1"" of type '" "OpenBabel::FastSearch *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::FastSearch * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_std__istream, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ReadIndex" "', argument " "2"" of type '" "std::istream *""'"); 
  }
  arg2 = reinterpret_cast< std::istream * >(argp2);
  result = (arg1)->ReadIndex(arg2);
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_FastSearch(OpenBabel::FastSearch *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_FastSearch_find(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FastSearch *arg1 = (OpenBabel::FastSearch *) 0 ;
  OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  std::vector<unsigned int > *arg3 = 0 ;
  unsigned int arg4 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  unsigned int val4 ;
  int ecode4 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FastSearch, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Find" "', argument " "1"" of type '" "OpenBabel::FastSearch *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::FastSearch * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Find" "', argument " "2"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_std__vectorTunsigned_int_t,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Find" "', argument " "3"" of type '" "std::vector<unsigned int > &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Find" "', argument " "3"" of type '" "std::vector<unsigned int > &""'"); 
  }
  arg3 = reinterpret_cast< std::vector<unsigned int > * >(argp3);
  ecode4 = SWIG_AsVal_unsigned_SS_int(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Find" "', argument " "4"" of type '" "unsigned int""'");
  } 
  arg4 = static_cast< unsigned int >(val4);
  result = (bool)(arg1)->Find(arg2,*arg3,arg4);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FastSearch_find_match(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FastSearch *arg1 = (OpenBabel::FastSearch *) 0 ;
  OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  std::vector<unsigned int > *arg3 = 0 ;
  unsigned int arg4 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  unsigned int val4 ;
  int ecode4 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FastSearch, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FindMatch" "', argument " "1"" of type '" "OpenBabel::FastSearch *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::FastSearch * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "FindMatch" "', argument " "2"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_std__vectorTunsigned_int_t,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "FindMatch" "', argument " "3"" of type '" "std::vector<unsigned int > &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "FindMatch" "', argument " "3"" of type '" "std::vector<unsigned int > &""'"); 
  }
  arg3 = reinterpret_cast< std::vector<unsigned int > * >(argp3);
  ecode4 = SWIG_AsVal_unsigned_SS_int(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "FindMatch" "', argument " "4"" of type '" "unsigned int""'");
  } 
  arg4 = static_cast< unsigned int >(val4);
  result = (bool)(arg1)->FindMatch(arg2,*arg3,arg4);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FastSearch_find_similar__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FastSearch *arg1 = (OpenBabel::FastSearch *) 0 ;
  OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  std::multimap<double,unsigned int > *arg3 = 0 ;
  double arg4 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FastSearch, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FindSimilar" "', argument " "1"" of type '" "OpenBabel::FastSearch *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::FastSearch * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "FindSimilar" "', argument " "2"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_std__multimapTdouble_unsigned_int_t,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "FindSimilar" "', argument " "3"" of type '" "std::multimap<double,unsigned int > &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "FindSimilar" "', argument " "3"" of type '" "std::multimap<double,unsigned int > &""'"); 
  }
  arg3 = reinterpret_cast< std::multimap<double,unsigned int > * >(argp3);
  ecode4 = SWIG_AsVal_double(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "FindSimilar" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = static_cast< double >(val4);
  result = (bool)(arg1)->FindSimilar(arg2,*arg3,arg4);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FastSearch_find_similar__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FastSearch *arg1 = (OpenBabel::FastSearch *) 0 ;
  OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  std::multimap<double,unsigned int > *arg3 = 0 ;
  int arg4 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FastSearch, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FindSimilar" "', argument " "1"" of type '" "OpenBabel::FastSearch *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::FastSearch * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "FindSimilar" "', argument " "2"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_std__multimapTdouble_unsigned_int_t,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "FindSimilar" "', argument " "3"" of type '" "std::multimap<double,unsigned int > &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "FindSimilar" "', argument " "3"" of type '" "std::multimap<double,unsigned int > &""'"); 
  }
  arg3 = reinterpret_cast< std::multimap<double,unsigned int > * >(argp3);
  ecode4 = SWIG_AsVal_int(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "FindSimilar" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = static_cast< int >(val4);
  result = (bool)(arg1)->FindSimilar(arg2,*arg3,arg4);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FastSearch_find_similar__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FastSearch *arg1 = (OpenBabel::FastSearch *) 0 ;
  OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  std::multimap<double,unsigned int > *arg3 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FastSearch, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FindSimilar" "', argument " "1"" of type '" "OpenBabel::FastSearch *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::FastSearch * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "FindSimilar" "', argument " "2"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_std__multimapTdouble_unsigned_int_t,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "FindSimilar" "', argument " "3"" of type '" "std::multimap<double,unsigned int > &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "FindSimilar" "', argument " "3"" of type '" "std::multimap<double,unsigned int > &""'"); 
  }
  arg3 = reinterpret_cast< std::multimap<double,unsigned int > * >(argp3);
  result = (bool)(arg1)->FindSimilar(arg2,*arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_FastSearch_find_similar(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__FastSearch, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBBase, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_std__multimapTdouble_unsigned_int_t, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_FastSearch_find_similar__SWIG_2(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__FastSearch, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBBase, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_std__multimapTdouble_unsigned_int_t, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_FastSearch_find_similar__SWIG_1(nargs, args, self);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__FastSearch, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBBase, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_std__multimapTdouble_unsigned_int_t, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_double(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_FastSearch_find_similar__SWIG_0(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'FastSearch_find_similar'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FastSearch_get_fingerprint(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FastSearch *arg1 = (OpenBabel::FastSearch *) 0 ;
  OpenBabel::OBFingerprint *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FastSearch, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetFingerprint" "', argument " "1"" of type '" "OpenBabel::FastSearch const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::FastSearch * >(argp1);
  result = (OpenBabel::OBFingerprint *)((OpenBabel::FastSearch const *)arg1)->GetFingerprint();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBFingerprint, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FastSearch_get_index_header(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FastSearch *arg1 = (OpenBabel::FastSearch *) 0 ;
  OpenBabel::FptIndexHeader *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FastSearch, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetIndexHeader" "', argument " "1"" of type '" "OpenBabel::FastSearch const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::FastSearch * >(argp1);
  {
    OpenBabel::FptIndexHeader const &_result_ref = ((OpenBabel::FastSearch const *)arg1)->GetIndexHeader();
    result = (OpenBabel::FptIndexHeader *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__FptIndexHeader, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_FastSearch_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_FastSearch_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__FastSearch);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_FastSearch(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FastSearch *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::FastSearch *)new OpenBabel::FastSearch();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


swig_class cFastSearchIndexer;

SWIGINTERN VALUE
_wrap_new_FastSearchIndexer__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  std::ostream *arg2 = (std::ostream *) 0 ;
  std::string *arg3 = 0 ;
  int arg4 ;
  OpenBabel::FastSearchIndexer *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_std__string,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::FastSearchIndexer" "', argument " "1"" of type '" "std::string &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::FastSearchIndexer" "', argument " "1"" of type '" "std::string &""'"); 
  }
  arg1 = reinterpret_cast< std::string * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_std__ostream, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::FastSearchIndexer" "', argument " "2"" of type '" "std::ostream *""'"); 
  }
  arg2 = reinterpret_cast< std::ostream * >(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_std__string,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "OpenBabel::FastSearchIndexer" "', argument " "3"" of type '" "std::string &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::FastSearchIndexer" "', argument " "3"" of type '" "std::string &""'"); 
  }
  arg3 = reinterpret_cast< std::string * >(argp3);
  ecode4 = SWIG_AsVal_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "OpenBabel::FastSearchIndexer" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = static_cast< int >(val4);
  result = (OpenBabel::FastSearchIndexer *)new OpenBabel::FastSearchIndexer(*arg1,arg2,*arg3,arg4);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_FastSearchIndexer__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  std::ostream *arg2 = (std::ostream *) 0 ;
  std::string *arg3 = 0 ;
  OpenBabel::FastSearchIndexer *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_std__string,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::FastSearchIndexer" "', argument " "1"" of type '" "std::string &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::FastSearchIndexer" "', argument " "1"" of type '" "std::string &""'"); 
  }
  arg1 = reinterpret_cast< std::string * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_std__ostream, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::FastSearchIndexer" "', argument " "2"" of type '" "std::ostream *""'"); 
  }
  arg2 = reinterpret_cast< std::ostream * >(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_std__string,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "OpenBabel::FastSearchIndexer" "', argument " "3"" of type '" "std::string &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::FastSearchIndexer" "', argument " "3"" of type '" "std::string &""'"); 
  }
  arg3 = reinterpret_cast< std::string * >(argp3);
  result = (OpenBabel::FastSearchIndexer *)new OpenBabel::FastSearchIndexer(*arg1,arg2,*arg3);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_FastSearchIndexer_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_FastSearchIndexer_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__FastSearchIndexer);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_FastSearchIndexer__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FptIndex *arg1 = (OpenBabel::FptIndex *) 0 ;
  std::ostream *arg2 = (std::ostream *) 0 ;
  OpenBabel::FastSearchIndexer *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_OpenBabel__FptIndex, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::FastSearchIndexer" "', argument " "1"" of type '" "OpenBabel::FptIndex *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::FptIndex * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_std__ostream, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::FastSearchIndexer" "', argument " "2"" of type '" "std::ostream *""'"); 
  }
  arg2 = reinterpret_cast< std::ostream * >(argp2);
  result = (OpenBabel::FastSearchIndexer *)new OpenBabel::FastSearchIndexer(arg1,arg2);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_FastSearchIndexer(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs;
  if (argc > 4) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__FptIndex, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__ostream, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_FastSearchIndexer__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__string, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__ostream, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_std__string, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_new_FastSearchIndexer__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__string, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__ostream, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_std__string, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_new_FastSearchIndexer__SWIG_0(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_FastSearchIndexer'");
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_FastSearchIndexer(OpenBabel::FastSearchIndexer *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_FastSearchIndexer_add(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FastSearchIndexer *arg1 = (OpenBabel::FastSearchIndexer *) 0 ;
  OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  std::streampos arg3 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FastSearchIndexer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Add" "', argument " "1"" of type '" "OpenBabel::FastSearchIndexer *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::FastSearchIndexer * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Add" "', argument " "2"" of type '" "OpenBabel::OBBase *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  {
    res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_std__streampos,  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Add" "', argument " "3"" of type '" "std::streampos""'"); 
    }  
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Add" "', argument " "3"" of type '" "std::streampos""'");
    } else {
      arg3 = *(reinterpret_cast< std::streampos * >(argp3));
    }
  }
  result = (bool)(arg1)->Add(arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


swig_class cOBFFParameter;

SWIGINTERN VALUE
_wrap_OBFFParameter_a_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "a" "', argument " "1"" of type '" "OpenBabel::OBFFParameter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "a" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  if (arg1) (arg1)->a = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFParameter_a_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "a" "', argument " "1"" of type '" "OpenBabel::OBFFParameter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1);
  result = (int) ((arg1)->a);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFParameter_b_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "b" "', argument " "1"" of type '" "OpenBabel::OBFFParameter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "b" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  if (arg1) (arg1)->b = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFParameter_b_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "b" "', argument " "1"" of type '" "OpenBabel::OBFFParameter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1);
  result = (int) ((arg1)->b);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFParameter_c_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "c" "', argument " "1"" of type '" "OpenBabel::OBFFParameter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "c" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  if (arg1) (arg1)->c = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFParameter_c_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "c" "', argument " "1"" of type '" "OpenBabel::OBFFParameter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1);
  result = (int) ((arg1)->c);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFParameter_d_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "d" "', argument " "1"" of type '" "OpenBabel::OBFFParameter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "d" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  if (arg1) (arg1)->d = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFParameter_d_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "d" "', argument " "1"" of type '" "OpenBabel::OBFFParameter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1);
  result = (int) ((arg1)->d);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFParameter__a_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_a" "', argument " "1"" of type '" "OpenBabel::OBFFParameter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "_a" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "_a" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  if (arg1) (arg1)->_a = *arg2;
  
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFParameter__a_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ;
  std::string *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_a" "', argument " "1"" of type '" "OpenBabel::OBFFParameter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1);
  {
    std::string const &_result_ref =  ((arg1)->_a);
    result = (std::string *) &_result_ref;
  }
  vresult = SWIG_From_std_string(static_cast< std::string >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFParameter__b_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_b" "', argument " "1"" of type '" "OpenBabel::OBFFParameter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "_b" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "_b" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  if (arg1) (arg1)->_b = *arg2;
  
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFParameter__b_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ;
  std::string *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_b" "', argument " "1"" of type '" "OpenBabel::OBFFParameter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1);
  {
    std::string const &_result_ref =  ((arg1)->_b);
    result = (std::string *) &_result_ref;
  }
  vresult = SWIG_From_std_string(static_cast< std::string >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFParameter__c_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_c" "', argument " "1"" of type '" "OpenBabel::OBFFParameter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "_c" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "_c" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  if (arg1) (arg1)->_c = *arg2;
  
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFParameter__c_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ;
  std::string *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_c" "', argument " "1"" of type '" "OpenBabel::OBFFParameter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1);
  {
    std::string const &_result_ref =  ((arg1)->_c);
    result = (std::string *) &_result_ref;
  }
  vresult = SWIG_From_std_string(static_cast< std::string >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFParameter__d_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_d" "', argument " "1"" of type '" "OpenBabel::OBFFParameter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "_d" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "_d" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  if (arg1) (arg1)->_d = *arg2;
  
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFParameter__d_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ;
  std::string *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_d" "', argument " "1"" of type '" "OpenBabel::OBFFParameter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1);
  {
    std::string const &_result_ref =  ((arg1)->_d);
    result = (std::string *) &_result_ref;
  }
  vresult = SWIG_From_std_string(static_cast< std::string >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFParameter_ipar1_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ipar1" "', argument " "1"" of type '" "OpenBabel::OBFFParameter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ipar1" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  if (arg1) (arg1)->ipar1 = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFParameter_ipar1_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ipar1" "', argument " "1"" of type '" "OpenBabel::OBFFParameter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1);
  result = (int) ((arg1)->ipar1);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFParameter_ipar2_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ipar2" "', argument " "1"" of type '" "OpenBabel::OBFFParameter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ipar2" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  if (arg1) (arg1)->ipar2 = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFParameter_ipar2_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ipar2" "', argument " "1"" of type '" "OpenBabel::OBFFParameter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1);
  result = (int) ((arg1)->ipar2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFParameter_ipar3_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ipar3" "', argument " "1"" of type '" "OpenBabel::OBFFParameter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ipar3" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  if (arg1) (arg1)->ipar3 = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFParameter_ipar3_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ipar3" "', argument " "1"" of type '" "OpenBabel::OBFFParameter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1);
  result = (int) ((arg1)->ipar3);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFParameter_ipar4_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ipar4" "', argument " "1"" of type '" "OpenBabel::OBFFParameter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ipar4" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  if (arg1) (arg1)->ipar4 = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFParameter_ipar4_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ipar4" "', argument " "1"" of type '" "OpenBabel::OBFFParameter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1);
  result = (int) ((arg1)->ipar4);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFParameter_ipar5_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ipar5" "', argument " "1"" of type '" "OpenBabel::OBFFParameter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ipar5" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  if (arg1) (arg1)->ipar5 = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFParameter_ipar5_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ipar5" "', argument " "1"" of type '" "OpenBabel::OBFFParameter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1);
  result = (int) ((arg1)->ipar5);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFParameter_dpar1_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "dpar1" "', argument " "1"" of type '" "OpenBabel::OBFFParameter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "dpar1" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  if (arg1) (arg1)->dpar1 = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFParameter_dpar1_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "dpar1" "', argument " "1"" of type '" "OpenBabel::OBFFParameter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1);
  result = (double) ((arg1)->dpar1);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFParameter_dpar2_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "dpar2" "', argument " "1"" of type '" "OpenBabel::OBFFParameter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "dpar2" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  if (arg1) (arg1)->dpar2 = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFParameter_dpar2_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "dpar2" "', argument " "1"" of type '" "OpenBabel::OBFFParameter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1);
  result = (double) ((arg1)->dpar2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFParameter_dpar3_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "dpar3" "', argument " "1"" of type '" "OpenBabel::OBFFParameter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "dpar3" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  if (arg1) (arg1)->dpar3 = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFParameter_dpar3_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "dpar3" "', argument " "1"" of type '" "OpenBabel::OBFFParameter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1);
  result = (double) ((arg1)->dpar3);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFParameter_dpar4_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "dpar4" "', argument " "1"" of type '" "OpenBabel::OBFFParameter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "dpar4" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  if (arg1) (arg1)->dpar4 = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFParameter_dpar4_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "dpar4" "', argument " "1"" of type '" "OpenBabel::OBFFParameter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1);
  result = (double) ((arg1)->dpar4);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFParameter_dpar5_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "dpar5" "', argument " "1"" of type '" "OpenBabel::OBFFParameter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "dpar5" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  if (arg1) (arg1)->dpar5 = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFParameter_dpar5_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "dpar5" "', argument " "1"" of type '" "OpenBabel::OBFFParameter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1);
  result = (double) ((arg1)->dpar5);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFParameter_clear(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "clear" "', argument " "1"" of type '" "OpenBabel::OBFFParameter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1);
  (arg1)->clear();
  return Qnil;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBFFParameter_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBFFParameter_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBFFParameter);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBFFParameter(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBFFParameter *)new OpenBabel::OBFFParameter();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBFFParameter(OpenBabel::OBFFParameter *arg1) {
    delete arg1;
}

swig_class cOBFFCalculation;

SWIGINTERN VALUE
_wrap_OBFFCalculation_energy_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFCalculation *arg1 = (OpenBabel::OBFFCalculation *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFCalculation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "energy" "', argument " "1"" of type '" "OpenBabel::OBFFCalculation *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFCalculation * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "energy" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  if (arg1) (arg1)->energy = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFCalculation_energy_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFCalculation *arg1 = (OpenBabel::OBFFCalculation *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFCalculation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "energy" "', argument " "1"" of type '" "OpenBabel::OBFFCalculation *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFCalculation * >(argp1);
  result = (double) ((arg1)->energy);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFCalculation_grada_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFCalculation *arg1 = (OpenBabel::OBFFCalculation *) 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFCalculation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "grada" "', argument " "1"" of type '" "OpenBabel::OBFFCalculation *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFCalculation * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "grada" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "grada" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  if (arg1) (arg1)->grada = *arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFCalculation_grada_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFCalculation *arg1 = (OpenBabel::OBFFCalculation *) 0 ;
  OpenBabel::vector3 *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFCalculation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "grada" "', argument " "1"" of type '" "OpenBabel::OBFFCalculation *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFCalculation * >(argp1);
  {
    OpenBabel::vector3 const &_result_ref =  ((arg1)->grada);
    result = (OpenBabel::vector3 *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFCalculation_gradb_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFCalculation *arg1 = (OpenBabel::OBFFCalculation *) 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFCalculation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gradb" "', argument " "1"" of type '" "OpenBabel::OBFFCalculation *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFCalculation * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "gradb" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gradb" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  if (arg1) (arg1)->gradb = *arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFCalculation_gradb_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFCalculation *arg1 = (OpenBabel::OBFFCalculation *) 0 ;
  OpenBabel::vector3 *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFCalculation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gradb" "', argument " "1"" of type '" "OpenBabel::OBFFCalculation *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFCalculation * >(argp1);
  {
    OpenBabel::vector3 const &_result_ref =  ((arg1)->gradb);
    result = (OpenBabel::vector3 *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFCalculation_gradc_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFCalculation *arg1 = (OpenBabel::OBFFCalculation *) 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFCalculation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gradc" "', argument " "1"" of type '" "OpenBabel::OBFFCalculation *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFCalculation * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "gradc" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gradc" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  if (arg1) (arg1)->gradc = *arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFCalculation_gradc_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFCalculation *arg1 = (OpenBabel::OBFFCalculation *) 0 ;
  OpenBabel::vector3 *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFCalculation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gradc" "', argument " "1"" of type '" "OpenBabel::OBFFCalculation *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFCalculation * >(argp1);
  {
    OpenBabel::vector3 const &_result_ref =  ((arg1)->gradc);
    result = (OpenBabel::vector3 *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFCalculation_gradd_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFCalculation *arg1 = (OpenBabel::OBFFCalculation *) 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFCalculation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gradd" "', argument " "1"" of type '" "OpenBabel::OBFFCalculation *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFCalculation * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "gradd" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "gradd" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  if (arg1) (arg1)->gradd = *arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFCalculation_gradd_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFCalculation *arg1 = (OpenBabel::OBFFCalculation *) 0 ;
  OpenBabel::vector3 *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFCalculation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "gradd" "', argument " "1"" of type '" "OpenBabel::OBFFCalculation *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFCalculation * >(argp1);
  {
    OpenBabel::vector3 const &_result_ref =  ((arg1)->gradd);
    result = (OpenBabel::vector3 *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFCalculation_a_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFCalculation *arg1 = (OpenBabel::OBFFCalculation *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFCalculation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "a" "', argument " "1"" of type '" "OpenBabel::OBFFCalculation *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFCalculation * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "a" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  if (arg1) (arg1)->a = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFCalculation_a_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFCalculation *arg1 = (OpenBabel::OBFFCalculation *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFCalculation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "a" "', argument " "1"" of type '" "OpenBabel::OBFFCalculation *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFCalculation * >(argp1);
  result = (OpenBabel::OBAtom *) ((arg1)->a);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFCalculation_b_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFCalculation *arg1 = (OpenBabel::OBFFCalculation *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFCalculation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "b" "', argument " "1"" of type '" "OpenBabel::OBFFCalculation *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFCalculation * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "b" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  if (arg1) (arg1)->b = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFCalculation_b_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFCalculation *arg1 = (OpenBabel::OBFFCalculation *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFCalculation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "b" "', argument " "1"" of type '" "OpenBabel::OBFFCalculation *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFCalculation * >(argp1);
  result = (OpenBabel::OBAtom *) ((arg1)->b);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFCalculation_c_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFCalculation *arg1 = (OpenBabel::OBFFCalculation *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFCalculation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "c" "', argument " "1"" of type '" "OpenBabel::OBFFCalculation *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFCalculation * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "c" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  if (arg1) (arg1)->c = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFCalculation_c_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFCalculation *arg1 = (OpenBabel::OBFFCalculation *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFCalculation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "c" "', argument " "1"" of type '" "OpenBabel::OBFFCalculation *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFCalculation * >(argp1);
  result = (OpenBabel::OBAtom *) ((arg1)->c);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFCalculation_d_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFCalculation *arg1 = (OpenBabel::OBFFCalculation *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFCalculation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "d" "', argument " "1"" of type '" "OpenBabel::OBFFCalculation *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFCalculation * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "d" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  if (arg1) (arg1)->d = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFCalculation_d_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFCalculation *arg1 = (OpenBabel::OBFFCalculation *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFCalculation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "d" "', argument " "1"" of type '" "OpenBabel::OBFFCalculation *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFCalculation * >(argp1);
  result = (OpenBabel::OBAtom *) ((arg1)->d);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBFFCalculation_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBFFCalculation_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBFFCalculation);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBFFCalculation(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFCalculation *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBFFCalculation *)new OpenBabel::OBFFCalculation();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBFFCalculation(OpenBabel::OBFFCalculation *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_OBFFCalculation_compute__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFCalculation *arg1 = (OpenBabel::OBFFCalculation *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFCalculation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compute" "', argument " "1"" of type '" "OpenBabel::OBFFCalculation *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFCalculation * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Compute" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  (arg1)->Compute(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFCalculation_compute__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFCalculation *arg1 = (OpenBabel::OBFFCalculation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFCalculation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compute" "', argument " "1"" of type '" "OpenBabel::OBFFCalculation *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFCalculation * >(argp1);
  (arg1)->Compute();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBFFCalculation_compute(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBFFCalculation, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBFFCalculation_compute__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBFFCalculation, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBFFCalculation_compute__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBFFCalculation_compute'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFCalculation_get_energy(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFCalculation *arg1 = (OpenBabel::OBFFCalculation *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFCalculation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetEnergy" "', argument " "1"" of type '" "OpenBabel::OBFFCalculation *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFCalculation * >(argp1);
  result = (double)(arg1)->GetEnergy();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBFFCalculation_get_gradient(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFCalculation *arg1 = (OpenBabel::OBFFCalculation *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::vector3 result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFCalculation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetGradient" "', argument " "1"" of type '" "OpenBabel::OBFFCalculation *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBFFCalculation * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetGradient" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (arg1)->GetGradient(arg2);
  vresult = SWIG_NewPointerObj((new OpenBabel::vector3(static_cast< const OpenBabel::vector3& >(result))), SWIGTYPE_p_OpenBabel__vector3, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


swig_class cOBForceField;

SWIGINTERN VALUE
_wrap_new_OBForceField__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::string arg1 ;
  bool arg2 ;
  OpenBabel::OBForceField *result = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "OpenBabel::OBForceField" "', argument " "1"" of type '" "std::string""'"); 
    }
    arg1 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  ecode2 = SWIG_AsVal_bool(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "OpenBabel::OBForceField" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (OpenBabel::OBForceField *)new OpenBabel::OBForceField(arg1,arg2);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBForceField_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBForceField_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBForceField);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBForceField__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::string arg1 ;
  OpenBabel::OBForceField *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "OpenBabel::OBForceField" "', argument " "1"" of type '" "std::string""'"); 
    }
    arg1 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = (OpenBabel::OBForceField *)new OpenBabel::OBForceField(arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_OBForceField(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBForceField__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_OBForceField__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_OBForceField'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_iter(int argc, VALUE *argv, VALUE self) {
  OpenBabel::PluginIter<OpenBabel::OBForceField > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  {
    OpenBabel::PluginIter<OpenBabel::OBForceField > &_result_ref = OpenBabel::OBForceField::Iter();
    result = (OpenBabel::PluginIter<OpenBabel::OBForceField > *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_find_default_type(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBForceField *)OpenBabel::OBForceField::FindDefaultType();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_find_type(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  OpenBabel::OBForceField *result = 0 ;
  int res1 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBForceField::FindType" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBForceField::FindType" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  result = (OpenBabel::OBForceField *)OpenBabel::OBForceField::FindType((std::string const &)*arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  return vresult;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBForceField(OpenBabel::OBForceField *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_OBForceField_find_force_field__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::string *arg1 = 0 ;
  OpenBabel::OBForceField *result = 0 ;
  int res1 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBForceField::FindForceField" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBForceField::FindForceField" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  result = (OpenBabel::OBForceField *)OpenBabel::OBForceField::FindForceField((std::string const &)*arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  return vresult;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_find_force_field__SWIG_1(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  OpenBabel::OBForceField *result = 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBForceField::FindForceField" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  result = (OpenBabel::OBForceField *)OpenBabel::OBForceField::FindForceField((char const *)arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return vresult;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBForceField_find_force_field(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBForceField_find_force_field__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBForceField_find_force_field__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBForceField_find_force_field'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_get_unit(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetUnit" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  result = (arg1)->GetUnit();
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_setup(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  OpenBabel::OBMol *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Setup" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBMol,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Setup" "', argument " "2"" of type '" "OpenBabel::OBMol &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Setup" "', argument " "2"" of type '" "OpenBabel::OBMol &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2);
  result = (bool)(arg1)->Setup(*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_update_coordinates(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  OpenBabel::OBMol *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UpdateCoordinates" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBMol,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "UpdateCoordinates" "', argument " "2"" of type '" "OpenBabel::OBMol &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "UpdateCoordinates" "', argument " "2"" of type '" "OpenBabel::OBMol &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2);
  result = (bool)(arg1)->UpdateCoordinates(*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_update_conformers(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  OpenBabel::OBMol *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UpdateConformers" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBMol,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "UpdateConformers" "', argument " "2"" of type '" "OpenBabel::OBMol &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "UpdateConformers" "', argument " "2"" of type '" "OpenBabel::OBMol &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2);
  result = (bool)(arg1)->UpdateConformers(*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_obfflog__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  std::string arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OBFFLog" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "OBFFLog" "', argument " "2"" of type '" "std::string""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  (arg1)->OBFFLog(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_obfflog__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OBFFLog" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OBFFLog" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  (arg1)->OBFFLog((char const *)arg2);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBForceField_obfflog(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBForceField, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBForceField_obfflog__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBForceField, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBForceField_obfflog__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBForceField_obfflog'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_energy__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  bool arg2 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Energy" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Energy" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (double)(arg1)->Energy(arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_energy__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Energy" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  result = (double)(arg1)->Energy();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBForceField_energy(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBForceField, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBForceField_energy__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBForceField, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBForceField_energy__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBForceField_energy'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_e_bond__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  bool arg2 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "E_Bond" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "E_Bond" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (double)(arg1)->E_Bond(arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_e_bond__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "E_Bond" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  result = (double)(arg1)->E_Bond();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBForceField_e_bond(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBForceField, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBForceField_e_bond__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBForceField, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBForceField_e_bond__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBForceField_e_bond'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_e_angle__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  bool arg2 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "E_Angle" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "E_Angle" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (double)(arg1)->E_Angle(arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_e_angle__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "E_Angle" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  result = (double)(arg1)->E_Angle();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBForceField_e_angle(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBForceField, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBForceField_e_angle__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBForceField, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBForceField_e_angle__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBForceField_e_angle'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_e_str_bnd__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  bool arg2 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "E_StrBnd" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "E_StrBnd" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (double)(arg1)->E_StrBnd(arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_e_str_bnd__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "E_StrBnd" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  result = (double)(arg1)->E_StrBnd();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBForceField_e_str_bnd(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBForceField, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBForceField_e_str_bnd__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBForceField, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBForceField_e_str_bnd__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBForceField_e_str_bnd'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_e_torsion__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  bool arg2 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "E_Torsion" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "E_Torsion" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (double)(arg1)->E_Torsion(arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_e_torsion__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "E_Torsion" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  result = (double)(arg1)->E_Torsion();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBForceField_e_torsion(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBForceField, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBForceField_e_torsion__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBForceField, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBForceField_e_torsion__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBForceField_e_torsion'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_e_oop__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  bool arg2 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "E_OOP" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "E_OOP" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (double)(arg1)->E_OOP(arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_e_oop__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "E_OOP" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  result = (double)(arg1)->E_OOP();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBForceField_e_oop(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBForceField, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBForceField_e_oop__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBForceField, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBForceField_e_oop__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBForceField_e_oop'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_e_vdw__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  bool arg2 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "E_VDW" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "E_VDW" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (double)(arg1)->E_VDW(arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_e_vdw__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "E_VDW" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  result = (double)(arg1)->E_VDW();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBForceField_e_vdw(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBForceField, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBForceField_e_vdw__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBForceField, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBForceField_e_vdw__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBForceField_e_vdw'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_e_electrostatic__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  bool arg2 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "E_Electrostatic" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "E_Electrostatic" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (double)(arg1)->E_Electrostatic(arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_e_electrostatic__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "E_Electrostatic" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  result = (double)(arg1)->E_Electrostatic();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBForceField_e_electrostatic(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBForceField, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBForceField_e_electrostatic__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBForceField, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBForceField_e_electrostatic__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBForceField_e_electrostatic'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_set_log_file(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  std::ostream *arg2 = (std::ostream *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetLogFile" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_std__ostream, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetLogFile" "', argument " "2"" of type '" "std::ostream *""'"); 
  }
  arg2 = reinterpret_cast< std::ostream * >(argp2);
  result = (bool)(arg1)->SetLogFile(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_set_log_level(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetLogLevel" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetLogLevel" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (bool)(arg1)->SetLogLevel(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_get_log_level(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetLogLevel" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  result = (int)(arg1)->GetLogLevel();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_systematic_rotor_search(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SystematicRotorSearch" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  (arg1)->SystematicRotorSearch();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_line_search(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::vector3 *arg3 = 0 ;
  OpenBabel::vector3 result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LineSearch" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "LineSearch" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "LineSearch" "', argument " "3"" of type '" "OpenBabel::vector3 &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "LineSearch" "', argument " "3"" of type '" "OpenBabel::vector3 &""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::vector3 * >(argp3);
  result = (arg1)->LineSearch(arg2,*arg3);
  vresult = SWIG_NewPointerObj((new OpenBabel::vector3(static_cast< const OpenBabel::vector3& >(result))), SWIGTYPE_p_OpenBabel__vector3, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_steepest_descent__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  int arg2 ;
  double arg3 ;
  int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SteepestDescent" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SteepestDescent" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_double(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SteepestDescent" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  ecode4 = SWIG_AsVal_int(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "SteepestDescent" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = static_cast< int >(val4);
  (arg1)->SteepestDescent(arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_steepest_descent__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  int arg2 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SteepestDescent" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SteepestDescent" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_double(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SteepestDescent" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  (arg1)->SteepestDescent(arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_steepest_descent__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SteepestDescent" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SteepestDescent" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->SteepestDescent(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBForceField_steepest_descent(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBForceField, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBForceField_steepest_descent__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBForceField, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_OBForceField_steepest_descent__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBForceField, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_OBForceField_steepest_descent__SWIG_0(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBForceField_steepest_descent'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_steepest_descent_initialize__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  int arg2 ;
  double arg3 ;
  int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SteepestDescentInitialize" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SteepestDescentInitialize" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_double(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SteepestDescentInitialize" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  ecode4 = SWIG_AsVal_int(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "SteepestDescentInitialize" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = static_cast< int >(val4);
  (arg1)->SteepestDescentInitialize(arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_steepest_descent_initialize__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  int arg2 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SteepestDescentInitialize" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SteepestDescentInitialize" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_double(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SteepestDescentInitialize" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  (arg1)->SteepestDescentInitialize(arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_steepest_descent_initialize__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SteepestDescentInitialize" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SteepestDescentInitialize" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->SteepestDescentInitialize(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_steepest_descent_initialize__SWIG_3(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SteepestDescentInitialize" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  (arg1)->SteepestDescentInitialize();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBForceField_steepest_descent_initialize(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBForceField, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBForceField_steepest_descent_initialize__SWIG_3(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBForceField, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBForceField_steepest_descent_initialize__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBForceField, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_OBForceField_steepest_descent_initialize__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBForceField, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_OBForceField_steepest_descent_initialize__SWIG_0(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBForceField_steepest_descent_initialize'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_steepest_descent_take_nsteps(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SteepestDescentTakeNSteps" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SteepestDescentTakeNSteps" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (bool)(arg1)->SteepestDescentTakeNSteps(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_conjugate_gradients__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  int arg2 ;
  double arg3 ;
  int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConjugateGradients" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ConjugateGradients" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_double(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "ConjugateGradients" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  ecode4 = SWIG_AsVal_int(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "ConjugateGradients" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = static_cast< int >(val4);
  (arg1)->ConjugateGradients(arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_conjugate_gradients__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  int arg2 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConjugateGradients" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ConjugateGradients" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_double(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "ConjugateGradients" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  (arg1)->ConjugateGradients(arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_conjugate_gradients__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConjugateGradients" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ConjugateGradients" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->ConjugateGradients(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBForceField_conjugate_gradients(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBForceField, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBForceField_conjugate_gradients__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBForceField, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_OBForceField_conjugate_gradients__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBForceField, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_OBForceField_conjugate_gradients__SWIG_0(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBForceField_conjugate_gradients'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_conjugate_gradients_initialize__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  int arg2 ;
  double arg3 ;
  int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConjugateGradientsInitialize" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ConjugateGradientsInitialize" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_double(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "ConjugateGradientsInitialize" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  ecode4 = SWIG_AsVal_int(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "ConjugateGradientsInitialize" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = static_cast< int >(val4);
  (arg1)->ConjugateGradientsInitialize(arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_conjugate_gradients_initialize__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  int arg2 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConjugateGradientsInitialize" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ConjugateGradientsInitialize" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_double(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "ConjugateGradientsInitialize" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  (arg1)->ConjugateGradientsInitialize(arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_conjugate_gradients_initialize__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConjugateGradientsInitialize" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ConjugateGradientsInitialize" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->ConjugateGradientsInitialize(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_conjugate_gradients_initialize__SWIG_3(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConjugateGradientsInitialize" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  (arg1)->ConjugateGradientsInitialize();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBForceField_conjugate_gradients_initialize(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBForceField, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBForceField_conjugate_gradients_initialize__SWIG_3(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBForceField, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBForceField_conjugate_gradients_initialize__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBForceField, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_OBForceField_conjugate_gradients_initialize__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBForceField, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_OBForceField_conjugate_gradients_initialize__SWIG_0(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBForceField_conjugate_gradients_initialize'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_conjugate_gradients_take_nsteps(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ConjugateGradientsTakeNSteps" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ConjugateGradientsTakeNSteps" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (bool)(arg1)->ConjugateGradientsTakeNSteps(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_validate(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Validate" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  result = (bool)(arg1)->Validate();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_validate_gradients(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ValidateGradients" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  result = (bool)(arg1)->ValidateGradients();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_validate_gradient_error(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  OpenBabel::vector3 *arg3 = 0 ;
  OpenBabel::vector3 result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ValidateGradientError" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ValidateGradientError" "', argument " "2"" of type '" "OpenBabel::vector3 &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ValidateGradientError" "', argument " "2"" of type '" "OpenBabel::vector3 &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "ValidateGradientError" "', argument " "3"" of type '" "OpenBabel::vector3 &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ValidateGradientError" "', argument " "3"" of type '" "OpenBabel::vector3 &""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::vector3 * >(argp3);
  result = (arg1)->ValidateGradientError(*arg2,*arg3);
  vresult = SWIG_NewPointerObj((new OpenBabel::vector3(static_cast< const OpenBabel::vector3& >(result))), SWIGTYPE_p_OpenBabel__vector3, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_vector_length_derivative(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBForceField::VectorLengthDerivative" "', argument " "1"" of type '" "OpenBabel::vector3 &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBForceField::VectorLengthDerivative" "', argument " "1"" of type '" "OpenBabel::vector3 &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::OBForceField::VectorLengthDerivative" "', argument " "2"" of type '" "OpenBabel::vector3 &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBForceField::VectorLengthDerivative" "', argument " "2"" of type '" "OpenBabel::vector3 &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  result = (double)OpenBabel::OBForceField::VectorLengthDerivative(*arg1,*arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_vector_angle_derivative(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  OpenBabel::vector3 *arg3 = 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBForceField::VectorAngleDerivative" "', argument " "1"" of type '" "OpenBabel::vector3 &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBForceField::VectorAngleDerivative" "', argument " "1"" of type '" "OpenBabel::vector3 &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::OBForceField::VectorAngleDerivative" "', argument " "2"" of type '" "OpenBabel::vector3 &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBForceField::VectorAngleDerivative" "', argument " "2"" of type '" "OpenBabel::vector3 &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "OpenBabel::OBForceField::VectorAngleDerivative" "', argument " "3"" of type '" "OpenBabel::vector3 &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBForceField::VectorAngleDerivative" "', argument " "3"" of type '" "OpenBabel::vector3 &""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::vector3 * >(argp3);
  result = (double)OpenBabel::OBForceField::VectorAngleDerivative(*arg1,*arg2,*arg3);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_vector_torsion_derivative(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  OpenBabel::vector3 *arg3 = 0 ;
  OpenBabel::vector3 *arg4 = 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBForceField::VectorTorsionDerivative" "', argument " "1"" of type '" "OpenBabel::vector3 &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBForceField::VectorTorsionDerivative" "', argument " "1"" of type '" "OpenBabel::vector3 &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OpenBabel::OBForceField::VectorTorsionDerivative" "', argument " "2"" of type '" "OpenBabel::vector3 &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBForceField::VectorTorsionDerivative" "', argument " "2"" of type '" "OpenBabel::vector3 &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "OpenBabel::OBForceField::VectorTorsionDerivative" "', argument " "3"" of type '" "OpenBabel::vector3 &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBForceField::VectorTorsionDerivative" "', argument " "3"" of type '" "OpenBabel::vector3 &""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::vector3 * >(argp3);
  res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "OpenBabel::OBForceField::VectorTorsionDerivative" "', argument " "4"" of type '" "OpenBabel::vector3 &""'"); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBForceField::VectorTorsionDerivative" "', argument " "4"" of type '" "OpenBabel::vector3 &""'"); 
  }
  arg4 = reinterpret_cast< OpenBabel::vector3 * >(argp4);
  result = (double)OpenBabel::OBForceField::VectorTorsionDerivative(*arg1,*arg2,*arg3,*arg4);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBForceField_kludge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "kludge" "', argument " "1"" of type '" "OpenBabel::OBForceField *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  (arg1)->kludge();
  return Qnil;
fail:
  return Qnil;
}


swig_class cOBMolAtomIter;

SWIGINTERN VALUE
_wrap_new_OBMolAtomIter__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBMolAtomIter *)new OpenBabel::OBMolAtomIter();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_OBMolAtomIter__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBMolAtomIter *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBMolAtomIter" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (OpenBabel::OBMolAtomIter *)new OpenBabel::OBMolAtomIter(arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBMolAtomIter_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBMolAtomIter_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBMolAtomIter);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBMolAtomIter__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = 0 ;
  OpenBabel::OBMolAtomIter *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBMolAtomIter,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBMolAtomIter" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBMolAtomIter" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter const &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (OpenBabel::OBMolAtomIter *)new OpenBabel::OBMolAtomIter((OpenBabel::OBMolAtomIter const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_OBMolAtomIter(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_OBMolAtomIter__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBMolAtomIter__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBMolAtomIter__SWIG_2(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_OBMolAtomIter'");
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBMolAtomIter(OpenBabel::OBMolAtomIter *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_OBMolAtomIter_good(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator bool" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (bool)((OpenBabel::OBMolAtomIter const *)arg1)->operator bool();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_inc__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  OpenBabel::OBMolAtomIter *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator ++" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  {
    OpenBabel::OBMolAtomIter &_result_ref = (arg1)->operator ++();
    result = (OpenBabel::OBMolAtomIter *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_inc__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  int arg2 ;
  OpenBabel::OBMolAtomIter result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator ++" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "operator ++" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (arg1)->operator ++(arg2);
  vresult = SWIG_NewPointerObj((new OpenBabel::OBMolAtomIter(static_cast< const OpenBabel::OBMolAtomIter& >(result))), SWIGTYPE_p_OpenBabel__OBMolAtomIter, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolAtomIter_inc(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBMolAtomIter_inc__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBMolAtomIter_inc__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolAtomIter_inc'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_deref(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator ->" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (OpenBabel::OBAtom *)((OpenBabel::OBMolAtomIter const *)arg1)->operator ->();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter___ref__(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator *" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  {
    OpenBabel::OBAtom &_result_ref = ((OpenBabel::OBMolAtomIter const *)arg1)->operator *();
    result = (OpenBabel::OBAtom *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_Visit_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Visit" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Visit" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  if (arg1) (*arg1)->Visit = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_Visit_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Visit" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (bool) ((*arg1)->Visit);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_clear(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Clear" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (bool)(*arg1)->Clear();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_set_idx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetIdx" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetIdx" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (*arg1)->SetIdx(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_set_hyb(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetHyb" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetHyb" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (*arg1)->SetHyb(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_set_atomic_num(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetAtomicNum" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetAtomicNum" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (*arg1)->SetAtomicNum(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_set_isotope(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetIsotope" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetIsotope" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  (*arg1)->SetIsotope(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_set_implicit_valence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetImplicitValence" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetImplicitValence" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (*arg1)->SetImplicitValence(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_increment_implicit_valence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IncrementImplicitValence" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  (*arg1)->IncrementImplicitValence();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_decrement_implicit_valence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DecrementImplicitValence" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  (*arg1)->DecrementImplicitValence();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_set_formal_charge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetFormalCharge" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetFormalCharge" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (*arg1)->SetFormalCharge(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_set_spin_multiplicity(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  short arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  short val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetSpinMultiplicity" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_short(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetSpinMultiplicity" "', argument " "2"" of type '" "short""'");
  } 
  arg2 = static_cast< short >(val2);
  (*arg1)->SetSpinMultiplicity(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_set_type__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetType" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetType" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  (*arg1)->SetType(arg2);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_set_type__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetType" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__string,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetType" "', argument " "2"" of type '" "std::string &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetType" "', argument " "2"" of type '" "std::string &""'"); 
  }
  arg2 = reinterpret_cast< std::string * >(argp2);
  (*arg1)->SetType(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolAtomIter_set_type(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__string, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMolAtomIter_set_type__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMolAtomIter_set_type__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolAtomIter_set_type'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_set_partial_charge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetPartialCharge" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetPartialCharge" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  (*arg1)->SetPartialCharge(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_set_vector__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetVector" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetVector" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetVector" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  (*arg1)->SetVector((OpenBabel::vector3 const &)*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_set_vector__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  double arg2 ;
  double arg3 ;
  double arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetVector" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetVector" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SetVector" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  ecode4 = SWIG_AsVal_double(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "SetVector" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = static_cast< double >(val4);
  (*arg1)->SetVector(arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_set_vector__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetVector" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  (*arg1)->SetVector();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolAtomIter_set_vector(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBMolAtomIter_set_vector__SWIG_2(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__vector3, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMolAtomIter_set_vector__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_double(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_OBMolAtomIter_set_vector__SWIG_1(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolAtomIter_set_vector'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_set_coord_ptr(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  double **arg2 = (double **) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetCoordPtr" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetCoordPtr" "', argument " "2"" of type '" "double **""'"); 
  }
  arg2 = reinterpret_cast< double ** >(argp2);
  (*arg1)->SetCoordPtr(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_set_residue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  OpenBabel::OBResidue *arg2 = (OpenBabel::OBResidue *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetResidue" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetResidue" "', argument " "2"" of type '" "OpenBabel::OBResidue *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBResidue * >(argp2);
  (*arg1)->SetResidue(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_set_parent(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  OpenBabel::OBMol *arg2 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetParent" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetParent" "', argument " "2"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2);
  (*arg1)->SetParent(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_set_aromatic(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetAromatic" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  (*arg1)->SetAromatic();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_unset_aromatic(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnsetAromatic" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  (*arg1)->UnsetAromatic();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_set_clockwise_stereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetClockwiseStereo" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  (*arg1)->SetClockwiseStereo();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_set_anti_clockwise_stereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetAntiClockwiseStereo" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  (*arg1)->SetAntiClockwiseStereo();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_set_positive_stereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetPositiveStereo" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  (*arg1)->SetPositiveStereo();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_set_negative_stereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetNegativeStereo" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  (*arg1)->SetNegativeStereo();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_unset_stereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnsetStereo" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  (*arg1)->UnsetStereo();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_set_in_ring(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetInRing" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  (*arg1)->SetInRing();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_set_chiral(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetChiral" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  (*arg1)->SetChiral();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_clear_coord_ptr(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ClearCoordPtr" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  (*arg1)->ClearCoordPtr();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_get_formal_charge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetFormalCharge" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (int)(*arg1)->GetFormalCharge();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_get_atomic_num(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAtomicNum" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->GetAtomicNum();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_get_isotope(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  unsigned short result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetIsotope" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (unsigned short)(*arg1)->GetIsotope();
  vresult = SWIG_From_unsigned_SS_short(static_cast< unsigned short >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_get_spin_multiplicity(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetSpinMultiplicity" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (int)(*arg1)->GetSpinMultiplicity();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_get_atomic_mass(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAtomicMass" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (double)(*arg1)->GetAtomicMass();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_get_exact_mass(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetExactMass" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (double)(*arg1)->GetExactMass();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_get_idx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetIdx" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->GetIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_get_coordinate_idx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetCoordinateIdx" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->GetCoordinateIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_get_cidx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetCIdx" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->GetCIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_get_valence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetValence" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->GetValence();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_get_hyb(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetHyb" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->GetHyb();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_get_implicit_valence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetImplicitValence" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->GetImplicitValence();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_get_hvy_valence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetHvyValence" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->GetHvyValence();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_get_hetero_valence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetHeteroValence" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->GetHeteroValence();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_get_type(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  char *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetType" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (char *)(*arg1)->GetType();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_get_x(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetX" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (double)(*arg1)->GetX();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_get_y(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetY" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (double)(*arg1)->GetY();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_get_z(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetZ" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (double)(*arg1)->GetZ();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_x(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "x" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (double)(*arg1)->x();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_y(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "y" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (double)(*arg1)->y();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_z(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "z" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (double)(*arg1)->z();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_get_coordinate(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  double *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetCoordinate" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (double *)(*arg1)->GetCoordinate();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_get_vector__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  OpenBabel::vector3 *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetVector" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  {
    OpenBabel::vector3 &_result_ref = (*arg1)->GetVector();
    result = (OpenBabel::vector3 *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_get_vector__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  OpenBabel::vector3 *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetVector" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  {
    OpenBabel::vector3 const &_result_ref = (*arg1)->GetVector();
    result = (OpenBabel::vector3 *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolAtomIter_get_vector(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBMolAtomIter_get_vector__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBMolAtomIter_get_vector__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolAtomIter_get_vector'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_get_partial_charge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetPartialCharge" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (double)(*arg1)->GetPartialCharge();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_get_residue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  OpenBabel::OBResidue *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetResidue" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (OpenBabel::OBResidue *)(*arg1)->GetResidue();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_get_parent(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  OpenBabel::OBMol *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetParent" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (OpenBabel::OBMol *)(*arg1)->GetParent();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_get_new_bond_vector(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  double arg3 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetNewBondVector" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetNewBondVector" "', argument " "2"" of type '" "OpenBabel::vector3 &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GetNewBondVector" "', argument " "2"" of type '" "OpenBabel::vector3 &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  ecode3 = SWIG_AsVal_double(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "GetNewBondVector" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  result = (bool)(*arg1)->GetNewBondVector(*arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_get_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBBond *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetBond" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetBond" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (OpenBabel::OBBond *)(*arg1)->GetBond(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_get_next_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetNextAtom" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (OpenBabel::OBAtom *)(*arg1)->GetNextAtom();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_begin_bonds(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBBond * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginBonds" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (*arg1)->BeginBonds();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBBondIterator(static_cast< const OpenBabel::OBBondIterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_end_bonds(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBBond * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EndBonds" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (*arg1)->EndBonds();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBBondIterator(static_cast< const OpenBabel::OBBondIterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_begin_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  OpenBabel::OBBondIterator *arg2 = 0 ;
  OpenBabel::OBBond *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginBond" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "BeginBond" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "BeginBond" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2);
  result = (OpenBabel::OBBond *)(*arg1)->BeginBond(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_next_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  OpenBabel::OBBondIterator *arg2 = 0 ;
  OpenBabel::OBBond *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NextBond" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "NextBond" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "NextBond" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2);
  result = (OpenBabel::OBBond *)(*arg1)->NextBond(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_begin_nbr_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  OpenBabel::OBBondIterator *arg2 = 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginNbrAtom" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "BeginNbrAtom" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "BeginNbrAtom" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2);
  result = (OpenBabel::OBAtom *)(*arg1)->BeginNbrAtom(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_next_nbr_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  OpenBabel::OBBondIterator *arg2 = 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NextNbrAtom" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "NextNbrAtom" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "NextNbrAtom" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2);
  result = (OpenBabel::OBAtom *)(*arg1)->NextNbrAtom(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_get_distance__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  int arg2 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetDistance" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetDistance" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (double)(*arg1)->GetDistance(arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_get_distance__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetDistance" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetDistance" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (double)(*arg1)->GetDistance(arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolAtomIter_get_distance(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMolAtomIter_get_distance__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBMolAtomIter_get_distance__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolAtomIter_get_distance'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_get_angle__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  int arg2 ;
  int arg3 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAngle" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetAngle" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "GetAngle" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  result = (double)(*arg1)->GetAngle(arg2,arg3);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_get_angle__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg3 = (OpenBabel::OBAtom *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAngle" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetAngle" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "GetAngle" "', argument " "3"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBAtom * >(argp3);
  result = (double)(*arg1)->GetAngle(arg2,arg3);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolAtomIter_get_angle(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_OBMolAtomIter_get_angle__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_OBMolAtomIter_get_angle__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolAtomIter_get_angle'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_new_residue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NewResidue" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  (*arg1)->NewResidue();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_add_residue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  OpenBabel::OBResidue *arg2 = (OpenBabel::OBResidue *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AddResidue" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AddResidue" "', argument " "2"" of type '" "OpenBabel::OBResidue *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBResidue * >(argp2);
  (*arg1)->AddResidue(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_delete_residue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteResidue" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  (*arg1)->DeleteResidue();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_add_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  OpenBabel::OBBond *arg2 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AddBond" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AddBond" "', argument " "2"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBond * >(argp2);
  (*arg1)->AddBond(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_insert_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  OpenBabel::OBBondIterator *arg2 = 0 ;
  OpenBabel::OBBond *arg3 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InsertBond" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InsertBond" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InsertBond" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "InsertBond" "', argument " "3"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBBond * >(argp3);
  (*arg1)->InsertBond(*arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_delete_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  OpenBabel::OBBond *arg2 = (OpenBabel::OBBond *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteBond" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DeleteBond" "', argument " "2"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBond * >(argp2);
  result = (bool)(*arg1)->DeleteBond(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_clear_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ClearBond" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  (*arg1)->ClearBond();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_hto_methyl(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HtoMethyl" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (bool)(*arg1)->HtoMethyl();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_set_hyb_and_geom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetHybAndGeom" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetHybAndGeom" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (bool)(*arg1)->SetHybAndGeom(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_force_no_h(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ForceNoH" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  (*arg1)->ForceNoH();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_has_no_hforced(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasNoHForced" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (bool)(*arg1)->HasNoHForced();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_count_free_oxygens(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CountFreeOxygens" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->CountFreeOxygens();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_implicit_hydrogen_count(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ImplicitHydrogenCount" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->ImplicitHydrogenCount();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_explicit_hydrogen_count__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool arg2 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ExplicitHydrogenCount" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ExplicitHydrogenCount" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (unsigned int)(*arg1)->ExplicitHydrogenCount(arg2);
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_explicit_hydrogen_count__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ExplicitHydrogenCount" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->ExplicitHydrogenCount();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolAtomIter_explicit_hydrogen_count(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBMolAtomIter_explicit_hydrogen_count__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBMolAtomIter_explicit_hydrogen_count__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolAtomIter_explicit_hydrogen_count'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_member_of_ring_count(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MemberOfRingCount" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->MemberOfRingCount();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_member_of_ring_size(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MemberOfRingSize" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->MemberOfRingSize();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_count_ring_bonds(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CountRingBonds" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->CountRingBonds();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_smallest_bond_angle(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SmallestBondAngle" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (double)(*arg1)->SmallestBondAngle();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_average_bond_angle(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AverageBondAngle" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (double)(*arg1)->AverageBondAngle();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_bosum(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BOSum" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->BOSum();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_kbosum(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KBOSum" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->KBOSum();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_has_residue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasResidue" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (bool)(*arg1)->HasResidue();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_is_hydrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsHydrogen" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (bool)(*arg1)->IsHydrogen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_is_carbon(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsCarbon" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (bool)(*arg1)->IsCarbon();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_is_nitrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsNitrogen" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (bool)(*arg1)->IsNitrogen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_is_oxygen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsOxygen" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (bool)(*arg1)->IsOxygen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_is_sulfur(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsSulfur" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (bool)(*arg1)->IsSulfur();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_is_phosphorus(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsPhosphorus" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (bool)(*arg1)->IsPhosphorus();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_is_aromatic(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsAromatic" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (bool)(*arg1)->IsAromatic();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_is_in_ring(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsInRing" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (bool)(*arg1)->IsInRing();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_is_in_ring_size(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsInRingSize" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IsInRingSize" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (bool)(*arg1)->IsInRingSize(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_is_heteroatom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsHeteroatom" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (bool)(*arg1)->IsHeteroatom();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_is_not_cor_h(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsNotCorH" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (bool)(*arg1)->IsNotCorH();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_is_connected(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsConnected" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "IsConnected" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (bool)(*arg1)->IsConnected(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_is_one_three(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsOneThree" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "IsOneThree" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (bool)(*arg1)->IsOneThree(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_is_one_four(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsOneFour" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "IsOneFour" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (bool)(*arg1)->IsOneFour(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_is_carboxyl_oxygen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsCarboxylOxygen" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (bool)(*arg1)->IsCarboxylOxygen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_is_phosphate_oxygen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsPhosphateOxygen" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (bool)(*arg1)->IsPhosphateOxygen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_is_sulfate_oxygen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsSulfateOxygen" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (bool)(*arg1)->IsSulfateOxygen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_is_nitro_oxygen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsNitroOxygen" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (bool)(*arg1)->IsNitroOxygen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_is_amide_nitrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsAmideNitrogen" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (bool)(*arg1)->IsAmideNitrogen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_is_polar_hydrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsPolarHydrogen" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (bool)(*arg1)->IsPolarHydrogen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_is_non_polar_hydrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsNonPolarHydrogen" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (bool)(*arg1)->IsNonPolarHydrogen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_is_aromatic_noxide(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsAromaticNOxide" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (bool)(*arg1)->IsAromaticNOxide();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_is_chiral(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsChiral" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (bool)(*arg1)->IsChiral();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_is_axial(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsAxial" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (bool)(*arg1)->IsAxial();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_is_clockwise(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsClockwise" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (bool)(*arg1)->IsClockwise();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_is_anti_clockwise(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsAntiClockwise" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (bool)(*arg1)->IsAntiClockwise();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_is_positive_stereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsPositiveStereo" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (bool)(*arg1)->IsPositiveStereo();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_is_negative_stereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsNegativeStereo" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (bool)(*arg1)->IsNegativeStereo();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_has_chirality_specified(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasChiralitySpecified" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (bool)(*arg1)->HasChiralitySpecified();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_has_chiral_volume(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasChiralVolume" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (bool)(*arg1)->HasChiralVolume();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_is_hbond_acceptor(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsHbondAcceptor" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (bool)(*arg1)->IsHbondAcceptor();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_is_hbond_donor(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsHbondDonor" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (bool)(*arg1)->IsHbondDonor();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_is_hbond_donor_h(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsHbondDonorH" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (bool)(*arg1)->IsHbondDonorH();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_has_alpha_beta_unsat__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasAlphaBetaUnsat" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "HasAlphaBetaUnsat" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (bool)(*arg1)->HasAlphaBetaUnsat(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_has_alpha_beta_unsat__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasAlphaBetaUnsat" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (bool)(*arg1)->HasAlphaBetaUnsat();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolAtomIter_has_alpha_beta_unsat(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBMolAtomIter_has_alpha_beta_unsat__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBMolAtomIter_has_alpha_beta_unsat__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolAtomIter_has_alpha_beta_unsat'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_has_bond_of_order(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  unsigned int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasBondOfOrder" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "HasBondOfOrder" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (bool)(*arg1)->HasBondOfOrder(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_count_bonds_of_order(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  unsigned int arg2 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CountBondsOfOrder" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CountBondsOfOrder" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (int)(*arg1)->CountBondsOfOrder(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_has_non_single_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasNonSingleBond" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (bool)(*arg1)->HasNonSingleBond();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_has_single_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasSingleBond" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (bool)(*arg1)->HasSingleBond();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_has_double_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasDoubleBond" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (bool)(*arg1)->HasDoubleBond();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_has_aromatic_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasAromaticBond" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (bool)(*arg1)->HasAromaticBond();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_matches_smarts(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  char *arg2 = (char *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MatchesSMARTS" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MatchesSMARTS" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (bool)(*arg1)->MatchesSMARTS((char const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_do_transformations(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  std::map<std::string,std::string > *arg2 = (std::map<std::string,std::string > *) 0 ;
  OpenBabel::OBBase *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DoTransformations" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_std__mapTstd__string_std__string_t, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DoTransformations" "', argument " "2"" of type '" "std::map<std::string,std::string > const *""'"); 
  }
  arg2 = reinterpret_cast< std::map<std::string,std::string > * >(argp2);
  result = (OpenBabel::OBBase *)(*arg1)->DoTransformations((std::map<std::string,std::string > const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_class_description(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  char *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ClassDescription" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (char *)(*arg1)->ClassDescription();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_has_data__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  std::string *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "HasData" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "HasData" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (bool)(*arg1)->HasData((std::string const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_has_data__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  char *arg2 = (char *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "HasData" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (bool)(*arg1)->HasData((char const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_has_data__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  unsigned int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "HasData" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (bool)(*arg1)->HasData(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolAtomIter_has_data(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBMolAtomIter_has_data__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMolAtomIter_has_data__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMolAtomIter_has_data__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolAtomIter_has_data'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_delete_data__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DeleteData" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  (*arg1)->DeleteData(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_delete_data__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  OpenBabel::OBGenericData *arg2 = (OpenBabel::OBGenericData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DeleteData" "', argument " "2"" of type '" "OpenBabel::OBGenericData *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBGenericData * >(argp2);
  (*arg1)->DeleteData(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_delete_data__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  std::vector<OpenBabel::OBGenericData * > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DeleteData" "', argument " "2"" of type '" "std::vector<OpenBabel::OBGenericData * > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DeleteData" "', argument " "2"" of type '" "std::vector<OpenBabel::OBGenericData * > &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<OpenBabel::OBGenericData * > * >(argp2);
  (*arg1)->DeleteData(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolAtomIter_delete_data(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBGenericData, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMolAtomIter_delete_data__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMolAtomIter_delete_data__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBMolAtomIter_delete_data__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolAtomIter_delete_data'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_set_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  OpenBabel::OBGenericData *arg2 = (OpenBabel::OBGenericData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetData" "', argument " "2"" of type '" "OpenBabel::OBGenericData *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBGenericData * >(argp2);
  (*arg1)->SetData(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_data_size(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataSize" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->DataSize();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_get_data__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  unsigned int arg2 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetData" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (OpenBabel::OBGenericData *)(*arg1)->GetData(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_get_data__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  std::string *arg2 = 0 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetData" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GetData" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (OpenBabel::OBGenericData *)(*arg1)->GetData((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_get_data__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  char *arg2 = (char *) 0 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetData" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (OpenBabel::OBGenericData *)(*arg1)->GetData((char const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_get_data__SWIG_3(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  std::vector<OpenBabel::OBGenericData * > *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  {
    std::vector<OpenBabel::OBGenericData * > &_result_ref = (*arg1)->GetData();
    result = (std::vector<OpenBabel::OBGenericData * > *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_get_data__SWIG_4(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  OpenBabel::DataOrigin arg2 ;
  std::vector<OpenBabel::OBGenericData * > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetData" "', argument " "2"" of type '" "OpenBabel::DataOrigin""'");
  } 
  arg2 = static_cast< OpenBabel::DataOrigin >(val2);
  result = (*arg1)->GetData(arg2);
  {
    vresult = rb_ary_new2((&result)->size());
    for (unsigned int i=0; i<(&result)->size(); i++) {
      OpenBabel::OBGenericData* x = ((std::vector<OpenBabel::OBGenericData * > &)result)[i];
      rb_ary_store(vresult,i,
        SWIG_NewPointerObj((void *) x, 
          SWIGTYPE_p_OpenBabel__OBGenericData, 0));
    }
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolAtomIter_get_data(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBMolAtomIter_get_data__SWIG_3(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBMolAtomIter_get_data__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBMolAtomIter_get_data__SWIG_4(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMolAtomIter_get_data__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMolAtomIter_get_data__SWIG_2(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolAtomIter_get_data'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_begin_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBGenericData * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (*arg1)->BeginData();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBDataIterator(static_cast< const OpenBabel::OBDataIterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomIter_end_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBGenericData * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EndData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (*arg1)->EndData();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBDataIterator(static_cast< const OpenBabel::OBDataIterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


swig_class cOBMolAtomDFSIter;

SWIGINTERN VALUE
_wrap_new_OBMolAtomDFSIter__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBMolAtomDFSIter *)new OpenBabel::OBMolAtomDFSIter();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_OBMolAtomDFSIter__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  int arg2 ;
  OpenBabel::OBMolAtomDFSIter *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBMolAtomDFSIter" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "OpenBabel::OBMolAtomDFSIter" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (OpenBabel::OBMolAtomDFSIter *)new OpenBabel::OBMolAtomDFSIter(arg1,arg2);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_OBMolAtomDFSIter__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBMolAtomDFSIter *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBMolAtomDFSIter" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (OpenBabel::OBMolAtomDFSIter *)new OpenBabel::OBMolAtomDFSIter(arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_OBMolAtomDFSIter__SWIG_3(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = 0 ;
  int arg2 ;
  OpenBabel::OBMolAtomDFSIter *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBMol,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBMolAtomDFSIter" "', argument " "1"" of type '" "OpenBabel::OBMol &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBMolAtomDFSIter" "', argument " "1"" of type '" "OpenBabel::OBMol &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "OpenBabel::OBMolAtomDFSIter" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (OpenBabel::OBMolAtomDFSIter *)new OpenBabel::OBMolAtomDFSIter(*arg1,arg2);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBMolAtomDFSIter_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBMolAtomDFSIter__SWIG_4(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = 0 ;
  OpenBabel::OBMolAtomDFSIter *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBMolAtomDFSIter" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBMolAtomDFSIter" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter const &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (OpenBabel::OBMolAtomDFSIter *)new OpenBabel::OBMolAtomDFSIter((OpenBabel::OBMolAtomDFSIter const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_OBMolAtomDFSIter(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_OBMolAtomDFSIter__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBMolAtomDFSIter__SWIG_2(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBMolAtomDFSIter__SWIG_4(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_OBMolAtomDFSIter__SWIG_3(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_OBMolAtomDFSIter__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_OBMolAtomDFSIter'");
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBMolAtomDFSIter(OpenBabel::OBMolAtomDFSIter *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_good(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator bool" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (bool)((OpenBabel::OBMolAtomDFSIter const *)arg1)->operator bool();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_inc__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  OpenBabel::OBMolAtomDFSIter *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator ++" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  {
    OpenBabel::OBMolAtomDFSIter &_result_ref = (arg1)->operator ++();
    result = (OpenBabel::OBMolAtomDFSIter *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_inc__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  int arg2 ;
  OpenBabel::OBMolAtomDFSIter result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator ++" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "operator ++" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (arg1)->operator ++(arg2);
  vresult = SWIG_NewPointerObj((new OpenBabel::OBMolAtomDFSIter(static_cast< const OpenBabel::OBMolAtomDFSIter& >(result))), SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolAtomDFSIter_inc(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBMolAtomDFSIter_inc__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBMolAtomDFSIter_inc__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolAtomDFSIter_inc'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_deref(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator ->" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (OpenBabel::OBAtom *)((OpenBabel::OBMolAtomDFSIter const *)arg1)->operator ->();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter___ref__(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator *" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  {
    OpenBabel::OBAtom &_result_ref = ((OpenBabel::OBMolAtomDFSIter const *)arg1)->operator *();
    result = (OpenBabel::OBAtom *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_next(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "next" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (OpenBabel::OBAtom *)(arg1)->next();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_Visit_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Visit" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Visit" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  if (arg1) (*arg1)->Visit = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_Visit_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Visit" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (bool) ((*arg1)->Visit);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_clear(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Clear" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (bool)(*arg1)->Clear();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_set_idx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetIdx" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetIdx" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (*arg1)->SetIdx(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_set_hyb(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetHyb" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetHyb" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (*arg1)->SetHyb(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_set_atomic_num(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetAtomicNum" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetAtomicNum" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (*arg1)->SetAtomicNum(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_set_isotope(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetIsotope" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetIsotope" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  (*arg1)->SetIsotope(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_set_implicit_valence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetImplicitValence" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetImplicitValence" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (*arg1)->SetImplicitValence(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_increment_implicit_valence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IncrementImplicitValence" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  (*arg1)->IncrementImplicitValence();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_decrement_implicit_valence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DecrementImplicitValence" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  (*arg1)->DecrementImplicitValence();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_set_formal_charge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetFormalCharge" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetFormalCharge" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (*arg1)->SetFormalCharge(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_set_spin_multiplicity(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  short arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  short val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetSpinMultiplicity" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  ecode2 = SWIG_AsVal_short(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetSpinMultiplicity" "', argument " "2"" of type '" "short""'");
  } 
  arg2 = static_cast< short >(val2);
  (*arg1)->SetSpinMultiplicity(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_set_type__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetType" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetType" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  (*arg1)->SetType(arg2);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_set_type__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetType" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__string,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetType" "', argument " "2"" of type '" "std::string &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetType" "', argument " "2"" of type '" "std::string &""'"); 
  }
  arg2 = reinterpret_cast< std::string * >(argp2);
  (*arg1)->SetType(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolAtomDFSIter_set_type(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__string, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMolAtomDFSIter_set_type__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMolAtomDFSIter_set_type__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolAtomDFSIter_set_type'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_set_partial_charge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetPartialCharge" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetPartialCharge" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  (*arg1)->SetPartialCharge(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_set_vector__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetVector" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetVector" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetVector" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  (*arg1)->SetVector((OpenBabel::vector3 const &)*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_set_vector__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  double arg2 ;
  double arg3 ;
  double arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetVector" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetVector" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SetVector" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  ecode4 = SWIG_AsVal_double(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "SetVector" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = static_cast< double >(val4);
  (*arg1)->SetVector(arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_set_vector__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetVector" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  (*arg1)->SetVector();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolAtomDFSIter_set_vector(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBMolAtomDFSIter_set_vector__SWIG_2(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__vector3, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMolAtomDFSIter_set_vector__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_double(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_OBMolAtomDFSIter_set_vector__SWIG_1(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolAtomDFSIter_set_vector'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_set_coord_ptr(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  double **arg2 = (double **) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetCoordPtr" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetCoordPtr" "', argument " "2"" of type '" "double **""'"); 
  }
  arg2 = reinterpret_cast< double ** >(argp2);
  (*arg1)->SetCoordPtr(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_set_residue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  OpenBabel::OBResidue *arg2 = (OpenBabel::OBResidue *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetResidue" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetResidue" "', argument " "2"" of type '" "OpenBabel::OBResidue *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBResidue * >(argp2);
  (*arg1)->SetResidue(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_set_parent(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  OpenBabel::OBMol *arg2 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetParent" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetParent" "', argument " "2"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2);
  (*arg1)->SetParent(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_set_aromatic(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetAromatic" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  (*arg1)->SetAromatic();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_unset_aromatic(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnsetAromatic" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  (*arg1)->UnsetAromatic();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_set_clockwise_stereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetClockwiseStereo" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  (*arg1)->SetClockwiseStereo();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_set_anti_clockwise_stereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetAntiClockwiseStereo" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  (*arg1)->SetAntiClockwiseStereo();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_set_positive_stereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetPositiveStereo" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  (*arg1)->SetPositiveStereo();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_set_negative_stereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetNegativeStereo" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  (*arg1)->SetNegativeStereo();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_unset_stereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnsetStereo" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  (*arg1)->UnsetStereo();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_set_in_ring(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetInRing" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  (*arg1)->SetInRing();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_set_chiral(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetChiral" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  (*arg1)->SetChiral();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_clear_coord_ptr(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ClearCoordPtr" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  (*arg1)->ClearCoordPtr();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_get_formal_charge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetFormalCharge" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (int)(*arg1)->GetFormalCharge();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_get_atomic_num(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAtomicNum" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (unsigned int)(*arg1)->GetAtomicNum();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_get_isotope(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  unsigned short result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetIsotope" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (unsigned short)(*arg1)->GetIsotope();
  vresult = SWIG_From_unsigned_SS_short(static_cast< unsigned short >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_get_spin_multiplicity(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetSpinMultiplicity" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (int)(*arg1)->GetSpinMultiplicity();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_get_atomic_mass(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAtomicMass" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (double)(*arg1)->GetAtomicMass();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_get_exact_mass(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetExactMass" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (double)(*arg1)->GetExactMass();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_get_idx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetIdx" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (unsigned int)(*arg1)->GetIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_get_coordinate_idx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetCoordinateIdx" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (unsigned int)(*arg1)->GetCoordinateIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_get_cidx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetCIdx" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (unsigned int)(*arg1)->GetCIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_get_valence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetValence" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (unsigned int)(*arg1)->GetValence();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_get_hyb(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetHyb" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (unsigned int)(*arg1)->GetHyb();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_get_implicit_valence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetImplicitValence" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (unsigned int)(*arg1)->GetImplicitValence();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_get_hvy_valence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetHvyValence" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (unsigned int)(*arg1)->GetHvyValence();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_get_hetero_valence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetHeteroValence" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (unsigned int)(*arg1)->GetHeteroValence();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_get_type(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  char *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetType" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (char *)(*arg1)->GetType();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_get_x(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetX" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (double)(*arg1)->GetX();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_get_y(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetY" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (double)(*arg1)->GetY();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_get_z(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetZ" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (double)(*arg1)->GetZ();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_x(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "x" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (double)(*arg1)->x();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_y(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "y" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (double)(*arg1)->y();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_z(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "z" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (double)(*arg1)->z();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_get_coordinate(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  double *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetCoordinate" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (double *)(*arg1)->GetCoordinate();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_get_vector__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  OpenBabel::vector3 *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetVector" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  {
    OpenBabel::vector3 &_result_ref = (*arg1)->GetVector();
    result = (OpenBabel::vector3 *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_get_vector__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  OpenBabel::vector3 *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetVector" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  {
    OpenBabel::vector3 const &_result_ref = (*arg1)->GetVector();
    result = (OpenBabel::vector3 *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolAtomDFSIter_get_vector(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBMolAtomDFSIter_get_vector__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBMolAtomDFSIter_get_vector__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolAtomDFSIter_get_vector'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_get_partial_charge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetPartialCharge" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (double)(*arg1)->GetPartialCharge();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_get_residue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  OpenBabel::OBResidue *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetResidue" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (OpenBabel::OBResidue *)(*arg1)->GetResidue();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_get_parent(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  OpenBabel::OBMol *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetParent" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (OpenBabel::OBMol *)(*arg1)->GetParent();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_get_new_bond_vector(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  double arg3 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetNewBondVector" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetNewBondVector" "', argument " "2"" of type '" "OpenBabel::vector3 &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GetNewBondVector" "', argument " "2"" of type '" "OpenBabel::vector3 &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  ecode3 = SWIG_AsVal_double(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "GetNewBondVector" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  result = (bool)(*arg1)->GetNewBondVector(*arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_get_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBBond *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetBond" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetBond" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (OpenBabel::OBBond *)(*arg1)->GetBond(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_get_next_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetNextAtom" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (OpenBabel::OBAtom *)(*arg1)->GetNextAtom();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_begin_bonds(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBBond * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginBonds" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (*arg1)->BeginBonds();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBBondIterator(static_cast< const OpenBabel::OBBondIterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_end_bonds(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBBond * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EndBonds" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (*arg1)->EndBonds();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBBondIterator(static_cast< const OpenBabel::OBBondIterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_begin_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  OpenBabel::OBBondIterator *arg2 = 0 ;
  OpenBabel::OBBond *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginBond" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "BeginBond" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "BeginBond" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2);
  result = (OpenBabel::OBBond *)(*arg1)->BeginBond(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_next_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  OpenBabel::OBBondIterator *arg2 = 0 ;
  OpenBabel::OBBond *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NextBond" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "NextBond" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "NextBond" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2);
  result = (OpenBabel::OBBond *)(*arg1)->NextBond(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_begin_nbr_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  OpenBabel::OBBondIterator *arg2 = 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginNbrAtom" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "BeginNbrAtom" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "BeginNbrAtom" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2);
  result = (OpenBabel::OBAtom *)(*arg1)->BeginNbrAtom(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_next_nbr_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  OpenBabel::OBBondIterator *arg2 = 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NextNbrAtom" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "NextNbrAtom" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "NextNbrAtom" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2);
  result = (OpenBabel::OBAtom *)(*arg1)->NextNbrAtom(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_get_distance__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  int arg2 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetDistance" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetDistance" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (double)(*arg1)->GetDistance(arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_get_distance__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetDistance" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetDistance" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (double)(*arg1)->GetDistance(arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolAtomDFSIter_get_distance(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMolAtomDFSIter_get_distance__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBMolAtomDFSIter_get_distance__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolAtomDFSIter_get_distance'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_get_angle__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  int arg2 ;
  int arg3 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAngle" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetAngle" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "GetAngle" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  result = (double)(*arg1)->GetAngle(arg2,arg3);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_get_angle__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg3 = (OpenBabel::OBAtom *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAngle" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetAngle" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "GetAngle" "', argument " "3"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBAtom * >(argp3);
  result = (double)(*arg1)->GetAngle(arg2,arg3);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolAtomDFSIter_get_angle(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_OBMolAtomDFSIter_get_angle__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_OBMolAtomDFSIter_get_angle__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolAtomDFSIter_get_angle'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_new_residue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NewResidue" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  (*arg1)->NewResidue();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_add_residue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  OpenBabel::OBResidue *arg2 = (OpenBabel::OBResidue *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AddResidue" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AddResidue" "', argument " "2"" of type '" "OpenBabel::OBResidue *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBResidue * >(argp2);
  (*arg1)->AddResidue(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_delete_residue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteResidue" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  (*arg1)->DeleteResidue();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_add_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  OpenBabel::OBBond *arg2 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AddBond" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AddBond" "', argument " "2"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBond * >(argp2);
  (*arg1)->AddBond(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_insert_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  OpenBabel::OBBondIterator *arg2 = 0 ;
  OpenBabel::OBBond *arg3 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InsertBond" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InsertBond" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InsertBond" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "InsertBond" "', argument " "3"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBBond * >(argp3);
  (*arg1)->InsertBond(*arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_delete_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  OpenBabel::OBBond *arg2 = (OpenBabel::OBBond *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteBond" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DeleteBond" "', argument " "2"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBond * >(argp2);
  result = (bool)(*arg1)->DeleteBond(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_clear_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ClearBond" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  (*arg1)->ClearBond();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_hto_methyl(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HtoMethyl" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (bool)(*arg1)->HtoMethyl();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_set_hyb_and_geom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetHybAndGeom" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetHybAndGeom" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (bool)(*arg1)->SetHybAndGeom(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_force_no_h(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ForceNoH" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  (*arg1)->ForceNoH();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_has_no_hforced(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasNoHForced" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (bool)(*arg1)->HasNoHForced();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_count_free_oxygens(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CountFreeOxygens" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (unsigned int)(*arg1)->CountFreeOxygens();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_implicit_hydrogen_count(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ImplicitHydrogenCount" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (unsigned int)(*arg1)->ImplicitHydrogenCount();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_explicit_hydrogen_count__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool arg2 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ExplicitHydrogenCount" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ExplicitHydrogenCount" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (unsigned int)(*arg1)->ExplicitHydrogenCount(arg2);
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_explicit_hydrogen_count__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ExplicitHydrogenCount" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (unsigned int)(*arg1)->ExplicitHydrogenCount();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolAtomDFSIter_explicit_hydrogen_count(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBMolAtomDFSIter_explicit_hydrogen_count__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBMolAtomDFSIter_explicit_hydrogen_count__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolAtomDFSIter_explicit_hydrogen_count'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_member_of_ring_count(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MemberOfRingCount" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (unsigned int)(*arg1)->MemberOfRingCount();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_member_of_ring_size(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MemberOfRingSize" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (unsigned int)(*arg1)->MemberOfRingSize();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_count_ring_bonds(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CountRingBonds" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (unsigned int)(*arg1)->CountRingBonds();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_smallest_bond_angle(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SmallestBondAngle" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (double)(*arg1)->SmallestBondAngle();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_average_bond_angle(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AverageBondAngle" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (double)(*arg1)->AverageBondAngle();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_bosum(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BOSum" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (unsigned int)(*arg1)->BOSum();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_kbosum(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KBOSum" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (unsigned int)(*arg1)->KBOSum();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_has_residue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasResidue" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (bool)(*arg1)->HasResidue();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_is_hydrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsHydrogen" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (bool)(*arg1)->IsHydrogen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_is_carbon(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsCarbon" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (bool)(*arg1)->IsCarbon();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_is_nitrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsNitrogen" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (bool)(*arg1)->IsNitrogen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_is_oxygen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsOxygen" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (bool)(*arg1)->IsOxygen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_is_sulfur(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsSulfur" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (bool)(*arg1)->IsSulfur();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_is_phosphorus(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsPhosphorus" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (bool)(*arg1)->IsPhosphorus();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_is_aromatic(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsAromatic" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (bool)(*arg1)->IsAromatic();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_is_in_ring(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsInRing" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (bool)(*arg1)->IsInRing();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_is_in_ring_size(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsInRingSize" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IsInRingSize" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (bool)(*arg1)->IsInRingSize(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_is_heteroatom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsHeteroatom" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (bool)(*arg1)->IsHeteroatom();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_is_not_cor_h(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsNotCorH" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (bool)(*arg1)->IsNotCorH();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_is_connected(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsConnected" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "IsConnected" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (bool)(*arg1)->IsConnected(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_is_one_three(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsOneThree" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "IsOneThree" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (bool)(*arg1)->IsOneThree(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_is_one_four(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsOneFour" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "IsOneFour" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (bool)(*arg1)->IsOneFour(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_is_carboxyl_oxygen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsCarboxylOxygen" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (bool)(*arg1)->IsCarboxylOxygen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_is_phosphate_oxygen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsPhosphateOxygen" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (bool)(*arg1)->IsPhosphateOxygen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_is_sulfate_oxygen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsSulfateOxygen" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (bool)(*arg1)->IsSulfateOxygen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_is_nitro_oxygen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsNitroOxygen" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (bool)(*arg1)->IsNitroOxygen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_is_amide_nitrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsAmideNitrogen" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (bool)(*arg1)->IsAmideNitrogen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_is_polar_hydrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsPolarHydrogen" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (bool)(*arg1)->IsPolarHydrogen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_is_non_polar_hydrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsNonPolarHydrogen" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (bool)(*arg1)->IsNonPolarHydrogen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_is_aromatic_noxide(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsAromaticNOxide" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (bool)(*arg1)->IsAromaticNOxide();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_is_chiral(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsChiral" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (bool)(*arg1)->IsChiral();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_is_axial(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsAxial" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (bool)(*arg1)->IsAxial();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_is_clockwise(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsClockwise" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (bool)(*arg1)->IsClockwise();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_is_anti_clockwise(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsAntiClockwise" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (bool)(*arg1)->IsAntiClockwise();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_is_positive_stereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsPositiveStereo" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (bool)(*arg1)->IsPositiveStereo();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_is_negative_stereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsNegativeStereo" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (bool)(*arg1)->IsNegativeStereo();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_has_chirality_specified(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasChiralitySpecified" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (bool)(*arg1)->HasChiralitySpecified();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_has_chiral_volume(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasChiralVolume" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (bool)(*arg1)->HasChiralVolume();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_is_hbond_acceptor(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsHbondAcceptor" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (bool)(*arg1)->IsHbondAcceptor();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_is_hbond_donor(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsHbondDonor" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (bool)(*arg1)->IsHbondDonor();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_is_hbond_donor_h(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsHbondDonorH" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (bool)(*arg1)->IsHbondDonorH();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_has_alpha_beta_unsat__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasAlphaBetaUnsat" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "HasAlphaBetaUnsat" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (bool)(*arg1)->HasAlphaBetaUnsat(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_has_alpha_beta_unsat__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasAlphaBetaUnsat" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (bool)(*arg1)->HasAlphaBetaUnsat();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolAtomDFSIter_has_alpha_beta_unsat(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBMolAtomDFSIter_has_alpha_beta_unsat__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBMolAtomDFSIter_has_alpha_beta_unsat__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolAtomDFSIter_has_alpha_beta_unsat'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_has_bond_of_order(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  unsigned int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasBondOfOrder" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "HasBondOfOrder" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (bool)(*arg1)->HasBondOfOrder(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_count_bonds_of_order(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  unsigned int arg2 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CountBondsOfOrder" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CountBondsOfOrder" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (int)(*arg1)->CountBondsOfOrder(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_has_non_single_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasNonSingleBond" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (bool)(*arg1)->HasNonSingleBond();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_has_single_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasSingleBond" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (bool)(*arg1)->HasSingleBond();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_has_double_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasDoubleBond" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (bool)(*arg1)->HasDoubleBond();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_has_aromatic_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasAromaticBond" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (bool)(*arg1)->HasAromaticBond();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_matches_smarts(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  char *arg2 = (char *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MatchesSMARTS" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MatchesSMARTS" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (bool)(*arg1)->MatchesSMARTS((char const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_do_transformations(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  std::map<std::string,std::string > *arg2 = (std::map<std::string,std::string > *) 0 ;
  OpenBabel::OBBase *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DoTransformations" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_std__mapTstd__string_std__string_t, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DoTransformations" "', argument " "2"" of type '" "std::map<std::string,std::string > const *""'"); 
  }
  arg2 = reinterpret_cast< std::map<std::string,std::string > * >(argp2);
  result = (OpenBabel::OBBase *)(*arg1)->DoTransformations((std::map<std::string,std::string > const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_class_description(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  char *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ClassDescription" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (char *)(*arg1)->ClassDescription();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_has_data__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  std::string *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "HasData" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "HasData" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (bool)(*arg1)->HasData((std::string const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_has_data__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  char *arg2 = (char *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "HasData" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (bool)(*arg1)->HasData((char const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_has_data__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  unsigned int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "HasData" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (bool)(*arg1)->HasData(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolAtomDFSIter_has_data(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBMolAtomDFSIter_has_data__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMolAtomDFSIter_has_data__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMolAtomDFSIter_has_data__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolAtomDFSIter_has_data'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_delete_data__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DeleteData" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  (*arg1)->DeleteData(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_delete_data__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  OpenBabel::OBGenericData *arg2 = (OpenBabel::OBGenericData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DeleteData" "', argument " "2"" of type '" "OpenBabel::OBGenericData *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBGenericData * >(argp2);
  (*arg1)->DeleteData(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_delete_data__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  std::vector<OpenBabel::OBGenericData * > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DeleteData" "', argument " "2"" of type '" "std::vector<OpenBabel::OBGenericData * > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DeleteData" "', argument " "2"" of type '" "std::vector<OpenBabel::OBGenericData * > &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<OpenBabel::OBGenericData * > * >(argp2);
  (*arg1)->DeleteData(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolAtomDFSIter_delete_data(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBGenericData, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMolAtomDFSIter_delete_data__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMolAtomDFSIter_delete_data__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBMolAtomDFSIter_delete_data__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolAtomDFSIter_delete_data'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_set_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  OpenBabel::OBGenericData *arg2 = (OpenBabel::OBGenericData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetData" "', argument " "2"" of type '" "OpenBabel::OBGenericData *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBGenericData * >(argp2);
  (*arg1)->SetData(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_data_size(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataSize" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (unsigned int)(*arg1)->DataSize();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_get_data__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  unsigned int arg2 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetData" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (OpenBabel::OBGenericData *)(*arg1)->GetData(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_get_data__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  std::string *arg2 = 0 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetData" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GetData" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (OpenBabel::OBGenericData *)(*arg1)->GetData((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_get_data__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  char *arg2 = (char *) 0 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetData" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (OpenBabel::OBGenericData *)(*arg1)->GetData((char const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_get_data__SWIG_3(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  std::vector<OpenBabel::OBGenericData * > *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  {
    std::vector<OpenBabel::OBGenericData * > &_result_ref = (*arg1)->GetData();
    result = (std::vector<OpenBabel::OBGenericData * > *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_get_data__SWIG_4(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  OpenBabel::DataOrigin arg2 ;
  std::vector<OpenBabel::OBGenericData * > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetData" "', argument " "2"" of type '" "OpenBabel::DataOrigin""'");
  } 
  arg2 = static_cast< OpenBabel::DataOrigin >(val2);
  result = (*arg1)->GetData(arg2);
  {
    vresult = rb_ary_new2((&result)->size());
    for (unsigned int i=0; i<(&result)->size(); i++) {
      OpenBabel::OBGenericData* x = ((std::vector<OpenBabel::OBGenericData * > &)result)[i];
      rb_ary_store(vresult,i,
        SWIG_NewPointerObj((void *) x, 
          SWIGTYPE_p_OpenBabel__OBGenericData, 0));
    }
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolAtomDFSIter_get_data(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBMolAtomDFSIter_get_data__SWIG_3(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBMolAtomDFSIter_get_data__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBMolAtomDFSIter_get_data__SWIG_4(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMolAtomDFSIter_get_data__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMolAtomDFSIter_get_data__SWIG_2(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolAtomDFSIter_get_data'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_begin_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBGenericData * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (*arg1)->BeginData();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBDataIterator(static_cast< const OpenBabel::OBDataIterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomDFSIter_end_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomDFSIter *arg1 = (OpenBabel::OBMolAtomDFSIter *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBGenericData * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EndData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomDFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp1);
  result = (*arg1)->EndData();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBDataIterator(static_cast< const OpenBabel::OBDataIterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


swig_class cOBMolAtomBFSIter;

SWIGINTERN VALUE
_wrap_new_OBMolAtomBFSIter__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBMolAtomBFSIter *)new OpenBabel::OBMolAtomBFSIter();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_OBMolAtomBFSIter__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBMolAtomBFSIter *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBMolAtomBFSIter" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (OpenBabel::OBMolAtomBFSIter *)new OpenBabel::OBMolAtomBFSIter(arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBMolAtomBFSIter_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBMolAtomBFSIter__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = 0 ;
  OpenBabel::OBMolAtomBFSIter *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBMolAtomBFSIter" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBMolAtomBFSIter" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter const &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (OpenBabel::OBMolAtomBFSIter *)new OpenBabel::OBMolAtomBFSIter((OpenBabel::OBMolAtomBFSIter const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_OBMolAtomBFSIter(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_OBMolAtomBFSIter__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBMolAtomBFSIter__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBMolAtomBFSIter__SWIG_2(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_OBMolAtomBFSIter'");
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBMolAtomBFSIter(OpenBabel::OBMolAtomBFSIter *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_good(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator bool" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (bool)((OpenBabel::OBMolAtomBFSIter const *)arg1)->operator bool();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_inc__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  OpenBabel::OBMolAtomBFSIter *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator ++" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  {
    OpenBabel::OBMolAtomBFSIter &_result_ref = (arg1)->operator ++();
    result = (OpenBabel::OBMolAtomBFSIter *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_inc__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  int arg2 ;
  OpenBabel::OBMolAtomBFSIter result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator ++" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "operator ++" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (arg1)->operator ++(arg2);
  vresult = SWIG_NewPointerObj((new OpenBabel::OBMolAtomBFSIter(static_cast< const OpenBabel::OBMolAtomBFSIter& >(result))), SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolAtomBFSIter_inc(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBMolAtomBFSIter_inc__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBMolAtomBFSIter_inc__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolAtomBFSIter_inc'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_deref(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator ->" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (OpenBabel::OBAtom *)((OpenBabel::OBMolAtomBFSIter const *)arg1)->operator ->();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter___ref__(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator *" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  {
    OpenBabel::OBAtom &_result_ref = ((OpenBabel::OBMolAtomBFSIter const *)arg1)->operator *();
    result = (OpenBabel::OBAtom *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_Visit_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Visit" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Visit" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  if (arg1) (*arg1)->Visit = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_Visit_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Visit" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (bool) ((*arg1)->Visit);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_clear(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Clear" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (bool)(*arg1)->Clear();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_set_idx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetIdx" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetIdx" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (*arg1)->SetIdx(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_set_hyb(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetHyb" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetHyb" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (*arg1)->SetHyb(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_set_atomic_num(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetAtomicNum" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetAtomicNum" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (*arg1)->SetAtomicNum(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_set_isotope(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetIsotope" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetIsotope" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  (*arg1)->SetIsotope(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_set_implicit_valence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetImplicitValence" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetImplicitValence" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (*arg1)->SetImplicitValence(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_increment_implicit_valence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IncrementImplicitValence" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  (*arg1)->IncrementImplicitValence();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_decrement_implicit_valence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DecrementImplicitValence" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  (*arg1)->DecrementImplicitValence();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_set_formal_charge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetFormalCharge" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetFormalCharge" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (*arg1)->SetFormalCharge(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_set_spin_multiplicity(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  short arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  short val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetSpinMultiplicity" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  ecode2 = SWIG_AsVal_short(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetSpinMultiplicity" "', argument " "2"" of type '" "short""'");
  } 
  arg2 = static_cast< short >(val2);
  (*arg1)->SetSpinMultiplicity(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_set_type__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetType" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetType" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  (*arg1)->SetType(arg2);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_set_type__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetType" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__string,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetType" "', argument " "2"" of type '" "std::string &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetType" "', argument " "2"" of type '" "std::string &""'"); 
  }
  arg2 = reinterpret_cast< std::string * >(argp2);
  (*arg1)->SetType(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolAtomBFSIter_set_type(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__string, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMolAtomBFSIter_set_type__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMolAtomBFSIter_set_type__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolAtomBFSIter_set_type'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_set_partial_charge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetPartialCharge" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetPartialCharge" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  (*arg1)->SetPartialCharge(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_set_vector__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetVector" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetVector" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetVector" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  (*arg1)->SetVector((OpenBabel::vector3 const &)*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_set_vector__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  double arg2 ;
  double arg3 ;
  double arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetVector" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetVector" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SetVector" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  ecode4 = SWIG_AsVal_double(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "SetVector" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = static_cast< double >(val4);
  (*arg1)->SetVector(arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_set_vector__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetVector" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  (*arg1)->SetVector();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolAtomBFSIter_set_vector(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBMolAtomBFSIter_set_vector__SWIG_2(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__vector3, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMolAtomBFSIter_set_vector__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_double(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_OBMolAtomBFSIter_set_vector__SWIG_1(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolAtomBFSIter_set_vector'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_set_coord_ptr(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  double **arg2 = (double **) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetCoordPtr" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetCoordPtr" "', argument " "2"" of type '" "double **""'"); 
  }
  arg2 = reinterpret_cast< double ** >(argp2);
  (*arg1)->SetCoordPtr(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_set_residue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  OpenBabel::OBResidue *arg2 = (OpenBabel::OBResidue *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetResidue" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetResidue" "', argument " "2"" of type '" "OpenBabel::OBResidue *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBResidue * >(argp2);
  (*arg1)->SetResidue(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_set_parent(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  OpenBabel::OBMol *arg2 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetParent" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetParent" "', argument " "2"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2);
  (*arg1)->SetParent(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_set_aromatic(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetAromatic" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  (*arg1)->SetAromatic();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_unset_aromatic(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnsetAromatic" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  (*arg1)->UnsetAromatic();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_set_clockwise_stereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetClockwiseStereo" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  (*arg1)->SetClockwiseStereo();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_set_anti_clockwise_stereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetAntiClockwiseStereo" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  (*arg1)->SetAntiClockwiseStereo();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_set_positive_stereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetPositiveStereo" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  (*arg1)->SetPositiveStereo();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_set_negative_stereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetNegativeStereo" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  (*arg1)->SetNegativeStereo();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_unset_stereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnsetStereo" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  (*arg1)->UnsetStereo();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_set_in_ring(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetInRing" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  (*arg1)->SetInRing();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_set_chiral(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetChiral" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  (*arg1)->SetChiral();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_clear_coord_ptr(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ClearCoordPtr" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  (*arg1)->ClearCoordPtr();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_get_formal_charge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetFormalCharge" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (int)(*arg1)->GetFormalCharge();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_get_atomic_num(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAtomicNum" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (unsigned int)(*arg1)->GetAtomicNum();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_get_isotope(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  unsigned short result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetIsotope" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (unsigned short)(*arg1)->GetIsotope();
  vresult = SWIG_From_unsigned_SS_short(static_cast< unsigned short >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_get_spin_multiplicity(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetSpinMultiplicity" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (int)(*arg1)->GetSpinMultiplicity();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_get_atomic_mass(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAtomicMass" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (double)(*arg1)->GetAtomicMass();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_get_exact_mass(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetExactMass" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (double)(*arg1)->GetExactMass();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_get_idx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetIdx" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (unsigned int)(*arg1)->GetIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_get_coordinate_idx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetCoordinateIdx" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (unsigned int)(*arg1)->GetCoordinateIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_get_cidx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetCIdx" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (unsigned int)(*arg1)->GetCIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_get_valence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetValence" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (unsigned int)(*arg1)->GetValence();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_get_hyb(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetHyb" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (unsigned int)(*arg1)->GetHyb();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_get_implicit_valence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetImplicitValence" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (unsigned int)(*arg1)->GetImplicitValence();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_get_hvy_valence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetHvyValence" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (unsigned int)(*arg1)->GetHvyValence();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_get_hetero_valence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetHeteroValence" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (unsigned int)(*arg1)->GetHeteroValence();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_get_type(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  char *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetType" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (char *)(*arg1)->GetType();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_get_x(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetX" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (double)(*arg1)->GetX();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_get_y(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetY" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (double)(*arg1)->GetY();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_get_z(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetZ" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (double)(*arg1)->GetZ();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_x(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "x" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (double)(*arg1)->x();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_y(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "y" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (double)(*arg1)->y();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_z(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "z" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (double)(*arg1)->z();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_get_coordinate(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  double *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetCoordinate" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (double *)(*arg1)->GetCoordinate();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_get_vector__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  OpenBabel::vector3 *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetVector" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  {
    OpenBabel::vector3 &_result_ref = (*arg1)->GetVector();
    result = (OpenBabel::vector3 *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_get_vector__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  OpenBabel::vector3 *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetVector" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  {
    OpenBabel::vector3 const &_result_ref = (*arg1)->GetVector();
    result = (OpenBabel::vector3 *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolAtomBFSIter_get_vector(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBMolAtomBFSIter_get_vector__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBMolAtomBFSIter_get_vector__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolAtomBFSIter_get_vector'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_get_partial_charge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetPartialCharge" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (double)(*arg1)->GetPartialCharge();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_get_residue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  OpenBabel::OBResidue *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetResidue" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (OpenBabel::OBResidue *)(*arg1)->GetResidue();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_get_parent(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  OpenBabel::OBMol *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetParent" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (OpenBabel::OBMol *)(*arg1)->GetParent();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_get_new_bond_vector(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  double arg3 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetNewBondVector" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetNewBondVector" "', argument " "2"" of type '" "OpenBabel::vector3 &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GetNewBondVector" "', argument " "2"" of type '" "OpenBabel::vector3 &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  ecode3 = SWIG_AsVal_double(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "GetNewBondVector" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  result = (bool)(*arg1)->GetNewBondVector(*arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_get_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBBond *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetBond" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetBond" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (OpenBabel::OBBond *)(*arg1)->GetBond(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_get_next_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetNextAtom" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (OpenBabel::OBAtom *)(*arg1)->GetNextAtom();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_begin_bonds(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBBond * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginBonds" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (*arg1)->BeginBonds();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBBondIterator(static_cast< const OpenBabel::OBBondIterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_end_bonds(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBBond * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EndBonds" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (*arg1)->EndBonds();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBBondIterator(static_cast< const OpenBabel::OBBondIterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_begin_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  OpenBabel::OBBondIterator *arg2 = 0 ;
  OpenBabel::OBBond *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginBond" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "BeginBond" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "BeginBond" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2);
  result = (OpenBabel::OBBond *)(*arg1)->BeginBond(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_next_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  OpenBabel::OBBondIterator *arg2 = 0 ;
  OpenBabel::OBBond *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NextBond" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "NextBond" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "NextBond" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2);
  result = (OpenBabel::OBBond *)(*arg1)->NextBond(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_begin_nbr_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  OpenBabel::OBBondIterator *arg2 = 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginNbrAtom" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "BeginNbrAtom" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "BeginNbrAtom" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2);
  result = (OpenBabel::OBAtom *)(*arg1)->BeginNbrAtom(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_next_nbr_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  OpenBabel::OBBondIterator *arg2 = 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NextNbrAtom" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "NextNbrAtom" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "NextNbrAtom" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2);
  result = (OpenBabel::OBAtom *)(*arg1)->NextNbrAtom(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_get_distance__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  int arg2 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetDistance" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetDistance" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (double)(*arg1)->GetDistance(arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_get_distance__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetDistance" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetDistance" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (double)(*arg1)->GetDistance(arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolAtomBFSIter_get_distance(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMolAtomBFSIter_get_distance__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBMolAtomBFSIter_get_distance__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolAtomBFSIter_get_distance'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_get_angle__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  int arg2 ;
  int arg3 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAngle" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetAngle" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "GetAngle" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  result = (double)(*arg1)->GetAngle(arg2,arg3);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_get_angle__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg3 = (OpenBabel::OBAtom *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAngle" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetAngle" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "GetAngle" "', argument " "3"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBAtom * >(argp3);
  result = (double)(*arg1)->GetAngle(arg2,arg3);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolAtomBFSIter_get_angle(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_OBMolAtomBFSIter_get_angle__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_OBMolAtomBFSIter_get_angle__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolAtomBFSIter_get_angle'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_new_residue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NewResidue" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  (*arg1)->NewResidue();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_add_residue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  OpenBabel::OBResidue *arg2 = (OpenBabel::OBResidue *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AddResidue" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AddResidue" "', argument " "2"" of type '" "OpenBabel::OBResidue *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBResidue * >(argp2);
  (*arg1)->AddResidue(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_delete_residue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteResidue" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  (*arg1)->DeleteResidue();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_add_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  OpenBabel::OBBond *arg2 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AddBond" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AddBond" "', argument " "2"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBond * >(argp2);
  (*arg1)->AddBond(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_insert_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  OpenBabel::OBBondIterator *arg2 = 0 ;
  OpenBabel::OBBond *arg3 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InsertBond" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InsertBond" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InsertBond" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "InsertBond" "', argument " "3"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBBond * >(argp3);
  (*arg1)->InsertBond(*arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_delete_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  OpenBabel::OBBond *arg2 = (OpenBabel::OBBond *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteBond" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DeleteBond" "', argument " "2"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBond * >(argp2);
  result = (bool)(*arg1)->DeleteBond(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_clear_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ClearBond" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  (*arg1)->ClearBond();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_hto_methyl(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HtoMethyl" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (bool)(*arg1)->HtoMethyl();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_set_hyb_and_geom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetHybAndGeom" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetHybAndGeom" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (bool)(*arg1)->SetHybAndGeom(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_force_no_h(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ForceNoH" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  (*arg1)->ForceNoH();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_has_no_hforced(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasNoHForced" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (bool)(*arg1)->HasNoHForced();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_count_free_oxygens(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CountFreeOxygens" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (unsigned int)(*arg1)->CountFreeOxygens();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_implicit_hydrogen_count(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ImplicitHydrogenCount" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (unsigned int)(*arg1)->ImplicitHydrogenCount();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_explicit_hydrogen_count__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool arg2 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ExplicitHydrogenCount" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ExplicitHydrogenCount" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (unsigned int)(*arg1)->ExplicitHydrogenCount(arg2);
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_explicit_hydrogen_count__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ExplicitHydrogenCount" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (unsigned int)(*arg1)->ExplicitHydrogenCount();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolAtomBFSIter_explicit_hydrogen_count(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBMolAtomBFSIter_explicit_hydrogen_count__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBMolAtomBFSIter_explicit_hydrogen_count__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolAtomBFSIter_explicit_hydrogen_count'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_member_of_ring_count(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MemberOfRingCount" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (unsigned int)(*arg1)->MemberOfRingCount();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_member_of_ring_size(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MemberOfRingSize" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (unsigned int)(*arg1)->MemberOfRingSize();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_count_ring_bonds(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CountRingBonds" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (unsigned int)(*arg1)->CountRingBonds();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_smallest_bond_angle(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SmallestBondAngle" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (double)(*arg1)->SmallestBondAngle();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_average_bond_angle(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AverageBondAngle" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (double)(*arg1)->AverageBondAngle();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_bosum(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BOSum" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (unsigned int)(*arg1)->BOSum();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_kbosum(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KBOSum" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (unsigned int)(*arg1)->KBOSum();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_has_residue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasResidue" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (bool)(*arg1)->HasResidue();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_is_hydrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsHydrogen" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (bool)(*arg1)->IsHydrogen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_is_carbon(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsCarbon" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (bool)(*arg1)->IsCarbon();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_is_nitrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsNitrogen" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (bool)(*arg1)->IsNitrogen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_is_oxygen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsOxygen" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (bool)(*arg1)->IsOxygen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_is_sulfur(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsSulfur" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (bool)(*arg1)->IsSulfur();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_is_phosphorus(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsPhosphorus" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (bool)(*arg1)->IsPhosphorus();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_is_aromatic(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsAromatic" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (bool)(*arg1)->IsAromatic();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_is_in_ring(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsInRing" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (bool)(*arg1)->IsInRing();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_is_in_ring_size(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsInRingSize" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IsInRingSize" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (bool)(*arg1)->IsInRingSize(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_is_heteroatom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsHeteroatom" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (bool)(*arg1)->IsHeteroatom();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_is_not_cor_h(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsNotCorH" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (bool)(*arg1)->IsNotCorH();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_is_connected(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsConnected" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "IsConnected" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (bool)(*arg1)->IsConnected(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_is_one_three(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsOneThree" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "IsOneThree" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (bool)(*arg1)->IsOneThree(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_is_one_four(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsOneFour" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "IsOneFour" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (bool)(*arg1)->IsOneFour(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_is_carboxyl_oxygen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsCarboxylOxygen" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (bool)(*arg1)->IsCarboxylOxygen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_is_phosphate_oxygen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsPhosphateOxygen" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (bool)(*arg1)->IsPhosphateOxygen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_is_sulfate_oxygen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsSulfateOxygen" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (bool)(*arg1)->IsSulfateOxygen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_is_nitro_oxygen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsNitroOxygen" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (bool)(*arg1)->IsNitroOxygen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_is_amide_nitrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsAmideNitrogen" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (bool)(*arg1)->IsAmideNitrogen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_is_polar_hydrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsPolarHydrogen" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (bool)(*arg1)->IsPolarHydrogen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_is_non_polar_hydrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsNonPolarHydrogen" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (bool)(*arg1)->IsNonPolarHydrogen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_is_aromatic_noxide(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsAromaticNOxide" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (bool)(*arg1)->IsAromaticNOxide();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_is_chiral(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsChiral" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (bool)(*arg1)->IsChiral();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_is_axial(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsAxial" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (bool)(*arg1)->IsAxial();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_is_clockwise(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsClockwise" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (bool)(*arg1)->IsClockwise();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_is_anti_clockwise(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsAntiClockwise" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (bool)(*arg1)->IsAntiClockwise();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_is_positive_stereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsPositiveStereo" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (bool)(*arg1)->IsPositiveStereo();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_is_negative_stereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsNegativeStereo" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (bool)(*arg1)->IsNegativeStereo();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_has_chirality_specified(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasChiralitySpecified" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (bool)(*arg1)->HasChiralitySpecified();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_has_chiral_volume(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasChiralVolume" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (bool)(*arg1)->HasChiralVolume();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_is_hbond_acceptor(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsHbondAcceptor" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (bool)(*arg1)->IsHbondAcceptor();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_is_hbond_donor(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsHbondDonor" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (bool)(*arg1)->IsHbondDonor();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_is_hbond_donor_h(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsHbondDonorH" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (bool)(*arg1)->IsHbondDonorH();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_has_alpha_beta_unsat__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasAlphaBetaUnsat" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "HasAlphaBetaUnsat" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (bool)(*arg1)->HasAlphaBetaUnsat(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_has_alpha_beta_unsat__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasAlphaBetaUnsat" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (bool)(*arg1)->HasAlphaBetaUnsat();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolAtomBFSIter_has_alpha_beta_unsat(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBMolAtomBFSIter_has_alpha_beta_unsat__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBMolAtomBFSIter_has_alpha_beta_unsat__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolAtomBFSIter_has_alpha_beta_unsat'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_has_bond_of_order(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  unsigned int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasBondOfOrder" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "HasBondOfOrder" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (bool)(*arg1)->HasBondOfOrder(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_count_bonds_of_order(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  unsigned int arg2 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CountBondsOfOrder" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CountBondsOfOrder" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (int)(*arg1)->CountBondsOfOrder(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_has_non_single_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasNonSingleBond" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (bool)(*arg1)->HasNonSingleBond();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_has_single_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasSingleBond" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (bool)(*arg1)->HasSingleBond();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_has_double_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasDoubleBond" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (bool)(*arg1)->HasDoubleBond();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_has_aromatic_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasAromaticBond" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (bool)(*arg1)->HasAromaticBond();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_matches_smarts(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  char *arg2 = (char *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MatchesSMARTS" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MatchesSMARTS" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (bool)(*arg1)->MatchesSMARTS((char const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_do_transformations(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  std::map<std::string,std::string > *arg2 = (std::map<std::string,std::string > *) 0 ;
  OpenBabel::OBBase *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DoTransformations" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_std__mapTstd__string_std__string_t, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DoTransformations" "', argument " "2"" of type '" "std::map<std::string,std::string > const *""'"); 
  }
  arg2 = reinterpret_cast< std::map<std::string,std::string > * >(argp2);
  result = (OpenBabel::OBBase *)(*arg1)->DoTransformations((std::map<std::string,std::string > const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_class_description(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  char *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ClassDescription" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (char *)(*arg1)->ClassDescription();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_has_data__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  std::string *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "HasData" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "HasData" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (bool)(*arg1)->HasData((std::string const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_has_data__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  char *arg2 = (char *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "HasData" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (bool)(*arg1)->HasData((char const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_has_data__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  unsigned int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "HasData" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (bool)(*arg1)->HasData(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolAtomBFSIter_has_data(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBMolAtomBFSIter_has_data__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMolAtomBFSIter_has_data__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMolAtomBFSIter_has_data__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolAtomBFSIter_has_data'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_delete_data__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DeleteData" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  (*arg1)->DeleteData(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_delete_data__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  OpenBabel::OBGenericData *arg2 = (OpenBabel::OBGenericData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DeleteData" "', argument " "2"" of type '" "OpenBabel::OBGenericData *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBGenericData * >(argp2);
  (*arg1)->DeleteData(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_delete_data__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  std::vector<OpenBabel::OBGenericData * > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DeleteData" "', argument " "2"" of type '" "std::vector<OpenBabel::OBGenericData * > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DeleteData" "', argument " "2"" of type '" "std::vector<OpenBabel::OBGenericData * > &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<OpenBabel::OBGenericData * > * >(argp2);
  (*arg1)->DeleteData(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolAtomBFSIter_delete_data(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBGenericData, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMolAtomBFSIter_delete_data__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMolAtomBFSIter_delete_data__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBMolAtomBFSIter_delete_data__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolAtomBFSIter_delete_data'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_set_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  OpenBabel::OBGenericData *arg2 = (OpenBabel::OBGenericData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetData" "', argument " "2"" of type '" "OpenBabel::OBGenericData *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBGenericData * >(argp2);
  (*arg1)->SetData(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_data_size(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataSize" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (unsigned int)(*arg1)->DataSize();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_get_data__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  unsigned int arg2 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetData" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (OpenBabel::OBGenericData *)(*arg1)->GetData(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_get_data__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  std::string *arg2 = 0 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetData" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GetData" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (OpenBabel::OBGenericData *)(*arg1)->GetData((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_get_data__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  char *arg2 = (char *) 0 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetData" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (OpenBabel::OBGenericData *)(*arg1)->GetData((char const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_get_data__SWIG_3(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  std::vector<OpenBabel::OBGenericData * > *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  {
    std::vector<OpenBabel::OBGenericData * > &_result_ref = (*arg1)->GetData();
    result = (std::vector<OpenBabel::OBGenericData * > *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_get_data__SWIG_4(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  OpenBabel::DataOrigin arg2 ;
  std::vector<OpenBabel::OBGenericData * > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetData" "', argument " "2"" of type '" "OpenBabel::DataOrigin""'");
  } 
  arg2 = static_cast< OpenBabel::DataOrigin >(val2);
  result = (*arg1)->GetData(arg2);
  {
    vresult = rb_ary_new2((&result)->size());
    for (unsigned int i=0; i<(&result)->size(); i++) {
      OpenBabel::OBGenericData* x = ((std::vector<OpenBabel::OBGenericData * > &)result)[i];
      rb_ary_store(vresult,i,
        SWIG_NewPointerObj((void *) x, 
          SWIGTYPE_p_OpenBabel__OBGenericData, 0));
    }
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolAtomBFSIter_get_data(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBMolAtomBFSIter_get_data__SWIG_3(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBMolAtomBFSIter_get_data__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBMolAtomBFSIter_get_data__SWIG_4(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMolAtomBFSIter_get_data__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMolAtomBFSIter_get_data__SWIG_2(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolAtomBFSIter_get_data'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_begin_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBGenericData * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (*arg1)->BeginData();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBDataIterator(static_cast< const OpenBabel::OBDataIterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAtomBFSIter_end_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomBFSIter *arg1 = (OpenBabel::OBMolAtomBFSIter *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBGenericData * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EndData" "', argument " "1"" of type '" "OpenBabel::OBMolAtomBFSIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomBFSIter * >(argp1);
  result = (*arg1)->EndData();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBDataIterator(static_cast< const OpenBabel::OBDataIterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


swig_class cOBMolBondIter;

SWIGINTERN VALUE
_wrap_new_OBMolBondIter__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBMolBondIter *)new OpenBabel::OBMolBondIter();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_OBMolBondIter__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBMolBondIter *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBMolBondIter" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (OpenBabel::OBMolBondIter *)new OpenBabel::OBMolBondIter(arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBMolBondIter_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBMolBondIter_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBMolBondIter);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBMolBondIter__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = 0 ;
  OpenBabel::OBMolBondIter *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBMolBondIter,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBMolBondIter" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBMolBondIter" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter const &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (OpenBabel::OBMolBondIter *)new OpenBabel::OBMolBondIter((OpenBabel::OBMolBondIter const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_OBMolBondIter(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_OBMolBondIter__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBMolBondIter__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolBondIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBMolBondIter__SWIG_2(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_OBMolBondIter'");
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBMolBondIter(OpenBabel::OBMolBondIter *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_OBMolBondIter_good(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator bool" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (bool)((OpenBabel::OBMolBondIter const *)arg1)->operator bool();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_inc__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  OpenBabel::OBMolBondIter *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator ++" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  {
    OpenBabel::OBMolBondIter &_result_ref = (arg1)->operator ++();
    result = (OpenBabel::OBMolBondIter *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_inc__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  int arg2 ;
  OpenBabel::OBMolBondIter result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator ++" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "operator ++" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (arg1)->operator ++(arg2);
  vresult = SWIG_NewPointerObj((new OpenBabel::OBMolBondIter(static_cast< const OpenBabel::OBMolBondIter& >(result))), SWIGTYPE_p_OpenBabel__OBMolBondIter, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolBondIter_inc(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolBondIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBMolBondIter_inc__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolBondIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBMolBondIter_inc__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolBondIter_inc'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_deref(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  OpenBabel::OBBond *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator ->" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (OpenBabel::OBBond *)((OpenBabel::OBMolBondIter const *)arg1)->operator ->();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter___ref__(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  OpenBabel::OBBond *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator *" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  {
    OpenBabel::OBBond &_result_ref = ((OpenBabel::OBMolBondIter const *)arg1)->operator *();
    result = (OpenBabel::OBBond *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_Visit_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Visit" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Visit" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  if (arg1) (*arg1)->Visit = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_Visit_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Visit" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (bool) ((*arg1)->Visit);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_set_idx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetIdx" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetIdx" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (*arg1)->SetIdx(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_set_bo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetBO" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetBO" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (*arg1)->SetBO(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_set_bond_order(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetBondOrder" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetBondOrder" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (*arg1)->SetBondOrder(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_set_begin(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetBegin" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetBegin" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  (*arg1)->SetBegin(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_set_end(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetEnd" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetEnd" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  (*arg1)->SetEnd(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_set_parent(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  OpenBabel::OBMol *arg2 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetParent" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetParent" "', argument " "2"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2);
  (*arg1)->SetParent(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_set_length(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetLength" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetLength" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  ecode3 = SWIG_AsVal_double(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SetLength" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  (*arg1)->SetLength(arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  int arg2 ;
  OpenBabel::OBAtom *arg3 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg4 = (OpenBabel::OBAtom *) 0 ;
  int arg5 ;
  int arg6 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  
  if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Set" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Set" "', argument " "3"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBAtom * >(argp3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Set" "', argument " "4"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg4 = reinterpret_cast< OpenBabel::OBAtom * >(argp4);
  ecode5 = SWIG_AsVal_int(argv[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Set" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = static_cast< int >(val5);
  ecode6 = SWIG_AsVal_int(argv[4], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "Set" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = static_cast< int >(val6);
  (*arg1)->Set(arg2,arg3,arg4,arg5,arg6);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_set_ksingle(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetKSingle" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  (*arg1)->SetKSingle();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_set_kdouble(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetKDouble" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  (*arg1)->SetKDouble();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_set_ktriple(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetKTriple" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  (*arg1)->SetKTriple();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_set_aromatic(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetAromatic" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  (*arg1)->SetAromatic();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_set_hash(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetHash" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  (*arg1)->SetHash();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_set_wedge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetWedge" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  (*arg1)->SetWedge();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_set_up(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetUp" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  (*arg1)->SetUp();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_set_down(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetDown" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  (*arg1)->SetDown();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_set_in_ring(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetInRing" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  (*arg1)->SetInRing();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_set_closure(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetClosure" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  (*arg1)->SetClosure();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_unset_hash(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnsetHash" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  (*arg1)->UnsetHash();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_unset_wedge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnsetWedge" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  (*arg1)->UnsetWedge();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_unset_up(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnsetUp" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  (*arg1)->UnsetUp();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_unset_down(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnsetDown" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  (*arg1)->UnsetDown();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_unset_aromatic(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnsetAromatic" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  (*arg1)->UnsetAromatic();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_unset_kekule(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnsetKekule" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  (*arg1)->UnsetKekule();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_get_idx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetIdx" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (unsigned int)(*arg1)->GetIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_get_bo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetBO" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (unsigned int)(*arg1)->GetBO();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_get_bond_order(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetBondOrder" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (unsigned int)(*arg1)->GetBondOrder();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_get_flags(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetFlags" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (unsigned int)(*arg1)->GetFlags();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_get_begin_atom_idx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetBeginAtomIdx" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (unsigned int)(*arg1)->GetBeginAtomIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_get_end_atom_idx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetEndAtomIdx" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (unsigned int)(*arg1)->GetEndAtomIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_get_begin_atom__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetBeginAtom" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (OpenBabel::OBAtom *)(*arg1)->GetBeginAtom();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_get_begin_atom__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetBeginAtom" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (OpenBabel::OBAtom *)(*arg1)->GetBeginAtom();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolBondIter_get_begin_atom(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolBondIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBMolBondIter_get_begin_atom__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolBondIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBMolBondIter_get_begin_atom__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolBondIter_get_begin_atom'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_get_end_atom__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetEndAtom" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (OpenBabel::OBAtom *)(*arg1)->GetEndAtom();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_get_end_atom__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetEndAtom" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (OpenBabel::OBAtom *)(*arg1)->GetEndAtom();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolBondIter_get_end_atom(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolBondIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBMolBondIter_get_end_atom__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolBondIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBMolBondIter_get_end_atom__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolBondIter_get_end_atom'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_get_nbr_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetNbrAtom" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetNbrAtom" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (OpenBabel::OBAtom *)(*arg1)->GetNbrAtom(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_get_parent(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  OpenBabel::OBMol *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetParent" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (OpenBabel::OBMol *)(*arg1)->GetParent();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_get_equib_length(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetEquibLength" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (double)(*arg1)->GetEquibLength();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_get_length(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetLength" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (double)(*arg1)->GetLength();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_get_nbr_atom_idx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetNbrAtomIdx" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetNbrAtomIdx" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (unsigned int)(*arg1)->GetNbrAtomIdx(arg2);
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_is_aromatic(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsAromatic" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (bool)(*arg1)->IsAromatic();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_is_in_ring(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsInRing" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (bool)(*arg1)->IsInRing();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_is_rotor(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsRotor" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (bool)(*arg1)->IsRotor();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_is_amide(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsAmide" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (bool)(*arg1)->IsAmide();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_is_primary_amide(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsPrimaryAmide" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (bool)(*arg1)->IsPrimaryAmide();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_is_secondary_amide(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsSecondaryAmide" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (bool)(*arg1)->IsSecondaryAmide();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_is_ester(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsEster" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (bool)(*arg1)->IsEster();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_is_carbonyl(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsCarbonyl" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (bool)(*arg1)->IsCarbonyl();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_is_single(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsSingle" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (bool)(*arg1)->IsSingle();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_is_double(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsDouble" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (bool)(*arg1)->IsDouble();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_is_triple(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsTriple" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (bool)(*arg1)->IsTriple();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_is_ksingle(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsKSingle" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (bool)(*arg1)->IsKSingle();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_is_kdouble(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsKDouble" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (bool)(*arg1)->IsKDouble();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_is_ktriple(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsKTriple" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (bool)(*arg1)->IsKTriple();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_is_closure(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsClosure" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (bool)(*arg1)->IsClosure();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_is_up(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsUp" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (bool)(*arg1)->IsUp();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_is_down(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsDown" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (bool)(*arg1)->IsDown();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_is_wedge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsWedge" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (bool)(*arg1)->IsWedge();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_is_hash(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsHash" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (bool)(*arg1)->IsHash();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_is_double_bond_geometry(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsDoubleBondGeometry" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (bool)(*arg1)->IsDoubleBondGeometry();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_clear(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Clear" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (bool)(*arg1)->Clear();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_do_transformations(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  std::map<std::string,std::string > *arg2 = (std::map<std::string,std::string > *) 0 ;
  OpenBabel::OBBase *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DoTransformations" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_std__mapTstd__string_std__string_t, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DoTransformations" "', argument " "2"" of type '" "std::map<std::string,std::string > const *""'"); 
  }
  arg2 = reinterpret_cast< std::map<std::string,std::string > * >(argp2);
  result = (OpenBabel::OBBase *)(*arg1)->DoTransformations((std::map<std::string,std::string > const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_class_description(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  char *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ClassDescription" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (char *)(*arg1)->ClassDescription();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_has_data__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  std::string *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasData" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "HasData" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "HasData" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (bool)(*arg1)->HasData((std::string const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_has_data__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  char *arg2 = (char *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasData" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "HasData" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (bool)(*arg1)->HasData((char const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_has_data__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  unsigned int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasData" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "HasData" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (bool)(*arg1)->HasData(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolBondIter_has_data(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolBondIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBMolBondIter_has_data__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolBondIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMolBondIter_has_data__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolBondIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMolBondIter_has_data__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolBondIter_has_data'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_delete_data__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteData" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DeleteData" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  (*arg1)->DeleteData(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_delete_data__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  OpenBabel::OBGenericData *arg2 = (OpenBabel::OBGenericData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteData" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DeleteData" "', argument " "2"" of type '" "OpenBabel::OBGenericData *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBGenericData * >(argp2);
  (*arg1)->DeleteData(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_delete_data__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  std::vector<OpenBabel::OBGenericData * > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteData" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DeleteData" "', argument " "2"" of type '" "std::vector<OpenBabel::OBGenericData * > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DeleteData" "', argument " "2"" of type '" "std::vector<OpenBabel::OBGenericData * > &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<OpenBabel::OBGenericData * > * >(argp2);
  (*arg1)->DeleteData(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolBondIter_delete_data(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolBondIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBGenericData, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMolBondIter_delete_data__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolBondIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMolBondIter_delete_data__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolBondIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBMolBondIter_delete_data__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolBondIter_delete_data'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_set_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  OpenBabel::OBGenericData *arg2 = (OpenBabel::OBGenericData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetData" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetData" "', argument " "2"" of type '" "OpenBabel::OBGenericData *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBGenericData * >(argp2);
  (*arg1)->SetData(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_data_size(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataSize" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (unsigned int)(*arg1)->DataSize();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_get_data__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  unsigned int arg2 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetData" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (OpenBabel::OBGenericData *)(*arg1)->GetData(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_get_data__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  std::string *arg2 = 0 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetData" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GetData" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (OpenBabel::OBGenericData *)(*arg1)->GetData((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_get_data__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  char *arg2 = (char *) 0 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetData" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (OpenBabel::OBGenericData *)(*arg1)->GetData((char const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_get_data__SWIG_3(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  std::vector<OpenBabel::OBGenericData * > *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  {
    std::vector<OpenBabel::OBGenericData * > &_result_ref = (*arg1)->GetData();
    result = (std::vector<OpenBabel::OBGenericData * > *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_get_data__SWIG_4(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  OpenBabel::DataOrigin arg2 ;
  std::vector<OpenBabel::OBGenericData * > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetData" "', argument " "2"" of type '" "OpenBabel::DataOrigin""'");
  } 
  arg2 = static_cast< OpenBabel::DataOrigin >(val2);
  result = (*arg1)->GetData(arg2);
  {
    vresult = rb_ary_new2((&result)->size());
    for (unsigned int i=0; i<(&result)->size(); i++) {
      OpenBabel::OBGenericData* x = ((std::vector<OpenBabel::OBGenericData * > &)result)[i];
      rb_ary_store(vresult,i,
        SWIG_NewPointerObj((void *) x, 
          SWIGTYPE_p_OpenBabel__OBGenericData, 0));
    }
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolBondIter_get_data(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolBondIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBMolBondIter_get_data__SWIG_3(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolBondIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBMolBondIter_get_data__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolBondIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBMolBondIter_get_data__SWIG_4(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolBondIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMolBondIter_get_data__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolBondIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMolBondIter_get_data__SWIG_2(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolBondIter_get_data'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_begin_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBGenericData * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginData" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (*arg1)->BeginData();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBDataIterator(static_cast< const OpenBabel::OBDataIterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolBondIter_end_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBGenericData * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EndData" "', argument " "1"" of type '" "OpenBabel::OBMolBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (*arg1)->EndData();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBDataIterator(static_cast< const OpenBabel::OBDataIterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


swig_class cOBAtomAtomIter;

SWIGINTERN VALUE
_wrap_new_OBAtomAtomIter__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBAtomAtomIter *)new OpenBabel::OBAtomAtomIter();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_OBAtomAtomIter__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtomAtomIter *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBAtomAtomIter" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (OpenBabel::OBAtomAtomIter *)new OpenBabel::OBAtomAtomIter(arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBAtomAtomIter_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBAtomAtomIter_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBAtomAtomIter);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBAtomAtomIter__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = 0 ;
  OpenBabel::OBAtomAtomIter *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBAtomAtomIter,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBAtomAtomIter" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBAtomAtomIter" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter const &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (OpenBabel::OBAtomAtomIter *)new OpenBabel::OBAtomAtomIter((OpenBabel::OBAtomAtomIter const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_OBAtomAtomIter(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_OBAtomAtomIter__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBAtomAtomIter__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBAtomAtomIter__SWIG_2(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_OBAtomAtomIter'");
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBAtomAtomIter(OpenBabel::OBAtomAtomIter *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_OBAtomAtomIter_good(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator bool" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (bool)((OpenBabel::OBAtomAtomIter const *)arg1)->operator bool();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_inc__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  OpenBabel::OBAtomAtomIter *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator ++" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  {
    OpenBabel::OBAtomAtomIter &_result_ref = (arg1)->operator ++();
    result = (OpenBabel::OBAtomAtomIter *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_inc__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  int arg2 ;
  OpenBabel::OBAtomAtomIter result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator ++" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "operator ++" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (arg1)->operator ++(arg2);
  vresult = SWIG_NewPointerObj((new OpenBabel::OBAtomAtomIter(static_cast< const OpenBabel::OBAtomAtomIter& >(result))), SWIGTYPE_p_OpenBabel__OBAtomAtomIter, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBAtomAtomIter_inc(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBAtomAtomIter_inc__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBAtomAtomIter_inc__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBAtomAtomIter_inc'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_deref(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator ->" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (OpenBabel::OBAtom *)((OpenBabel::OBAtomAtomIter const *)arg1)->operator ->();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter___ref__(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator *" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  {
    OpenBabel::OBAtom &_result_ref = ((OpenBabel::OBAtomAtomIter const *)arg1)->operator *();
    result = (OpenBabel::OBAtom *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_Visit_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Visit" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Visit" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  if (arg1) (*arg1)->Visit = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_Visit_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Visit" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (bool) ((*arg1)->Visit);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_clear(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Clear" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (bool)(*arg1)->Clear();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_set_idx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetIdx" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetIdx" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (*arg1)->SetIdx(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_set_hyb(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetHyb" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetHyb" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (*arg1)->SetHyb(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_set_atomic_num(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetAtomicNum" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetAtomicNum" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (*arg1)->SetAtomicNum(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_set_isotope(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetIsotope" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetIsotope" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  (*arg1)->SetIsotope(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_set_implicit_valence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetImplicitValence" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetImplicitValence" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (*arg1)->SetImplicitValence(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_increment_implicit_valence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IncrementImplicitValence" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  (*arg1)->IncrementImplicitValence();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_decrement_implicit_valence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DecrementImplicitValence" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  (*arg1)->DecrementImplicitValence();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_set_formal_charge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetFormalCharge" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetFormalCharge" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (*arg1)->SetFormalCharge(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_set_spin_multiplicity(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  short arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  short val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetSpinMultiplicity" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_short(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetSpinMultiplicity" "', argument " "2"" of type '" "short""'");
  } 
  arg2 = static_cast< short >(val2);
  (*arg1)->SetSpinMultiplicity(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_set_type__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetType" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetType" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  (*arg1)->SetType(arg2);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_set_type__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetType" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__string,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetType" "', argument " "2"" of type '" "std::string &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetType" "', argument " "2"" of type '" "std::string &""'"); 
  }
  arg2 = reinterpret_cast< std::string * >(argp2);
  (*arg1)->SetType(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBAtomAtomIter_set_type(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__string, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBAtomAtomIter_set_type__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBAtomAtomIter_set_type__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBAtomAtomIter_set_type'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_set_partial_charge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetPartialCharge" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetPartialCharge" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  (*arg1)->SetPartialCharge(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_set_vector__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetVector" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetVector" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetVector" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  (*arg1)->SetVector((OpenBabel::vector3 const &)*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_set_vector__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  double arg2 ;
  double arg3 ;
  double arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetVector" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetVector" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SetVector" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  ecode4 = SWIG_AsVal_double(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "SetVector" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = static_cast< double >(val4);
  (*arg1)->SetVector(arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_set_vector__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetVector" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  (*arg1)->SetVector();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBAtomAtomIter_set_vector(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBAtomAtomIter_set_vector__SWIG_2(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__vector3, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBAtomAtomIter_set_vector__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_double(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_OBAtomAtomIter_set_vector__SWIG_1(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBAtomAtomIter_set_vector'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_set_coord_ptr(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  double **arg2 = (double **) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetCoordPtr" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetCoordPtr" "', argument " "2"" of type '" "double **""'"); 
  }
  arg2 = reinterpret_cast< double ** >(argp2);
  (*arg1)->SetCoordPtr(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_set_residue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  OpenBabel::OBResidue *arg2 = (OpenBabel::OBResidue *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetResidue" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetResidue" "', argument " "2"" of type '" "OpenBabel::OBResidue *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBResidue * >(argp2);
  (*arg1)->SetResidue(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_set_parent(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  OpenBabel::OBMol *arg2 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetParent" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetParent" "', argument " "2"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2);
  (*arg1)->SetParent(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_set_aromatic(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetAromatic" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  (*arg1)->SetAromatic();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_unset_aromatic(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnsetAromatic" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  (*arg1)->UnsetAromatic();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_set_clockwise_stereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetClockwiseStereo" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  (*arg1)->SetClockwiseStereo();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_set_anti_clockwise_stereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetAntiClockwiseStereo" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  (*arg1)->SetAntiClockwiseStereo();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_set_positive_stereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetPositiveStereo" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  (*arg1)->SetPositiveStereo();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_set_negative_stereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetNegativeStereo" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  (*arg1)->SetNegativeStereo();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_unset_stereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnsetStereo" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  (*arg1)->UnsetStereo();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_set_in_ring(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetInRing" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  (*arg1)->SetInRing();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_set_chiral(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetChiral" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  (*arg1)->SetChiral();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_clear_coord_ptr(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ClearCoordPtr" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  (*arg1)->ClearCoordPtr();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_get_formal_charge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetFormalCharge" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (int)(*arg1)->GetFormalCharge();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_get_atomic_num(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAtomicNum" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->GetAtomicNum();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_get_isotope(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  unsigned short result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetIsotope" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (unsigned short)(*arg1)->GetIsotope();
  vresult = SWIG_From_unsigned_SS_short(static_cast< unsigned short >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_get_spin_multiplicity(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetSpinMultiplicity" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (int)(*arg1)->GetSpinMultiplicity();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_get_atomic_mass(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAtomicMass" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (double)(*arg1)->GetAtomicMass();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_get_exact_mass(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetExactMass" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (double)(*arg1)->GetExactMass();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_get_idx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetIdx" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->GetIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_get_coordinate_idx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetCoordinateIdx" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->GetCoordinateIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_get_cidx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetCIdx" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->GetCIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_get_valence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetValence" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->GetValence();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_get_hyb(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetHyb" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->GetHyb();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_get_implicit_valence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetImplicitValence" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->GetImplicitValence();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_get_hvy_valence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetHvyValence" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->GetHvyValence();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_get_hetero_valence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetHeteroValence" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->GetHeteroValence();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_get_type(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  char *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetType" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (char *)(*arg1)->GetType();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_get_x(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetX" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (double)(*arg1)->GetX();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_get_y(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetY" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (double)(*arg1)->GetY();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_get_z(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetZ" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (double)(*arg1)->GetZ();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_x(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "x" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (double)(*arg1)->x();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_y(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "y" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (double)(*arg1)->y();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_z(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "z" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (double)(*arg1)->z();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_get_coordinate(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  double *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetCoordinate" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (double *)(*arg1)->GetCoordinate();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_get_vector__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  OpenBabel::vector3 *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetVector" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  {
    OpenBabel::vector3 &_result_ref = (*arg1)->GetVector();
    result = (OpenBabel::vector3 *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_get_vector__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  OpenBabel::vector3 *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetVector" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  {
    OpenBabel::vector3 const &_result_ref = (*arg1)->GetVector();
    result = (OpenBabel::vector3 *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBAtomAtomIter_get_vector(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBAtomAtomIter_get_vector__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBAtomAtomIter_get_vector__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBAtomAtomIter_get_vector'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_get_partial_charge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetPartialCharge" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (double)(*arg1)->GetPartialCharge();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_get_residue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  OpenBabel::OBResidue *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetResidue" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (OpenBabel::OBResidue *)(*arg1)->GetResidue();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_get_parent(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  OpenBabel::OBMol *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetParent" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (OpenBabel::OBMol *)(*arg1)->GetParent();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_get_new_bond_vector(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  double arg3 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetNewBondVector" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetNewBondVector" "', argument " "2"" of type '" "OpenBabel::vector3 &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GetNewBondVector" "', argument " "2"" of type '" "OpenBabel::vector3 &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  ecode3 = SWIG_AsVal_double(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "GetNewBondVector" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  result = (bool)(*arg1)->GetNewBondVector(*arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_get_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBBond *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetBond" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetBond" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (OpenBabel::OBBond *)(*arg1)->GetBond(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_get_next_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetNextAtom" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (OpenBabel::OBAtom *)(*arg1)->GetNextAtom();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_begin_bonds(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBBond * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginBonds" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (*arg1)->BeginBonds();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBBondIterator(static_cast< const OpenBabel::OBBondIterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_end_bonds(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBBond * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EndBonds" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (*arg1)->EndBonds();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBBondIterator(static_cast< const OpenBabel::OBBondIterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_begin_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  OpenBabel::OBBondIterator *arg2 = 0 ;
  OpenBabel::OBBond *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginBond" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "BeginBond" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "BeginBond" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2);
  result = (OpenBabel::OBBond *)(*arg1)->BeginBond(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_next_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  OpenBabel::OBBondIterator *arg2 = 0 ;
  OpenBabel::OBBond *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NextBond" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "NextBond" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "NextBond" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2);
  result = (OpenBabel::OBBond *)(*arg1)->NextBond(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_begin_nbr_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  OpenBabel::OBBondIterator *arg2 = 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginNbrAtom" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "BeginNbrAtom" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "BeginNbrAtom" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2);
  result = (OpenBabel::OBAtom *)(*arg1)->BeginNbrAtom(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_next_nbr_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  OpenBabel::OBBondIterator *arg2 = 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NextNbrAtom" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "NextNbrAtom" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "NextNbrAtom" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2);
  result = (OpenBabel::OBAtom *)(*arg1)->NextNbrAtom(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_get_distance__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  int arg2 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetDistance" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetDistance" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (double)(*arg1)->GetDistance(arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_get_distance__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetDistance" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetDistance" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (double)(*arg1)->GetDistance(arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBAtomAtomIter_get_distance(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBAtomAtomIter_get_distance__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBAtomAtomIter_get_distance__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBAtomAtomIter_get_distance'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_get_angle__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  int arg2 ;
  int arg3 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAngle" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetAngle" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "GetAngle" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  result = (double)(*arg1)->GetAngle(arg2,arg3);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_get_angle__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg3 = (OpenBabel::OBAtom *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAngle" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetAngle" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "GetAngle" "', argument " "3"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBAtom * >(argp3);
  result = (double)(*arg1)->GetAngle(arg2,arg3);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBAtomAtomIter_get_angle(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_OBAtomAtomIter_get_angle__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_OBAtomAtomIter_get_angle__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBAtomAtomIter_get_angle'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_new_residue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NewResidue" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  (*arg1)->NewResidue();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_add_residue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  OpenBabel::OBResidue *arg2 = (OpenBabel::OBResidue *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AddResidue" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AddResidue" "', argument " "2"" of type '" "OpenBabel::OBResidue *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBResidue * >(argp2);
  (*arg1)->AddResidue(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_delete_residue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteResidue" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  (*arg1)->DeleteResidue();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_add_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  OpenBabel::OBBond *arg2 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AddBond" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AddBond" "', argument " "2"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBond * >(argp2);
  (*arg1)->AddBond(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_insert_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  OpenBabel::OBBondIterator *arg2 = 0 ;
  OpenBabel::OBBond *arg3 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InsertBond" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InsertBond" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InsertBond" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "InsertBond" "', argument " "3"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBBond * >(argp3);
  (*arg1)->InsertBond(*arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_delete_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  OpenBabel::OBBond *arg2 = (OpenBabel::OBBond *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteBond" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DeleteBond" "', argument " "2"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBond * >(argp2);
  result = (bool)(*arg1)->DeleteBond(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_clear_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ClearBond" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  (*arg1)->ClearBond();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_hto_methyl(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HtoMethyl" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (bool)(*arg1)->HtoMethyl();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_set_hyb_and_geom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetHybAndGeom" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetHybAndGeom" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (bool)(*arg1)->SetHybAndGeom(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_force_no_h(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ForceNoH" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  (*arg1)->ForceNoH();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_has_no_hforced(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasNoHForced" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (bool)(*arg1)->HasNoHForced();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_count_free_oxygens(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CountFreeOxygens" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->CountFreeOxygens();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_implicit_hydrogen_count(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ImplicitHydrogenCount" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->ImplicitHydrogenCount();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_explicit_hydrogen_count__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool arg2 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ExplicitHydrogenCount" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ExplicitHydrogenCount" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (unsigned int)(*arg1)->ExplicitHydrogenCount(arg2);
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_explicit_hydrogen_count__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ExplicitHydrogenCount" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->ExplicitHydrogenCount();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBAtomAtomIter_explicit_hydrogen_count(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBAtomAtomIter_explicit_hydrogen_count__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBAtomAtomIter_explicit_hydrogen_count__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBAtomAtomIter_explicit_hydrogen_count'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_member_of_ring_count(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MemberOfRingCount" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->MemberOfRingCount();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_member_of_ring_size(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MemberOfRingSize" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->MemberOfRingSize();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_count_ring_bonds(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CountRingBonds" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->CountRingBonds();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_smallest_bond_angle(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SmallestBondAngle" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (double)(*arg1)->SmallestBondAngle();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_average_bond_angle(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AverageBondAngle" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (double)(*arg1)->AverageBondAngle();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_bosum(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BOSum" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->BOSum();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_kbosum(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KBOSum" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->KBOSum();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_has_residue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasResidue" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (bool)(*arg1)->HasResidue();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_is_hydrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsHydrogen" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (bool)(*arg1)->IsHydrogen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_is_carbon(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsCarbon" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (bool)(*arg1)->IsCarbon();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_is_nitrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsNitrogen" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (bool)(*arg1)->IsNitrogen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_is_oxygen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsOxygen" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (bool)(*arg1)->IsOxygen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_is_sulfur(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsSulfur" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (bool)(*arg1)->IsSulfur();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_is_phosphorus(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsPhosphorus" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (bool)(*arg1)->IsPhosphorus();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_is_aromatic(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsAromatic" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (bool)(*arg1)->IsAromatic();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_is_in_ring(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsInRing" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (bool)(*arg1)->IsInRing();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_is_in_ring_size(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsInRingSize" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IsInRingSize" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (bool)(*arg1)->IsInRingSize(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_is_heteroatom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsHeteroatom" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (bool)(*arg1)->IsHeteroatom();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_is_not_cor_h(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsNotCorH" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (bool)(*arg1)->IsNotCorH();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_is_connected(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsConnected" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "IsConnected" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (bool)(*arg1)->IsConnected(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_is_one_three(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsOneThree" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "IsOneThree" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (bool)(*arg1)->IsOneThree(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_is_one_four(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsOneFour" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "IsOneFour" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (bool)(*arg1)->IsOneFour(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_is_carboxyl_oxygen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsCarboxylOxygen" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (bool)(*arg1)->IsCarboxylOxygen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_is_phosphate_oxygen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsPhosphateOxygen" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (bool)(*arg1)->IsPhosphateOxygen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_is_sulfate_oxygen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsSulfateOxygen" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (bool)(*arg1)->IsSulfateOxygen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_is_nitro_oxygen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsNitroOxygen" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (bool)(*arg1)->IsNitroOxygen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_is_amide_nitrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsAmideNitrogen" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (bool)(*arg1)->IsAmideNitrogen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_is_polar_hydrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsPolarHydrogen" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (bool)(*arg1)->IsPolarHydrogen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_is_non_polar_hydrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsNonPolarHydrogen" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (bool)(*arg1)->IsNonPolarHydrogen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_is_aromatic_noxide(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsAromaticNOxide" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (bool)(*arg1)->IsAromaticNOxide();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_is_chiral(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsChiral" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (bool)(*arg1)->IsChiral();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_is_axial(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsAxial" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (bool)(*arg1)->IsAxial();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_is_clockwise(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsClockwise" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (bool)(*arg1)->IsClockwise();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_is_anti_clockwise(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsAntiClockwise" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (bool)(*arg1)->IsAntiClockwise();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_is_positive_stereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsPositiveStereo" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (bool)(*arg1)->IsPositiveStereo();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_is_negative_stereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsNegativeStereo" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (bool)(*arg1)->IsNegativeStereo();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_has_chirality_specified(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasChiralitySpecified" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (bool)(*arg1)->HasChiralitySpecified();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_has_chiral_volume(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasChiralVolume" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (bool)(*arg1)->HasChiralVolume();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_is_hbond_acceptor(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsHbondAcceptor" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (bool)(*arg1)->IsHbondAcceptor();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_is_hbond_donor(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsHbondDonor" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (bool)(*arg1)->IsHbondDonor();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_is_hbond_donor_h(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsHbondDonorH" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (bool)(*arg1)->IsHbondDonorH();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_has_alpha_beta_unsat__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasAlphaBetaUnsat" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "HasAlphaBetaUnsat" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (bool)(*arg1)->HasAlphaBetaUnsat(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_has_alpha_beta_unsat__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasAlphaBetaUnsat" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (bool)(*arg1)->HasAlphaBetaUnsat();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBAtomAtomIter_has_alpha_beta_unsat(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBAtomAtomIter_has_alpha_beta_unsat__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBAtomAtomIter_has_alpha_beta_unsat__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBAtomAtomIter_has_alpha_beta_unsat'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_has_bond_of_order(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  unsigned int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasBondOfOrder" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "HasBondOfOrder" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (bool)(*arg1)->HasBondOfOrder(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_count_bonds_of_order(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  unsigned int arg2 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CountBondsOfOrder" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CountBondsOfOrder" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (int)(*arg1)->CountBondsOfOrder(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_has_non_single_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasNonSingleBond" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (bool)(*arg1)->HasNonSingleBond();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_has_single_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasSingleBond" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (bool)(*arg1)->HasSingleBond();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_has_double_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasDoubleBond" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (bool)(*arg1)->HasDoubleBond();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_has_aromatic_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasAromaticBond" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (bool)(*arg1)->HasAromaticBond();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_matches_smarts(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  char *arg2 = (char *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MatchesSMARTS" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MatchesSMARTS" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (bool)(*arg1)->MatchesSMARTS((char const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_do_transformations(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  std::map<std::string,std::string > *arg2 = (std::map<std::string,std::string > *) 0 ;
  OpenBabel::OBBase *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DoTransformations" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_std__mapTstd__string_std__string_t, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DoTransformations" "', argument " "2"" of type '" "std::map<std::string,std::string > const *""'"); 
  }
  arg2 = reinterpret_cast< std::map<std::string,std::string > * >(argp2);
  result = (OpenBabel::OBBase *)(*arg1)->DoTransformations((std::map<std::string,std::string > const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_class_description(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  char *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ClassDescription" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (char *)(*arg1)->ClassDescription();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_has_data__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  std::string *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasData" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "HasData" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "HasData" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (bool)(*arg1)->HasData((std::string const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_has_data__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  char *arg2 = (char *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasData" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "HasData" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (bool)(*arg1)->HasData((char const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_has_data__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  unsigned int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasData" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "HasData" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (bool)(*arg1)->HasData(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBAtomAtomIter_has_data(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBAtomAtomIter_has_data__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBAtomAtomIter_has_data__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBAtomAtomIter_has_data__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBAtomAtomIter_has_data'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_delete_data__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteData" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DeleteData" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  (*arg1)->DeleteData(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_delete_data__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  OpenBabel::OBGenericData *arg2 = (OpenBabel::OBGenericData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteData" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DeleteData" "', argument " "2"" of type '" "OpenBabel::OBGenericData *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBGenericData * >(argp2);
  (*arg1)->DeleteData(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_delete_data__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  std::vector<OpenBabel::OBGenericData * > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteData" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DeleteData" "', argument " "2"" of type '" "std::vector<OpenBabel::OBGenericData * > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DeleteData" "', argument " "2"" of type '" "std::vector<OpenBabel::OBGenericData * > &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<OpenBabel::OBGenericData * > * >(argp2);
  (*arg1)->DeleteData(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBAtomAtomIter_delete_data(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBGenericData, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBAtomAtomIter_delete_data__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBAtomAtomIter_delete_data__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBAtomAtomIter_delete_data__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBAtomAtomIter_delete_data'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_set_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  OpenBabel::OBGenericData *arg2 = (OpenBabel::OBGenericData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetData" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetData" "', argument " "2"" of type '" "OpenBabel::OBGenericData *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBGenericData * >(argp2);
  (*arg1)->SetData(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_data_size(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataSize" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->DataSize();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_get_data__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  unsigned int arg2 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetData" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (OpenBabel::OBGenericData *)(*arg1)->GetData(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_get_data__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  std::string *arg2 = 0 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetData" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GetData" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (OpenBabel::OBGenericData *)(*arg1)->GetData((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_get_data__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  char *arg2 = (char *) 0 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetData" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (OpenBabel::OBGenericData *)(*arg1)->GetData((char const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_get_data__SWIG_3(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  std::vector<OpenBabel::OBGenericData * > *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  {
    std::vector<OpenBabel::OBGenericData * > &_result_ref = (*arg1)->GetData();
    result = (std::vector<OpenBabel::OBGenericData * > *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_get_data__SWIG_4(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  OpenBabel::DataOrigin arg2 ;
  std::vector<OpenBabel::OBGenericData * > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetData" "', argument " "2"" of type '" "OpenBabel::DataOrigin""'");
  } 
  arg2 = static_cast< OpenBabel::DataOrigin >(val2);
  result = (*arg1)->GetData(arg2);
  {
    vresult = rb_ary_new2((&result)->size());
    for (unsigned int i=0; i<(&result)->size(); i++) {
      OpenBabel::OBGenericData* x = ((std::vector<OpenBabel::OBGenericData * > &)result)[i];
      rb_ary_store(vresult,i,
        SWIG_NewPointerObj((void *) x, 
          SWIGTYPE_p_OpenBabel__OBGenericData, 0));
    }
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBAtomAtomIter_get_data(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBAtomAtomIter_get_data__SWIG_3(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBAtomAtomIter_get_data__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBAtomAtomIter_get_data__SWIG_4(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBAtomAtomIter_get_data__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBAtomAtomIter_get_data__SWIG_2(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBAtomAtomIter_get_data'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_begin_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBGenericData * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginData" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (*arg1)->BeginData();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBDataIterator(static_cast< const OpenBabel::OBDataIterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomAtomIter_end_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBGenericData * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EndData" "', argument " "1"" of type '" "OpenBabel::OBAtomAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (*arg1)->EndData();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBDataIterator(static_cast< const OpenBabel::OBDataIterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


swig_class cOBAtomBondIter;

SWIGINTERN VALUE
_wrap_new_OBAtomBondIter__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBAtomBondIter *)new OpenBabel::OBAtomBondIter();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_OBAtomBondIter__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtomBondIter *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBAtomBondIter" "', argument " "1"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (OpenBabel::OBAtomBondIter *)new OpenBabel::OBAtomBondIter(arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBAtomBondIter_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBAtomBondIter_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBAtomBondIter);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBAtomBondIter__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = 0 ;
  OpenBabel::OBAtomBondIter *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBAtomBondIter,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBAtomBondIter" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBAtomBondIter" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter const &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (OpenBabel::OBAtomBondIter *)new OpenBabel::OBAtomBondIter((OpenBabel::OBAtomBondIter const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_OBAtomBondIter(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_OBAtomBondIter__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBAtomBondIter__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBAtomBondIter__SWIG_2(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_OBAtomBondIter'");
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBAtomBondIter(OpenBabel::OBAtomBondIter *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_OBAtomBondIter_good(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator bool" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (bool)((OpenBabel::OBAtomBondIter const *)arg1)->operator bool();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_inc__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  OpenBabel::OBAtomBondIter *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator ++" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  {
    OpenBabel::OBAtomBondIter &_result_ref = (arg1)->operator ++();
    result = (OpenBabel::OBAtomBondIter *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_inc__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  int arg2 ;
  OpenBabel::OBAtomBondIter result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator ++" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "operator ++" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (arg1)->operator ++(arg2);
  vresult = SWIG_NewPointerObj((new OpenBabel::OBAtomBondIter(static_cast< const OpenBabel::OBAtomBondIter& >(result))), SWIGTYPE_p_OpenBabel__OBAtomBondIter, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBAtomBondIter_inc(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBAtomBondIter_inc__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBAtomBondIter_inc__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBAtomBondIter_inc'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_deref(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  OpenBabel::OBBond *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator ->" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (OpenBabel::OBBond *)((OpenBabel::OBAtomBondIter const *)arg1)->operator ->();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter___ref__(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  OpenBabel::OBBond *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator *" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  {
    OpenBabel::OBBond &_result_ref = ((OpenBabel::OBAtomBondIter const *)arg1)->operator *();
    result = (OpenBabel::OBBond *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_Visit_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Visit" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Visit" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  if (arg1) (*arg1)->Visit = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_Visit_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Visit" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (bool) ((*arg1)->Visit);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_set_idx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetIdx" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetIdx" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (*arg1)->SetIdx(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_set_bo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetBO" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetBO" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (*arg1)->SetBO(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_set_bond_order(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetBondOrder" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetBondOrder" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (*arg1)->SetBondOrder(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_set_begin(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetBegin" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetBegin" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  (*arg1)->SetBegin(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_set_end(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetEnd" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetEnd" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  (*arg1)->SetEnd(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_set_parent(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  OpenBabel::OBMol *arg2 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetParent" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetParent" "', argument " "2"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2);
  (*arg1)->SetParent(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_set_length(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetLength" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetLength" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  ecode3 = SWIG_AsVal_double(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SetLength" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  (*arg1)->SetLength(arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  int arg2 ;
  OpenBabel::OBAtom *arg3 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg4 = (OpenBabel::OBAtom *) 0 ;
  int arg5 ;
  int arg6 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  
  if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Set" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Set" "', argument " "3"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBAtom * >(argp3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Set" "', argument " "4"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg4 = reinterpret_cast< OpenBabel::OBAtom * >(argp4);
  ecode5 = SWIG_AsVal_int(argv[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Set" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = static_cast< int >(val5);
  ecode6 = SWIG_AsVal_int(argv[4], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "Set" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = static_cast< int >(val6);
  (*arg1)->Set(arg2,arg3,arg4,arg5,arg6);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_set_ksingle(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetKSingle" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  (*arg1)->SetKSingle();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_set_kdouble(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetKDouble" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  (*arg1)->SetKDouble();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_set_ktriple(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetKTriple" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  (*arg1)->SetKTriple();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_set_aromatic(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetAromatic" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  (*arg1)->SetAromatic();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_set_hash(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetHash" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  (*arg1)->SetHash();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_set_wedge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetWedge" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  (*arg1)->SetWedge();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_set_up(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetUp" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  (*arg1)->SetUp();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_set_down(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetDown" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  (*arg1)->SetDown();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_set_in_ring(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetInRing" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  (*arg1)->SetInRing();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_set_closure(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetClosure" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  (*arg1)->SetClosure();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_unset_hash(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnsetHash" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  (*arg1)->UnsetHash();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_unset_wedge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnsetWedge" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  (*arg1)->UnsetWedge();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_unset_up(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnsetUp" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  (*arg1)->UnsetUp();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_unset_down(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnsetDown" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  (*arg1)->UnsetDown();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_unset_aromatic(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnsetAromatic" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  (*arg1)->UnsetAromatic();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_unset_kekule(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnsetKekule" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  (*arg1)->UnsetKekule();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_get_idx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetIdx" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (unsigned int)(*arg1)->GetIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_get_bo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetBO" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (unsigned int)(*arg1)->GetBO();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_get_bond_order(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetBondOrder" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (unsigned int)(*arg1)->GetBondOrder();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_get_flags(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetFlags" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (unsigned int)(*arg1)->GetFlags();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_get_begin_atom_idx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetBeginAtomIdx" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (unsigned int)(*arg1)->GetBeginAtomIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_get_end_atom_idx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetEndAtomIdx" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (unsigned int)(*arg1)->GetEndAtomIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_get_begin_atom__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetBeginAtom" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (OpenBabel::OBAtom *)(*arg1)->GetBeginAtom();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_get_begin_atom__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetBeginAtom" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (OpenBabel::OBAtom *)(*arg1)->GetBeginAtom();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBAtomBondIter_get_begin_atom(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBAtomBondIter_get_begin_atom__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBAtomBondIter_get_begin_atom__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBAtomBondIter_get_begin_atom'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_get_end_atom__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetEndAtom" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (OpenBabel::OBAtom *)(*arg1)->GetEndAtom();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_get_end_atom__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetEndAtom" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (OpenBabel::OBAtom *)(*arg1)->GetEndAtom();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBAtomBondIter_get_end_atom(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBAtomBondIter_get_end_atom__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBAtomBondIter_get_end_atom__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBAtomBondIter_get_end_atom'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_get_nbr_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetNbrAtom" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetNbrAtom" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (OpenBabel::OBAtom *)(*arg1)->GetNbrAtom(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_get_parent(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  OpenBabel::OBMol *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetParent" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (OpenBabel::OBMol *)(*arg1)->GetParent();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_get_equib_length(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetEquibLength" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (double)(*arg1)->GetEquibLength();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_get_length(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetLength" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (double)(*arg1)->GetLength();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_get_nbr_atom_idx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetNbrAtomIdx" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetNbrAtomIdx" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (unsigned int)(*arg1)->GetNbrAtomIdx(arg2);
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_is_aromatic(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsAromatic" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (bool)(*arg1)->IsAromatic();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_is_in_ring(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsInRing" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (bool)(*arg1)->IsInRing();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_is_rotor(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsRotor" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (bool)(*arg1)->IsRotor();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_is_amide(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsAmide" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (bool)(*arg1)->IsAmide();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_is_primary_amide(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsPrimaryAmide" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (bool)(*arg1)->IsPrimaryAmide();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_is_secondary_amide(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsSecondaryAmide" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (bool)(*arg1)->IsSecondaryAmide();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_is_ester(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsEster" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (bool)(*arg1)->IsEster();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_is_carbonyl(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsCarbonyl" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (bool)(*arg1)->IsCarbonyl();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_is_single(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsSingle" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (bool)(*arg1)->IsSingle();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_is_double(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsDouble" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (bool)(*arg1)->IsDouble();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_is_triple(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsTriple" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (bool)(*arg1)->IsTriple();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_is_ksingle(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsKSingle" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (bool)(*arg1)->IsKSingle();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_is_kdouble(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsKDouble" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (bool)(*arg1)->IsKDouble();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_is_ktriple(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsKTriple" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (bool)(*arg1)->IsKTriple();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_is_closure(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsClosure" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (bool)(*arg1)->IsClosure();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_is_up(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsUp" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (bool)(*arg1)->IsUp();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_is_down(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsDown" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (bool)(*arg1)->IsDown();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_is_wedge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsWedge" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (bool)(*arg1)->IsWedge();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_is_hash(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsHash" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (bool)(*arg1)->IsHash();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_is_double_bond_geometry(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsDoubleBondGeometry" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (bool)(*arg1)->IsDoubleBondGeometry();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_clear(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Clear" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (bool)(*arg1)->Clear();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_do_transformations(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  std::map<std::string,std::string > *arg2 = (std::map<std::string,std::string > *) 0 ;
  OpenBabel::OBBase *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DoTransformations" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_std__mapTstd__string_std__string_t, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DoTransformations" "', argument " "2"" of type '" "std::map<std::string,std::string > const *""'"); 
  }
  arg2 = reinterpret_cast< std::map<std::string,std::string > * >(argp2);
  result = (OpenBabel::OBBase *)(*arg1)->DoTransformations((std::map<std::string,std::string > const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_class_description(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  char *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ClassDescription" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (char *)(*arg1)->ClassDescription();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_has_data__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  std::string *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasData" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "HasData" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "HasData" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (bool)(*arg1)->HasData((std::string const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_has_data__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  char *arg2 = (char *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasData" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "HasData" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (bool)(*arg1)->HasData((char const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_has_data__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  unsigned int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasData" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "HasData" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (bool)(*arg1)->HasData(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBAtomBondIter_has_data(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBAtomBondIter_has_data__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBAtomBondIter_has_data__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBAtomBondIter_has_data__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBAtomBondIter_has_data'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_delete_data__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteData" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DeleteData" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  (*arg1)->DeleteData(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_delete_data__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  OpenBabel::OBGenericData *arg2 = (OpenBabel::OBGenericData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteData" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DeleteData" "', argument " "2"" of type '" "OpenBabel::OBGenericData *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBGenericData * >(argp2);
  (*arg1)->DeleteData(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_delete_data__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  std::vector<OpenBabel::OBGenericData * > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteData" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DeleteData" "', argument " "2"" of type '" "std::vector<OpenBabel::OBGenericData * > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DeleteData" "', argument " "2"" of type '" "std::vector<OpenBabel::OBGenericData * > &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<OpenBabel::OBGenericData * > * >(argp2);
  (*arg1)->DeleteData(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBAtomBondIter_delete_data(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBGenericData, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBAtomBondIter_delete_data__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBAtomBondIter_delete_data__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBAtomBondIter_delete_data__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBAtomBondIter_delete_data'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_set_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  OpenBabel::OBGenericData *arg2 = (OpenBabel::OBGenericData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetData" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetData" "', argument " "2"" of type '" "OpenBabel::OBGenericData *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBGenericData * >(argp2);
  (*arg1)->SetData(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_data_size(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataSize" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (unsigned int)(*arg1)->DataSize();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_get_data__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  unsigned int arg2 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetData" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (OpenBabel::OBGenericData *)(*arg1)->GetData(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_get_data__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  std::string *arg2 = 0 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetData" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GetData" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (OpenBabel::OBGenericData *)(*arg1)->GetData((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_get_data__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  char *arg2 = (char *) 0 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetData" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (OpenBabel::OBGenericData *)(*arg1)->GetData((char const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_get_data__SWIG_3(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  std::vector<OpenBabel::OBGenericData * > *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  {
    std::vector<OpenBabel::OBGenericData * > &_result_ref = (*arg1)->GetData();
    result = (std::vector<OpenBabel::OBGenericData * > *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_get_data__SWIG_4(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  OpenBabel::DataOrigin arg2 ;
  std::vector<OpenBabel::OBGenericData * > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetData" "', argument " "2"" of type '" "OpenBabel::DataOrigin""'");
  } 
  arg2 = static_cast< OpenBabel::DataOrigin >(val2);
  result = (*arg1)->GetData(arg2);
  {
    vresult = rb_ary_new2((&result)->size());
    for (unsigned int i=0; i<(&result)->size(); i++) {
      OpenBabel::OBGenericData* x = ((std::vector<OpenBabel::OBGenericData * > &)result)[i];
      rb_ary_store(vresult,i,
        SWIG_NewPointerObj((void *) x, 
          SWIGTYPE_p_OpenBabel__OBGenericData, 0));
    }
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBAtomBondIter_get_data(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBAtomBondIter_get_data__SWIG_3(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBAtomBondIter_get_data__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBAtomBondIter_get_data__SWIG_4(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBAtomBondIter_get_data__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBAtomBondIter_get_data__SWIG_2(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBAtomBondIter_get_data'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_begin_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBGenericData * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginData" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (*arg1)->BeginData();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBDataIterator(static_cast< const OpenBabel::OBDataIterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBAtomBondIter_end_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBGenericData * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EndData" "', argument " "1"" of type '" "OpenBabel::OBAtomBondIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (*arg1)->EndData();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBDataIterator(static_cast< const OpenBabel::OBDataIterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


swig_class cOBResidueIter;

SWIGINTERN VALUE
_wrap_new_OBResidueIter__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBResidueIter *)new OpenBabel::OBResidueIter();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_OBResidueIter__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBResidueIter *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBResidueIter" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (OpenBabel::OBResidueIter *)new OpenBabel::OBResidueIter(arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBResidueIter_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBResidueIter_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBResidueIter);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBResidueIter__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = 0 ;
  OpenBabel::OBResidueIter *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBResidueIter,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBResidueIter" "', argument " "1"" of type '" "OpenBabel::OBResidueIter const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBResidueIter" "', argument " "1"" of type '" "OpenBabel::OBResidueIter const &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  result = (OpenBabel::OBResidueIter *)new OpenBabel::OBResidueIter((OpenBabel::OBResidueIter const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_OBResidueIter(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_OBResidueIter__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBResidueIter__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBResidueIter__SWIG_2(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_OBResidueIter'");
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBResidueIter(OpenBabel::OBResidueIter *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_OBResidueIter_good(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator bool" "', argument " "1"" of type '" "OpenBabel::OBResidueIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  result = (bool)((OpenBabel::OBResidueIter const *)arg1)->operator bool();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_inc__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  OpenBabel::OBResidueIter *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator ++" "', argument " "1"" of type '" "OpenBabel::OBResidueIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  {
    OpenBabel::OBResidueIter &_result_ref = (arg1)->operator ++();
    result = (OpenBabel::OBResidueIter *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_inc__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  int arg2 ;
  OpenBabel::OBResidueIter result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator ++" "', argument " "1"" of type '" "OpenBabel::OBResidueIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "operator ++" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (arg1)->operator ++(arg2);
  vresult = SWIG_NewPointerObj((new OpenBabel::OBResidueIter(static_cast< const OpenBabel::OBResidueIter& >(result))), SWIGTYPE_p_OpenBabel__OBResidueIter, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBResidueIter_inc(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBResidueIter_inc__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBResidueIter_inc__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBResidueIter_inc'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_deref(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  OpenBabel::OBResidue *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator ->" "', argument " "1"" of type '" "OpenBabel::OBResidueIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  result = (OpenBabel::OBResidue *)((OpenBabel::OBResidueIter const *)arg1)->operator ->();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter___ref__(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  OpenBabel::OBResidue *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator *" "', argument " "1"" of type '" "OpenBabel::OBResidueIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  {
    OpenBabel::OBResidue &_result_ref = ((OpenBabel::OBResidueIter const *)arg1)->operator *();
    result = (OpenBabel::OBResidue *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_add_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AddAtom" "', argument " "1"" of type '" "OpenBabel::OBResidueIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AddAtom" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  (*arg1)->AddAtom(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_insert_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InsertAtom" "', argument " "1"" of type '" "OpenBabel::OBResidueIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InsertAtom" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  (*arg1)->InsertAtom(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_remove_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RemoveAtom" "', argument " "1"" of type '" "OpenBabel::OBResidueIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "RemoveAtom" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  (*arg1)->RemoveAtom(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_clear(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Clear" "', argument " "1"" of type '" "OpenBabel::OBResidueIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  result = (bool)(*arg1)->Clear();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_set_name(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetName" "', argument " "1"" of type '" "OpenBabel::OBResidueIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetName" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetName" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  (*arg1)->SetName((std::string const &)*arg2);
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_set_num(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetNum" "', argument " "1"" of type '" "OpenBabel::OBResidueIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetNum" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  (*arg1)->SetNum(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_set_chain(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  char arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetChain" "', argument " "1"" of type '" "OpenBabel::OBResidueIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  ecode2 = SWIG_AsVal_char(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetChain" "', argument " "2"" of type '" "char""'");
  } 
  arg2 = static_cast< char >(val2);
  (*arg1)->SetChain(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_set_chain_num(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetChainNum" "', argument " "1"" of type '" "OpenBabel::OBResidueIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetChainNum" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  (*arg1)->SetChainNum(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_set_idx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetIdx" "', argument " "1"" of type '" "OpenBabel::OBResidueIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetIdx" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  (*arg1)->SetIdx(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_set_atom_id(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int res3 = SWIG_OLDOBJ ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetAtomID" "', argument " "1"" of type '" "OpenBabel::OBResidueIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetAtomID" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  {
    std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SetAtomID" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetAtomID" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  (*arg1)->SetAtomID(arg2,(std::string const &)*arg3);
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
fail:
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_set_het_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  bool arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetHetAtom" "', argument " "1"" of type '" "OpenBabel::OBResidueIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetHetAtom" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  ecode3 = SWIG_AsVal_bool(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SetHetAtom" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  (*arg1)->SetHetAtom(arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_set_serial_num(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  unsigned int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetSerialNum" "', argument " "1"" of type '" "OpenBabel::OBResidueIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetSerialNum" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SetSerialNum" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  (*arg1)->SetSerialNum(arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_get_name(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetName" "', argument " "1"" of type '" "OpenBabel::OBResidueIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  result = (*arg1)->GetName();
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_get_num(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetNum" "', argument " "1"" of type '" "OpenBabel::OBResidueIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  result = (unsigned int)(*arg1)->GetNum();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_get_num_atoms(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetNumAtoms" "', argument " "1"" of type '" "OpenBabel::OBResidueIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  result = (unsigned int)(*arg1)->GetNumAtoms();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_get_chain(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  char result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetChain" "', argument " "1"" of type '" "OpenBabel::OBResidueIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  result = (char)(*arg1)->GetChain();
  vresult = SWIG_From_char(static_cast< char >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_get_chain_num(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetChainNum" "', argument " "1"" of type '" "OpenBabel::OBResidueIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  result = (unsigned int)(*arg1)->GetChainNum();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_get_idx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetIdx" "', argument " "1"" of type '" "OpenBabel::OBResidueIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  result = (unsigned int)(*arg1)->GetIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_get_res_key(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetResKey" "', argument " "1"" of type '" "OpenBabel::OBResidueIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  result = (unsigned int)(*arg1)->GetResKey();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_get_atoms(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBAtom * > > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAtoms" "', argument " "1"" of type '" "OpenBabel::OBResidueIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  result = (*arg1)->GetAtoms();
  vresult = SWIG_NewPointerObj((new std::vector<OpenBabel::OBAtom * >(static_cast< const std::vector<OpenBabel::OBAtom * >& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBAtom_p_t, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_get_bonds__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  bool arg2 ;
  SwigValueWrapper<std::vector<OpenBabel::OBBond * > > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetBonds" "', argument " "1"" of type '" "OpenBabel::OBResidueIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetBonds" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (*arg1)->GetBonds(arg2);
  vresult = SWIG_NewPointerObj((new std::vector<OpenBabel::OBBond * >(static_cast< const std::vector<OpenBabel::OBBond * >& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_get_bonds__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBBond * > > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetBonds" "', argument " "1"" of type '" "OpenBabel::OBResidueIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  result = (*arg1)->GetBonds();
  vresult = SWIG_NewPointerObj((new std::vector<OpenBabel::OBBond * >(static_cast< const std::vector<OpenBabel::OBBond * >& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBResidueIter_get_bonds(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBResidueIter_get_bonds__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBResidueIter_get_bonds__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBResidueIter_get_bonds'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_get_atom_id(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  std::string result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAtomID" "', argument " "1"" of type '" "OpenBabel::OBResidueIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetAtomID" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (*arg1)->GetAtomID(arg2);
  vresult = SWIG_From_std_string(static_cast< std::string >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_get_serial_num(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetSerialNum" "', argument " "1"" of type '" "OpenBabel::OBResidueIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetSerialNum" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (unsigned int)(*arg1)->GetSerialNum(arg2);
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_get_amino_acid_property(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAminoAcidProperty" "', argument " "1"" of type '" "OpenBabel::OBResidueIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetAminoAcidProperty" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (bool)(*arg1)->GetAminoAcidProperty(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_get_atom_property(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  int arg3 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAtomProperty" "', argument " "1"" of type '" "OpenBabel::OBResidueIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetAtomProperty" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "GetAtomProperty" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  result = (bool)(*arg1)->GetAtomProperty(arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_get_residue_property(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetResidueProperty" "', argument " "1"" of type '" "OpenBabel::OBResidueIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetResidueProperty" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (bool)(*arg1)->GetResidueProperty(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_is_het_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsHetAtom" "', argument " "1"" of type '" "OpenBabel::OBResidueIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "IsHetAtom" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (bool)(*arg1)->IsHetAtom(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_is_residue_type(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsResidueType" "', argument " "1"" of type '" "OpenBabel::OBResidueIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IsResidueType" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (bool)(*arg1)->IsResidueType(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_begin_atoms(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBAtom * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginAtoms" "', argument " "1"" of type '" "OpenBabel::OBResidueIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  result = (*arg1)->BeginAtoms();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBAtomIterator(static_cast< const OpenBabel::OBAtomIterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBAtom_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_end_atoms(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBAtom * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EndAtoms" "', argument " "1"" of type '" "OpenBabel::OBResidueIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  result = (*arg1)->EndAtoms();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBAtomIterator(static_cast< const OpenBabel::OBAtomIterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBAtom_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_begin_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  std::vector<OpenBabel::OBAtom * >::iterator *arg2 = 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginAtom" "', argument " "1"" of type '" "OpenBabel::OBResidueIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBAtom_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "BeginAtom" "', argument " "2"" of type '" "std::vector<OpenBabel::OBAtom * >::iterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "BeginAtom" "', argument " "2"" of type '" "std::vector<OpenBabel::OBAtom * >::iterator &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<OpenBabel::OBAtom * >::iterator * >(argp2);
  result = (OpenBabel::OBAtom *)(*arg1)->BeginAtom(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_next_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  std::vector<OpenBabel::OBAtom * >::iterator *arg2 = 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NextAtom" "', argument " "1"" of type '" "OpenBabel::OBResidueIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBAtom_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "NextAtom" "', argument " "2"" of type '" "std::vector<OpenBabel::OBAtom * >::iterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "NextAtom" "', argument " "2"" of type '" "std::vector<OpenBabel::OBAtom * >::iterator &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<OpenBabel::OBAtom * >::iterator * >(argp2);
  result = (OpenBabel::OBAtom *)(*arg1)->NextAtom(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_do_transformations(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  std::map<std::string,std::string > *arg2 = (std::map<std::string,std::string > *) 0 ;
  OpenBabel::OBBase *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DoTransformations" "', argument " "1"" of type '" "OpenBabel::OBResidueIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_std__mapTstd__string_std__string_t, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DoTransformations" "', argument " "2"" of type '" "std::map<std::string,std::string > const *""'"); 
  }
  arg2 = reinterpret_cast< std::map<std::string,std::string > * >(argp2);
  result = (OpenBabel::OBBase *)(*arg1)->DoTransformations((std::map<std::string,std::string > const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_class_description(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  char *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ClassDescription" "', argument " "1"" of type '" "OpenBabel::OBResidueIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  result = (char *)(*arg1)->ClassDescription();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_has_data__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  std::string *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasData" "', argument " "1"" of type '" "OpenBabel::OBResidueIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "HasData" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "HasData" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (bool)(*arg1)->HasData((std::string const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_has_data__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  char *arg2 = (char *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasData" "', argument " "1"" of type '" "OpenBabel::OBResidueIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "HasData" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (bool)(*arg1)->HasData((char const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_has_data__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  unsigned int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasData" "', argument " "1"" of type '" "OpenBabel::OBResidueIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "HasData" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (bool)(*arg1)->HasData(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBResidueIter_has_data(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBResidueIter_has_data__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBResidueIter_has_data__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBResidueIter_has_data__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBResidueIter_has_data'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_delete_data__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteData" "', argument " "1"" of type '" "OpenBabel::OBResidueIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DeleteData" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  (*arg1)->DeleteData(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_delete_data__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  OpenBabel::OBGenericData *arg2 = (OpenBabel::OBGenericData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteData" "', argument " "1"" of type '" "OpenBabel::OBResidueIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DeleteData" "', argument " "2"" of type '" "OpenBabel::OBGenericData *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBGenericData * >(argp2);
  (*arg1)->DeleteData(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_delete_data__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  std::vector<OpenBabel::OBGenericData * > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteData" "', argument " "1"" of type '" "OpenBabel::OBResidueIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DeleteData" "', argument " "2"" of type '" "std::vector<OpenBabel::OBGenericData * > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DeleteData" "', argument " "2"" of type '" "std::vector<OpenBabel::OBGenericData * > &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<OpenBabel::OBGenericData * > * >(argp2);
  (*arg1)->DeleteData(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBResidueIter_delete_data(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBGenericData, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBResidueIter_delete_data__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBResidueIter_delete_data__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBResidueIter_delete_data__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBResidueIter_delete_data'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_set_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  OpenBabel::OBGenericData *arg2 = (OpenBabel::OBGenericData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetData" "', argument " "1"" of type '" "OpenBabel::OBResidueIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetData" "', argument " "2"" of type '" "OpenBabel::OBGenericData *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBGenericData * >(argp2);
  (*arg1)->SetData(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_data_size(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataSize" "', argument " "1"" of type '" "OpenBabel::OBResidueIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  result = (unsigned int)(*arg1)->DataSize();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_get_data__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  unsigned int arg2 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBResidueIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetData" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (OpenBabel::OBGenericData *)(*arg1)->GetData(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_get_data__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  std::string *arg2 = 0 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBResidueIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetData" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GetData" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (OpenBabel::OBGenericData *)(*arg1)->GetData((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_get_data__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  char *arg2 = (char *) 0 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBResidueIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetData" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (OpenBabel::OBGenericData *)(*arg1)->GetData((char const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_get_data__SWIG_3(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  std::vector<OpenBabel::OBGenericData * > *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBResidueIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  {
    std::vector<OpenBabel::OBGenericData * > &_result_ref = (*arg1)->GetData();
    result = (std::vector<OpenBabel::OBGenericData * > *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_get_data__SWIG_4(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  OpenBabel::DataOrigin arg2 ;
  std::vector<OpenBabel::OBGenericData * > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBResidueIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetData" "', argument " "2"" of type '" "OpenBabel::DataOrigin""'");
  } 
  arg2 = static_cast< OpenBabel::DataOrigin >(val2);
  result = (*arg1)->GetData(arg2);
  {
    vresult = rb_ary_new2((&result)->size());
    for (unsigned int i=0; i<(&result)->size(); i++) {
      OpenBabel::OBGenericData* x = ((std::vector<OpenBabel::OBGenericData * > &)result)[i];
      rb_ary_store(vresult,i,
        SWIG_NewPointerObj((void *) x, 
          SWIGTYPE_p_OpenBabel__OBGenericData, 0));
    }
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBResidueIter_get_data(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBResidueIter_get_data__SWIG_3(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBResidueIter_get_data__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBResidueIter_get_data__SWIG_4(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBResidueIter_get_data__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBResidueIter_get_data__SWIG_2(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBResidueIter_get_data'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_begin_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBGenericData * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginData" "', argument " "1"" of type '" "OpenBabel::OBResidueIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  result = (*arg1)->BeginData();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBDataIterator(static_cast< const OpenBabel::OBDataIterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueIter_end_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBGenericData * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EndData" "', argument " "1"" of type '" "OpenBabel::OBResidueIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  result = (*arg1)->EndData();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBDataIterator(static_cast< const OpenBabel::OBDataIterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


swig_class cOBResidueAtomIter;

SWIGINTERN VALUE
_wrap_new_OBResidueAtomIter__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBResidueAtomIter *)new OpenBabel::OBResidueAtomIter();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_OBResidueAtomIter__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ;
  OpenBabel::OBResidueAtomIter *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBResidueAtomIter" "', argument " "1"" of type '" "OpenBabel::OBResidue *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  result = (OpenBabel::OBResidueAtomIter *)new OpenBabel::OBResidueAtomIter(arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBResidueAtomIter_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBResidueAtomIter_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBResidueAtomIter);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBResidueAtomIter__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = 0 ;
  OpenBabel::OBResidueAtomIter *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBResidueAtomIter,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBResidueAtomIter" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBResidueAtomIter" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter const &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (OpenBabel::OBResidueAtomIter *)new OpenBabel::OBResidueAtomIter((OpenBabel::OBResidueAtomIter const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_OBResidueAtomIter(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_OBResidueAtomIter__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidue, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBResidueAtomIter__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBResidueAtomIter__SWIG_2(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_OBResidueAtomIter'");
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBResidueAtomIter(OpenBabel::OBResidueAtomIter *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_OBResidueAtomIter_good(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator bool" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (bool)((OpenBabel::OBResidueAtomIter const *)arg1)->operator bool();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_inc__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  OpenBabel::OBResidueAtomIter *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator ++" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  {
    OpenBabel::OBResidueAtomIter &_result_ref = (arg1)->operator ++();
    result = (OpenBabel::OBResidueAtomIter *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_inc__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  int arg2 ;
  OpenBabel::OBResidueAtomIter result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator ++" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "operator ++" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (arg1)->operator ++(arg2);
  vresult = SWIG_NewPointerObj((new OpenBabel::OBResidueAtomIter(static_cast< const OpenBabel::OBResidueAtomIter& >(result))), SWIGTYPE_p_OpenBabel__OBResidueAtomIter, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBResidueAtomIter_inc(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBResidueAtomIter_inc__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBResidueAtomIter_inc__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBResidueAtomIter_inc'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_deref(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator ->" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (OpenBabel::OBAtom *)((OpenBabel::OBResidueAtomIter const *)arg1)->operator ->();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter___ref__(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator *" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  {
    OpenBabel::OBAtom &_result_ref = ((OpenBabel::OBResidueAtomIter const *)arg1)->operator *();
    result = (OpenBabel::OBAtom *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_Visit_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Visit" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Visit" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  if (arg1) (*arg1)->Visit = arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_Visit_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Visit" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (bool) ((*arg1)->Visit);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_clear(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Clear" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (bool)(*arg1)->Clear();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_set_idx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetIdx" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetIdx" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (*arg1)->SetIdx(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_set_hyb(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetHyb" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetHyb" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (*arg1)->SetHyb(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_set_atomic_num(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetAtomicNum" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetAtomicNum" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (*arg1)->SetAtomicNum(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_set_isotope(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetIsotope" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetIsotope" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  (*arg1)->SetIsotope(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_set_implicit_valence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetImplicitValence" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetImplicitValence" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (*arg1)->SetImplicitValence(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_increment_implicit_valence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IncrementImplicitValence" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  (*arg1)->IncrementImplicitValence();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_decrement_implicit_valence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DecrementImplicitValence" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  (*arg1)->DecrementImplicitValence();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_set_formal_charge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetFormalCharge" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetFormalCharge" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  (*arg1)->SetFormalCharge(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_set_spin_multiplicity(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  short arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  short val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetSpinMultiplicity" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_short(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetSpinMultiplicity" "', argument " "2"" of type '" "short""'");
  } 
  arg2 = static_cast< short >(val2);
  (*arg1)->SetSpinMultiplicity(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_set_type__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetType" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetType" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  (*arg1)->SetType(arg2);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_set_type__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetType" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__string,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetType" "', argument " "2"" of type '" "std::string &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetType" "', argument " "2"" of type '" "std::string &""'"); 
  }
  arg2 = reinterpret_cast< std::string * >(argp2);
  (*arg1)->SetType(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBResidueAtomIter_set_type(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__string, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBResidueAtomIter_set_type__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBResidueAtomIter_set_type__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBResidueAtomIter_set_type'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_set_partial_charge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetPartialCharge" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetPartialCharge" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  (*arg1)->SetPartialCharge(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_set_vector__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetVector" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetVector" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SetVector" "', argument " "2"" of type '" "OpenBabel::vector3 const &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  (*arg1)->SetVector((OpenBabel::vector3 const &)*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_set_vector__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  double arg2 ;
  double arg3 ;
  double arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetVector" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetVector" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SetVector" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  ecode4 = SWIG_AsVal_double(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "SetVector" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = static_cast< double >(val4);
  (*arg1)->SetVector(arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_set_vector__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetVector" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  (*arg1)->SetVector();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBResidueAtomIter_set_vector(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBResidueAtomIter_set_vector__SWIG_2(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__vector3, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBResidueAtomIter_set_vector__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_double(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_OBResidueAtomIter_set_vector__SWIG_1(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBResidueAtomIter_set_vector'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_set_coord_ptr(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  double **arg2 = (double **) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetCoordPtr" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetCoordPtr" "', argument " "2"" of type '" "double **""'"); 
  }
  arg2 = reinterpret_cast< double ** >(argp2);
  (*arg1)->SetCoordPtr(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_set_residue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  OpenBabel::OBResidue *arg2 = (OpenBabel::OBResidue *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetResidue" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetResidue" "', argument " "2"" of type '" "OpenBabel::OBResidue *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBResidue * >(argp2);
  (*arg1)->SetResidue(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_set_parent(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  OpenBabel::OBMol *arg2 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetParent" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetParent" "', argument " "2"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2);
  (*arg1)->SetParent(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_set_aromatic(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetAromatic" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  (*arg1)->SetAromatic();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_unset_aromatic(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnsetAromatic" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  (*arg1)->UnsetAromatic();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_set_clockwise_stereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetClockwiseStereo" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  (*arg1)->SetClockwiseStereo();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_set_anti_clockwise_stereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetAntiClockwiseStereo" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  (*arg1)->SetAntiClockwiseStereo();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_set_positive_stereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetPositiveStereo" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  (*arg1)->SetPositiveStereo();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_set_negative_stereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetNegativeStereo" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  (*arg1)->SetNegativeStereo();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_unset_stereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnsetStereo" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  (*arg1)->UnsetStereo();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_set_in_ring(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetInRing" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  (*arg1)->SetInRing();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_set_chiral(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetChiral" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  (*arg1)->SetChiral();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_clear_coord_ptr(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ClearCoordPtr" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  (*arg1)->ClearCoordPtr();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_get_formal_charge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetFormalCharge" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (int)(*arg1)->GetFormalCharge();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_get_atomic_num(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAtomicNum" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->GetAtomicNum();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_get_isotope(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  unsigned short result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetIsotope" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (unsigned short)(*arg1)->GetIsotope();
  vresult = SWIG_From_unsigned_SS_short(static_cast< unsigned short >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_get_spin_multiplicity(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetSpinMultiplicity" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (int)(*arg1)->GetSpinMultiplicity();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_get_atomic_mass(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAtomicMass" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (double)(*arg1)->GetAtomicMass();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_get_exact_mass(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetExactMass" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (double)(*arg1)->GetExactMass();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_get_idx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetIdx" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->GetIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_get_coordinate_idx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetCoordinateIdx" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->GetCoordinateIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_get_cidx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetCIdx" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->GetCIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_get_valence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetValence" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->GetValence();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_get_hyb(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetHyb" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->GetHyb();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_get_implicit_valence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetImplicitValence" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->GetImplicitValence();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_get_hvy_valence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetHvyValence" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->GetHvyValence();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_get_hetero_valence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetHeteroValence" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->GetHeteroValence();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_get_type(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  char *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetType" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (char *)(*arg1)->GetType();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_get_x(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetX" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (double)(*arg1)->GetX();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_get_y(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetY" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (double)(*arg1)->GetY();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_get_z(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetZ" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (double)(*arg1)->GetZ();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_x(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "x" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (double)(*arg1)->x();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_y(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "y" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (double)(*arg1)->y();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_z(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "z" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (double)(*arg1)->z();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_get_coordinate(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  double *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetCoordinate" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (double *)(*arg1)->GetCoordinate();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_get_vector__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  OpenBabel::vector3 *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetVector" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  {
    OpenBabel::vector3 &_result_ref = (*arg1)->GetVector();
    result = (OpenBabel::vector3 *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_get_vector__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  OpenBabel::vector3 *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetVector" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  {
    OpenBabel::vector3 const &_result_ref = (*arg1)->GetVector();
    result = (OpenBabel::vector3 *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__vector3, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBResidueAtomIter_get_vector(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 2) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBResidueAtomIter_get_vector__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBResidueAtomIter_get_vector__SWIG_1(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBResidueAtomIter_get_vector'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_get_partial_charge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetPartialCharge" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (double)(*arg1)->GetPartialCharge();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_get_residue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  OpenBabel::OBResidue *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetResidue" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (OpenBabel::OBResidue *)(*arg1)->GetResidue();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_get_parent(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  OpenBabel::OBMol *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetParent" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (OpenBabel::OBMol *)(*arg1)->GetParent();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_get_new_bond_vector(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  double arg3 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetNewBondVector" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetNewBondVector" "', argument " "2"" of type '" "OpenBabel::vector3 &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GetNewBondVector" "', argument " "2"" of type '" "OpenBabel::vector3 &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  ecode3 = SWIG_AsVal_double(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "GetNewBondVector" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  result = (bool)(*arg1)->GetNewBondVector(*arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_get_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBBond *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetBond" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetBond" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (OpenBabel::OBBond *)(*arg1)->GetBond(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_get_next_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetNextAtom" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (OpenBabel::OBAtom *)(*arg1)->GetNextAtom();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_begin_bonds(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBBond * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginBonds" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (*arg1)->BeginBonds();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBBondIterator(static_cast< const OpenBabel::OBBondIterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_end_bonds(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBBond * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EndBonds" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (*arg1)->EndBonds();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBBondIterator(static_cast< const OpenBabel::OBBondIterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_begin_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  OpenBabel::OBBondIterator *arg2 = 0 ;
  OpenBabel::OBBond *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginBond" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "BeginBond" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "BeginBond" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2);
  result = (OpenBabel::OBBond *)(*arg1)->BeginBond(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_next_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  OpenBabel::OBBondIterator *arg2 = 0 ;
  OpenBabel::OBBond *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NextBond" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "NextBond" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "NextBond" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2);
  result = (OpenBabel::OBBond *)(*arg1)->NextBond(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_begin_nbr_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  OpenBabel::OBBondIterator *arg2 = 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginNbrAtom" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "BeginNbrAtom" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "BeginNbrAtom" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2);
  result = (OpenBabel::OBAtom *)(*arg1)->BeginNbrAtom(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_next_nbr_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  OpenBabel::OBBondIterator *arg2 = 0 ;
  OpenBabel::OBAtom *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NextNbrAtom" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "NextNbrAtom" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "NextNbrAtom" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2);
  result = (OpenBabel::OBAtom *)(*arg1)->NextNbrAtom(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_get_distance__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  int arg2 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetDistance" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetDistance" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (double)(*arg1)->GetDistance(arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_get_distance__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetDistance" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetDistance" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (double)(*arg1)->GetDistance(arg2);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBResidueAtomIter_get_distance(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBResidueAtomIter_get_distance__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBResidueAtomIter_get_distance__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBResidueAtomIter_get_distance'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_get_angle__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  int arg2 ;
  int arg3 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAngle" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetAngle" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "GetAngle" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  result = (double)(*arg1)->GetAngle(arg2,arg3);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_get_angle__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg3 = (OpenBabel::OBAtom *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetAngle" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetAngle" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "GetAngle" "', argument " "3"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBAtom * >(argp3);
  result = (double)(*arg1)->GetAngle(arg2,arg3);
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBResidueAtomIter_get_angle(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_OBResidueAtomIter_get_angle__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_OBResidueAtomIter_get_angle__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBResidueAtomIter_get_angle'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_new_residue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NewResidue" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  (*arg1)->NewResidue();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_add_residue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  OpenBabel::OBResidue *arg2 = (OpenBabel::OBResidue *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AddResidue" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AddResidue" "', argument " "2"" of type '" "OpenBabel::OBResidue *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBResidue * >(argp2);
  (*arg1)->AddResidue(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_delete_residue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteResidue" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  (*arg1)->DeleteResidue();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_add_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  OpenBabel::OBBond *arg2 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AddBond" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AddBond" "', argument " "2"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBond * >(argp2);
  (*arg1)->AddBond(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_insert_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  OpenBabel::OBBondIterator *arg2 = 0 ;
  OpenBabel::OBBond *arg3 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InsertBond" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBBond_p_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InsertBond" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InsertBond" "', argument " "2"" of type '" "OpenBabel::OBBondIterator &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "InsertBond" "', argument " "3"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::OBBond * >(argp3);
  (*arg1)->InsertBond(*arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_delete_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  OpenBabel::OBBond *arg2 = (OpenBabel::OBBond *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteBond" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DeleteBond" "', argument " "2"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBond * >(argp2);
  result = (bool)(*arg1)->DeleteBond(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_clear_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ClearBond" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  (*arg1)->ClearBond();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_hto_methyl(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HtoMethyl" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (bool)(*arg1)->HtoMethyl();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_set_hyb_and_geom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetHybAndGeom" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SetHybAndGeom" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (bool)(*arg1)->SetHybAndGeom(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_force_no_h(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ForceNoH" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  (*arg1)->ForceNoH();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_has_no_hforced(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasNoHForced" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (bool)(*arg1)->HasNoHForced();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_count_free_oxygens(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CountFreeOxygens" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->CountFreeOxygens();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_implicit_hydrogen_count(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ImplicitHydrogenCount" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->ImplicitHydrogenCount();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_explicit_hydrogen_count__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool arg2 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ExplicitHydrogenCount" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ExplicitHydrogenCount" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (unsigned int)(*arg1)->ExplicitHydrogenCount(arg2);
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_explicit_hydrogen_count__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ExplicitHydrogenCount" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->ExplicitHydrogenCount();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBResidueAtomIter_explicit_hydrogen_count(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBResidueAtomIter_explicit_hydrogen_count__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBResidueAtomIter_explicit_hydrogen_count__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBResidueAtomIter_explicit_hydrogen_count'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_member_of_ring_count(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MemberOfRingCount" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->MemberOfRingCount();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_member_of_ring_size(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MemberOfRingSize" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->MemberOfRingSize();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_count_ring_bonds(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CountRingBonds" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->CountRingBonds();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_smallest_bond_angle(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SmallestBondAngle" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (double)(*arg1)->SmallestBondAngle();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_average_bond_angle(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  double result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AverageBondAngle" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (double)(*arg1)->AverageBondAngle();
  vresult = SWIG_From_double(static_cast< double >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_bosum(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BOSum" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->BOSum();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_kbosum(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KBOSum" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->KBOSum();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_has_residue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasResidue" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (bool)(*arg1)->HasResidue();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_is_hydrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsHydrogen" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (bool)(*arg1)->IsHydrogen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_is_carbon(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsCarbon" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (bool)(*arg1)->IsCarbon();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_is_nitrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsNitrogen" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (bool)(*arg1)->IsNitrogen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_is_oxygen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsOxygen" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (bool)(*arg1)->IsOxygen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_is_sulfur(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsSulfur" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (bool)(*arg1)->IsSulfur();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_is_phosphorus(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsPhosphorus" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (bool)(*arg1)->IsPhosphorus();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_is_aromatic(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsAromatic" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (bool)(*arg1)->IsAromatic();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_is_in_ring(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsInRing" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (bool)(*arg1)->IsInRing();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_is_in_ring_size(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsInRingSize" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IsInRingSize" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (bool)(*arg1)->IsInRingSize(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_is_heteroatom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsHeteroatom" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (bool)(*arg1)->IsHeteroatom();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_is_not_cor_h(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsNotCorH" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (bool)(*arg1)->IsNotCorH();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_is_connected(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsConnected" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "IsConnected" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (bool)(*arg1)->IsConnected(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_is_one_three(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsOneThree" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "IsOneThree" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (bool)(*arg1)->IsOneThree(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_is_one_four(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsOneFour" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "IsOneFour" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (bool)(*arg1)->IsOneFour(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_is_carboxyl_oxygen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsCarboxylOxygen" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (bool)(*arg1)->IsCarboxylOxygen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_is_phosphate_oxygen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsPhosphateOxygen" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (bool)(*arg1)->IsPhosphateOxygen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_is_sulfate_oxygen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsSulfateOxygen" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (bool)(*arg1)->IsSulfateOxygen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_is_nitro_oxygen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsNitroOxygen" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (bool)(*arg1)->IsNitroOxygen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_is_amide_nitrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsAmideNitrogen" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (bool)(*arg1)->IsAmideNitrogen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_is_polar_hydrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsPolarHydrogen" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (bool)(*arg1)->IsPolarHydrogen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_is_non_polar_hydrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsNonPolarHydrogen" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (bool)(*arg1)->IsNonPolarHydrogen();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_is_aromatic_noxide(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsAromaticNOxide" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (bool)(*arg1)->IsAromaticNOxide();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_is_chiral(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsChiral" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (bool)(*arg1)->IsChiral();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_is_axial(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsAxial" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (bool)(*arg1)->IsAxial();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_is_clockwise(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsClockwise" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (bool)(*arg1)->IsClockwise();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_is_anti_clockwise(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsAntiClockwise" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (bool)(*arg1)->IsAntiClockwise();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_is_positive_stereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsPositiveStereo" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (bool)(*arg1)->IsPositiveStereo();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_is_negative_stereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsNegativeStereo" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (bool)(*arg1)->IsNegativeStereo();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_has_chirality_specified(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasChiralitySpecified" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (bool)(*arg1)->HasChiralitySpecified();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_has_chiral_volume(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasChiralVolume" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (bool)(*arg1)->HasChiralVolume();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_is_hbond_acceptor(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsHbondAcceptor" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (bool)(*arg1)->IsHbondAcceptor();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_is_hbond_donor(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsHbondDonor" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (bool)(*arg1)->IsHbondDonor();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_is_hbond_donor_h(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsHbondDonorH" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (bool)(*arg1)->IsHbondDonorH();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_has_alpha_beta_unsat__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasAlphaBetaUnsat" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "HasAlphaBetaUnsat" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (bool)(*arg1)->HasAlphaBetaUnsat(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_has_alpha_beta_unsat__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasAlphaBetaUnsat" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (bool)(*arg1)->HasAlphaBetaUnsat();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBResidueAtomIter_has_alpha_beta_unsat(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBResidueAtomIter_has_alpha_beta_unsat__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBResidueAtomIter_has_alpha_beta_unsat__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBResidueAtomIter_has_alpha_beta_unsat'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_has_bond_of_order(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  unsigned int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasBondOfOrder" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "HasBondOfOrder" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (bool)(*arg1)->HasBondOfOrder(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_count_bonds_of_order(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  unsigned int arg2 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CountBondsOfOrder" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CountBondsOfOrder" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (int)(*arg1)->CountBondsOfOrder(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_has_non_single_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasNonSingleBond" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (bool)(*arg1)->HasNonSingleBond();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_has_single_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasSingleBond" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (bool)(*arg1)->HasSingleBond();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_has_double_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasDoubleBond" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (bool)(*arg1)->HasDoubleBond();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_has_aromatic_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasAromaticBond" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (bool)(*arg1)->HasAromaticBond();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_matches_smarts(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  char *arg2 = (char *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MatchesSMARTS" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MatchesSMARTS" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (bool)(*arg1)->MatchesSMARTS((char const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_do_transformations(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  std::map<std::string,std::string > *arg2 = (std::map<std::string,std::string > *) 0 ;
  OpenBabel::OBBase *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DoTransformations" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_std__mapTstd__string_std__string_t, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DoTransformations" "', argument " "2"" of type '" "std::map<std::string,std::string > const *""'"); 
  }
  arg2 = reinterpret_cast< std::map<std::string,std::string > * >(argp2);
  result = (OpenBabel::OBBase *)(*arg1)->DoTransformations((std::map<std::string,std::string > const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_class_description(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  char *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ClassDescription" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (char *)(*arg1)->ClassDescription();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_has_data__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  std::string *arg2 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasData" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "HasData" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "HasData" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (bool)(*arg1)->HasData((std::string const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_has_data__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  char *arg2 = (char *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasData" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "HasData" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (bool)(*arg1)->HasData((char const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_has_data__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  unsigned int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "HasData" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "HasData" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (bool)(*arg1)->HasData(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBResidueAtomIter_has_data(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBResidueAtomIter_has_data__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBResidueAtomIter_has_data__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBResidueAtomIter_has_data__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBResidueAtomIter_has_data'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_delete_data__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteData" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DeleteData" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  (*arg1)->DeleteData(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_delete_data__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  OpenBabel::OBGenericData *arg2 = (OpenBabel::OBGenericData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteData" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DeleteData" "', argument " "2"" of type '" "OpenBabel::OBGenericData *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBGenericData * >(argp2);
  (*arg1)->DeleteData(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_delete_data__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  std::vector<OpenBabel::OBGenericData * > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeleteData" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DeleteData" "', argument " "2"" of type '" "std::vector<OpenBabel::OBGenericData * > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DeleteData" "', argument " "2"" of type '" "std::vector<OpenBabel::OBGenericData * > &""'"); 
  }
  arg2 = reinterpret_cast< std::vector<OpenBabel::OBGenericData * > * >(argp2);
  (*arg1)->DeleteData(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBResidueAtomIter_delete_data(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBGenericData, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBResidueAtomIter_delete_data__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBResidueAtomIter_delete_data__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBResidueAtomIter_delete_data__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBResidueAtomIter_delete_data'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_set_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  OpenBabel::OBGenericData *arg2 = (OpenBabel::OBGenericData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetData" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetData" "', argument " "2"" of type '" "OpenBabel::OBGenericData *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBGenericData * >(argp2);
  (*arg1)->SetData(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_data_size(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  unsigned int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DataSize" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (unsigned int)(*arg1)->DataSize();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_get_data__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  unsigned int arg2 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetData" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (OpenBabel::OBGenericData *)(*arg1)->GetData(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_get_data__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  std::string *arg2 = 0 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetData" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GetData" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (OpenBabel::OBGenericData *)(*arg1)->GetData((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_get_data__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  char *arg2 = (char *) 0 ;
  OpenBabel::OBGenericData *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GetData" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (OpenBabel::OBGenericData *)(*arg1)->GetData((char const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_get_data__SWIG_3(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  std::vector<OpenBabel::OBGenericData * > *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  {
    std::vector<OpenBabel::OBGenericData * > &_result_ref = (*arg1)->GetData();
    result = (std::vector<OpenBabel::OBGenericData * > *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_get_data__SWIG_4(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  OpenBabel::DataOrigin arg2 ;
  std::vector<OpenBabel::OBGenericData * > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetData" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GetData" "', argument " "2"" of type '" "OpenBabel::DataOrigin""'");
  } 
  arg2 = static_cast< OpenBabel::DataOrigin >(val2);
  result = (*arg1)->GetData(arg2);
  {
    vresult = rb_ary_new2((&result)->size());
    for (unsigned int i=0; i<(&result)->size(); i++) {
      OpenBabel::OBGenericData* x = ((std::vector<OpenBabel::OBGenericData * > &)result)[i];
      rb_ary_store(vresult,i,
        SWIG_NewPointerObj((void *) x, 
          SWIGTYPE_p_OpenBabel__OBGenericData, 0));
    }
  }
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBResidueAtomIter_get_data(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBResidueAtomIter_get_data__SWIG_3(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBResidueAtomIter_get_data__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBResidueAtomIter_get_data__SWIG_4(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBResidueAtomIter_get_data__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBResidueAtomIter_get_data__SWIG_2(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBResidueAtomIter_get_data'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_begin_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBGenericData * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BeginData" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (*arg1)->BeginData();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBDataIterator(static_cast< const OpenBabel::OBDataIterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBResidueAtomIter_end_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  SwigValueWrapper<std::vector<OpenBabel::OBGenericData * >::iterator > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EndData" "', argument " "1"" of type '" "OpenBabel::OBResidueAtomIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (*arg1)->EndData();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBDataIterator(static_cast< const OpenBabel::OBDataIterator& >(result))), SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


swig_class cOBMolAngleIter;

SWIGINTERN VALUE
_wrap_new_OBMolAngleIter__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAngleIter *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBMolAngleIter *)new OpenBabel::OBMolAngleIter();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_OBMolAngleIter__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBMolAngleIter *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBMolAngleIter" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (OpenBabel::OBMolAngleIter *)new OpenBabel::OBMolAngleIter(arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBMolAngleIter_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBMolAngleIter_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBMolAngleIter);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBMolAngleIter__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAngleIter *arg1 = 0 ;
  OpenBabel::OBMolAngleIter *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBMolAngleIter,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBMolAngleIter" "', argument " "1"" of type '" "OpenBabel::OBMolAngleIter const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBMolAngleIter" "', argument " "1"" of type '" "OpenBabel::OBMolAngleIter const &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAngleIter * >(argp1);
  result = (OpenBabel::OBMolAngleIter *)new OpenBabel::OBMolAngleIter((OpenBabel::OBMolAngleIter const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_OBMolAngleIter(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_OBMolAngleIter__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBMolAngleIter__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolAngleIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBMolAngleIter__SWIG_2(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_OBMolAngleIter'");
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBMolAngleIter(OpenBabel::OBMolAngleIter *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_OBMolAngleIter_good(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAngleIter *arg1 = (OpenBabel::OBMolAngleIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAngleIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator bool" "', argument " "1"" of type '" "OpenBabel::OBMolAngleIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAngleIter * >(argp1);
  result = (bool)((OpenBabel::OBMolAngleIter const *)arg1)->operator bool();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAngleIter_inc(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAngleIter *arg1 = (OpenBabel::OBMolAngleIter *) 0 ;
  OpenBabel::OBMolAngleIter *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAngleIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator ++" "', argument " "1"" of type '" "OpenBabel::OBMolAngleIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAngleIter * >(argp1);
  {
    OpenBabel::OBMolAngleIter &_result_ref = (arg1)->operator ++();
    result = (OpenBabel::OBMolAngleIter *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBMolAngleIter, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolAngleIter___ref__(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAngleIter *arg1 = (OpenBabel::OBMolAngleIter *) 0 ;
  std::vector<unsigned int > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAngleIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator *" "', argument " "1"" of type '" "OpenBabel::OBMolAngleIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolAngleIter * >(argp1);
  result = ((OpenBabel::OBMolAngleIter const *)arg1)->operator *();
  {
    vresult = rb_ary_new2((&result)->size());
    for (unsigned int i=0; i<(&result)->size(); i++)
    rb_ary_store(vresult,i,INT2NUM(((std::vector<unsigned int > &)result)[i]));
  }
  return vresult;
fail:
  return Qnil;
}


swig_class cOBMolTorsionIter;

SWIGINTERN VALUE
_wrap_new_OBMolTorsionIter__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolTorsionIter *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBMolTorsionIter *)new OpenBabel::OBMolTorsionIter();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_OBMolTorsionIter__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBMolTorsionIter *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBMolTorsionIter" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (OpenBabel::OBMolTorsionIter *)new OpenBabel::OBMolTorsionIter(arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBMolTorsionIter_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBMolTorsionIter_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBMolTorsionIter);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBMolTorsionIter__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolTorsionIter *arg1 = 0 ;
  OpenBabel::OBMolTorsionIter *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBMolTorsionIter,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBMolTorsionIter" "', argument " "1"" of type '" "OpenBabel::OBMolTorsionIter const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBMolTorsionIter" "', argument " "1"" of type '" "OpenBabel::OBMolTorsionIter const &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolTorsionIter * >(argp1);
  result = (OpenBabel::OBMolTorsionIter *)new OpenBabel::OBMolTorsionIter((OpenBabel::OBMolTorsionIter const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_OBMolTorsionIter(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_OBMolTorsionIter__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBMolTorsionIter__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolTorsionIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBMolTorsionIter__SWIG_2(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_OBMolTorsionIter'");
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBMolTorsionIter(OpenBabel::OBMolTorsionIter *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_OBMolTorsionIter_good(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolTorsionIter *arg1 = (OpenBabel::OBMolTorsionIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolTorsionIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator bool" "', argument " "1"" of type '" "OpenBabel::OBMolTorsionIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolTorsionIter * >(argp1);
  result = (bool)((OpenBabel::OBMolTorsionIter const *)arg1)->operator bool();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolTorsionIter_inc(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolTorsionIter *arg1 = (OpenBabel::OBMolTorsionIter *) 0 ;
  OpenBabel::OBMolTorsionIter *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolTorsionIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator ++" "', argument " "1"" of type '" "OpenBabel::OBMolTorsionIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolTorsionIter * >(argp1);
  {
    OpenBabel::OBMolTorsionIter &_result_ref = (arg1)->operator ++();
    result = (OpenBabel::OBMolTorsionIter *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBMolTorsionIter, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolTorsionIter___ref__(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolTorsionIter *arg1 = (OpenBabel::OBMolTorsionIter *) 0 ;
  std::vector<unsigned int > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolTorsionIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator *" "', argument " "1"" of type '" "OpenBabel::OBMolTorsionIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolTorsionIter * >(argp1);
  result = ((OpenBabel::OBMolTorsionIter const *)arg1)->operator *();
  {
    vresult = rb_ary_new2((&result)->size());
    for (unsigned int i=0; i<(&result)->size(); i++)
    rb_ary_store(vresult,i,INT2NUM(((std::vector<unsigned int > &)result)[i]));
  }
  return vresult;
fail:
  return Qnil;
}


swig_class cOBMolPairIter;

SWIGINTERN VALUE
_wrap_new_OBMolPairIter__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolPairIter *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBMolPairIter *)new OpenBabel::OBMolPairIter();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_OBMolPairIter__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBMolPairIter *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBMolPairIter" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (OpenBabel::OBMolPairIter *)new OpenBabel::OBMolPairIter(arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBMolPairIter_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBMolPairIter_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBMolPairIter);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBMolPairIter__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolPairIter *arg1 = 0 ;
  OpenBabel::OBMolPairIter *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBMolPairIter,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBMolPairIter" "', argument " "1"" of type '" "OpenBabel::OBMolPairIter const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBMolPairIter" "', argument " "1"" of type '" "OpenBabel::OBMolPairIter const &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolPairIter * >(argp1);
  result = (OpenBabel::OBMolPairIter *)new OpenBabel::OBMolPairIter((OpenBabel::OBMolPairIter const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_OBMolPairIter(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_OBMolPairIter__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBMolPairIter__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolPairIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBMolPairIter__SWIG_2(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_OBMolPairIter'");
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBMolPairIter(OpenBabel::OBMolPairIter *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_OBMolPairIter_good(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolPairIter *arg1 = (OpenBabel::OBMolPairIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolPairIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator bool" "', argument " "1"" of type '" "OpenBabel::OBMolPairIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolPairIter * >(argp1);
  result = (bool)((OpenBabel::OBMolPairIter const *)arg1)->operator bool();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolPairIter_inc(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolPairIter *arg1 = (OpenBabel::OBMolPairIter *) 0 ;
  OpenBabel::OBMolPairIter *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolPairIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator ++" "', argument " "1"" of type '" "OpenBabel::OBMolPairIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolPairIter * >(argp1);
  {
    OpenBabel::OBMolPairIter &_result_ref = (arg1)->operator ++();
    result = (OpenBabel::OBMolPairIter *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBMolPairIter, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolPairIter___ref__(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolPairIter *arg1 = (OpenBabel::OBMolPairIter *) 0 ;
  std::vector<unsigned int > result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolPairIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator *" "', argument " "1"" of type '" "OpenBabel::OBMolPairIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolPairIter * >(argp1);
  result = ((OpenBabel::OBMolPairIter const *)arg1)->operator *();
  {
    vresult = rb_ary_new2((&result)->size());
    for (unsigned int i=0; i<(&result)->size(); i++)
    rb_ary_store(vresult,i,INT2NUM(((std::vector<unsigned int > &)result)[i]));
  }
  return vresult;
fail:
  return Qnil;
}


swig_class cOBMolRingIter;

SWIGINTERN VALUE
_wrap_new_OBMolRingIter__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolRingIter *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (OpenBabel::OBMolRingIter *)new OpenBabel::OBMolRingIter();DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_OBMolRingIter__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBMolRingIter *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBMolRingIter" "', argument " "1"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (OpenBabel::OBMolRingIter *)new OpenBabel::OBMolRingIter(arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OBMolRingIter_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OBMolRingIter_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBMolRingIter);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OBMolRingIter__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolRingIter *arg1 = 0 ;
  OpenBabel::OBMolRingIter *result = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBMolRingIter,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OpenBabel::OBMolRingIter" "', argument " "1"" of type '" "OpenBabel::OBMolRingIter const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OpenBabel::OBMolRingIter" "', argument " "1"" of type '" "OpenBabel::OBMolRingIter const &""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolRingIter * >(argp1);
  result = (OpenBabel::OBMolRingIter *)new OpenBabel::OBMolRingIter((OpenBabel::OBMolRingIter const &)*arg1);DATA_PTR(self) = result;
  
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_OBMolRingIter(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ii++) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_OBMolRingIter__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBMolRingIter__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolRingIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OBMolRingIter__SWIG_2(nargs, args, self);
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'new_OBMolRingIter'");
  return Qnil;
}


SWIGINTERN void
free_OpenBabel_OBMolRingIter(OpenBabel::OBMolRingIter *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_OBMolRingIter_good(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolRingIter *arg1 = (OpenBabel::OBMolRingIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolRingIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator bool" "', argument " "1"" of type '" "OpenBabel::OBMolRingIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolRingIter * >(argp1);
  result = (bool)((OpenBabel::OBMolRingIter const *)arg1)->operator bool();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolRingIter_inc__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolRingIter *arg1 = (OpenBabel::OBMolRingIter *) 0 ;
  OpenBabel::OBMolRingIter *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolRingIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator ++" "', argument " "1"" of type '" "OpenBabel::OBMolRingIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolRingIter * >(argp1);
  {
    OpenBabel::OBMolRingIter &_result_ref = (arg1)->operator ++();
    result = (OpenBabel::OBMolRingIter *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBMolRingIter, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolRingIter_inc__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolRingIter *arg1 = (OpenBabel::OBMolRingIter *) 0 ;
  int arg2 ;
  OpenBabel::OBMolRingIter result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolRingIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator ++" "', argument " "1"" of type '" "OpenBabel::OBMolRingIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolRingIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "operator ++" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (arg1)->operator ++(arg2);
  vresult = SWIG_NewPointerObj((new OpenBabel::OBMolRingIter(static_cast< const OpenBabel::OBMolRingIter& >(result))), SWIGTYPE_p_OpenBabel__OBMolRingIter, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolRingIter_inc(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolRingIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OBMolRingIter_inc__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolRingIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OBMolRingIter_inc__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolRingIter_inc'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolRingIter_deref(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolRingIter *arg1 = (OpenBabel::OBMolRingIter *) 0 ;
  OpenBabel::OBRing *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolRingIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator ->" "', argument " "1"" of type '" "OpenBabel::OBMolRingIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolRingIter * >(argp1);
  result = (OpenBabel::OBRing *)((OpenBabel::OBMolRingIter const *)arg1)->operator ->();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBRing, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolRingIter___ref__(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolRingIter *arg1 = (OpenBabel::OBMolRingIter *) 0 ;
  OpenBabel::OBRing *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolRingIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "operator *" "', argument " "1"" of type '" "OpenBabel::OBMolRingIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolRingIter * >(argp1);
  {
    OpenBabel::OBRing &_result_ref = ((OpenBabel::OBMolRingIter const *)arg1)->operator *();
    result = (OpenBabel::OBRing *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBRing, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolRingIter__path_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolRingIter *arg1 = (OpenBabel::OBMolRingIter *) 0 ;
  std::vector<int > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector<int > temp2 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolRingIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_path" "', argument " "1"" of type '" "OpenBabel::OBMolRingIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolRingIter * >(argp1);
  {
    if (rb_obj_is_kind_of(argv[0],rb_cArray)) {
      unsigned int size = RARRAY_LEN(argv[0]);
      temp2 = std::vector<int >(size);
      arg2 = &temp2;
      for (unsigned int i=0; i<size; i++) {
        VALUE o = RARRAY_PTR(argv[0])[i];
        if (FIXNUM_P(o))
        temp2[i] = (int)(FIX2INT(o));
        else
        rb_raise(rb_eTypeError,
          "wrong argument type"
          " (expected vector<""int" ">)");
      }
    } else {
      SWIG_ConvertPtr(argv[0], (void **) &arg2, SWIGTYPE_p_std__vectorTint_t, 1);
    }
  }
  if (arg1) (*arg1)->_path = *arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolRingIter__path_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolRingIter *arg1 = (OpenBabel::OBMolRingIter *) 0 ;
  std::vector<int > *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolRingIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_path" "', argument " "1"" of type '" "OpenBabel::OBMolRingIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolRingIter * >(argp1);
  {
    std::vector<int > const &_result_ref =  ((*arg1)->_path);
    result = (std::vector<int > *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorTint_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolRingIter__pathset_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolRingIter *arg1 = (OpenBabel::OBMolRingIter *) 0 ;
  OpenBabel::OBBitVec *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolRingIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_pathset" "', argument " "1"" of type '" "OpenBabel::OBMolRingIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolRingIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBBitVec,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "_pathset" "', argument " "2"" of type '" "OpenBabel::OBBitVec const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "_pathset" "', argument " "2"" of type '" "OpenBabel::OBBitVec const &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBitVec * >(argp2);
  if (arg1) (*arg1)->_pathset = *arg2;
  
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolRingIter__pathset_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolRingIter *arg1 = (OpenBabel::OBMolRingIter *) 0 ;
  OpenBabel::OBBitVec *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolRingIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_pathset" "', argument " "1"" of type '" "OpenBabel::OBMolRingIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolRingIter * >(argp1);
  {
    OpenBabel::OBBitVec const &_result_ref =  ((*arg1)->_pathset);
    result = (OpenBabel::OBBitVec *) &_result_ref;
  }
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBitVec, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolRingIter_size(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolRingIter *arg1 = (OpenBabel::OBMolRingIter *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolRingIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Size" "', argument " "1"" of type '" "OpenBabel::OBMolRingIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolRingIter * >(argp1);
  result = (int)(*arg1)->Size();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolRingIter_path_size(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolRingIter *arg1 = (OpenBabel::OBMolRingIter *) 0 ;
  int result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolRingIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathSize" "', argument " "1"" of type '" "OpenBabel::OBMolRingIter const *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolRingIter * >(argp1);
  result = (int)(*arg1)->PathSize();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolRingIter_is_aromatic(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolRingIter *arg1 = (OpenBabel::OBMolRingIter *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolRingIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsAromatic" "', argument " "1"" of type '" "OpenBabel::OBMolRingIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolRingIter * >(argp1);
  result = (bool)(*arg1)->IsAromatic();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolRingIter_is_member__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolRingIter *arg1 = (OpenBabel::OBMolRingIter *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolRingIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsMember" "', argument " "1"" of type '" "OpenBabel::OBMolRingIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolRingIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "IsMember" "', argument " "2"" of type '" "OpenBabel::OBAtom *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (bool)(*arg1)->IsMember(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolRingIter_is_member__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolRingIter *arg1 = (OpenBabel::OBMolRingIter *) 0 ;
  OpenBabel::OBBond *arg2 = (OpenBabel::OBBond *) 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolRingIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsMember" "', argument " "1"" of type '" "OpenBabel::OBMolRingIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolRingIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "IsMember" "', argument " "2"" of type '" "OpenBabel::OBBond *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBBond * >(argp2);
  result = (bool)(*arg1)->IsMember(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OBMolRingIter_is_member(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ii++) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolRingIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMolRingIter_is_member__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMolRingIter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBBond, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OBMolRingIter_is_member__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  rb_raise(rb_eArgError, "No matching function for overloaded 'OBMolRingIter_is_member'");
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolRingIter_is_in_ring(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolRingIter *arg1 = (OpenBabel::OBMolRingIter *) 0 ;
  int arg2 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolRingIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IsInRing" "', argument " "1"" of type '" "OpenBabel::OBMolRingIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolRingIter * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IsInRing" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (bool)(*arg1)->IsInRing(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolRingIter_set_parent(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolRingIter *arg1 = (OpenBabel::OBMolRingIter *) 0 ;
  OpenBabel::OBMol *arg2 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolRingIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SetParent" "', argument " "1"" of type '" "OpenBabel::OBMolRingIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolRingIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SetParent" "', argument " "2"" of type '" "OpenBabel::OBMol *""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2);
  (*arg1)->SetParent(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolRingIter_get_parent(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolRingIter *arg1 = (OpenBabel::OBMolRingIter *) 0 ;
  OpenBabel::OBMol *result = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolRingIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GetParent" "', argument " "1"" of type '" "OpenBabel::OBMolRingIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolRingIter * >(argp1);
  result = (OpenBabel::OBMol *)(*arg1)->GetParent();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OBMolRingIter_find_center_and_normal(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolRingIter *arg1 = (OpenBabel::OBMolRingIter *) 0 ;
  OpenBabel::vector3 *arg2 = 0 ;
  OpenBabel::vector3 *arg3 = 0 ;
  OpenBabel::vector3 *arg4 = 0 ;
  bool result;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolRingIter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "findCenterAndNormal" "', argument " "1"" of type '" "OpenBabel::OBMolRingIter *""'"); 
  }
  arg1 = reinterpret_cast< OpenBabel::OBMolRingIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "findCenterAndNormal" "', argument " "2"" of type '" "OpenBabel::vector3 &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "findCenterAndNormal" "', argument " "2"" of type '" "OpenBabel::vector3 &""'"); 
  }
  arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "findCenterAndNormal" "', argument " "3"" of type '" "OpenBabel::vector3 &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "findCenterAndNormal" "', argument " "3"" of type '" "OpenBabel::vector3 &""'"); 
  }
  arg3 = reinterpret_cast< OpenBabel::vector3 * >(argp3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4, SWIGTYPE_p_OpenBabel__vector3,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "findCenterAndNormal" "', argument " "4"" of type '" "OpenBabel::vector3 &""'"); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "findCenterAndNormal" "', argument " "4"" of type '" "OpenBabel::vector3 &""'"); 
  }
  arg4 = reinterpret_cast< OpenBabel::vector3 * >(argp4);
  result = (bool)(*arg1)->findCenterAndNormal(*arg2,*arg3,*arg4);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}



/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */

static void *_p_OpenBabel__OBAtomTyperTo_p_OpenBabel__OBGlobalDataBase(void *x) {
    return (void *)((OpenBabel::OBGlobalDataBase *)  ((OpenBabel::OBAtomTyper *) x));
}
static void *_p_OpenBabel__OBAromaticTyperTo_p_OpenBabel__OBGlobalDataBase(void *x) {
    return (void *)((OpenBabel::OBGlobalDataBase *)  ((OpenBabel::OBAromaticTyper *) x));
}
static void *_p_OpenBabel__OBResidueDataTo_p_OpenBabel__OBGlobalDataBase(void *x) {
    return (void *)((OpenBabel::OBGlobalDataBase *)  ((OpenBabel::OBResidueData *) x));
}
static void *_p_OpenBabel__OBIsotopeTableTo_p_OpenBabel__OBGlobalDataBase(void *x) {
    return (void *)((OpenBabel::OBGlobalDataBase *)  ((OpenBabel::OBIsotopeTable *) x));
}
static void *_p_OpenBabel__OBTypeTableTo_p_OpenBabel__OBGlobalDataBase(void *x) {
    return (void *)((OpenBabel::OBGlobalDataBase *)  ((OpenBabel::OBTypeTable *) x));
}
static void *_p_OpenBabel__OBElementTableTo_p_OpenBabel__OBGlobalDataBase(void *x) {
    return (void *)((OpenBabel::OBGlobalDataBase *)  ((OpenBabel::OBElementTable *) x));
}
static void *_p_OpenBabel__OBMolTo_p_OpenBabel__OBBase(void *x) {
    return (void *)((OpenBabel::OBBase *)  ((OpenBabel::OBMol *) x));
}
static void *_p_OpenBabel__OBResidueTo_p_OpenBabel__OBBase(void *x) {
    return (void *)((OpenBabel::OBBase *)  ((OpenBabel::OBResidue *) x));
}
static void *_p_OpenBabel__OBBondTo_p_OpenBabel__OBBase(void *x) {
    return (void *)((OpenBabel::OBBase *)  ((OpenBabel::OBBond *) x));
}
static void *_p_OpenBabel__OBAtomTo_p_OpenBabel__OBBase(void *x) {
    return (void *)((OpenBabel::OBBase *)  ((OpenBabel::OBAtom *) x));
}
static void *_p_OpenBabel__OBVibrationDataTo_p_OpenBabel__OBGenericData(void *x) {
    return (void *)((OpenBabel::OBGenericData *)  ((OpenBabel::OBVibrationData *) x));
}
static void *_p_OpenBabel__OBTorsionDataTo_p_OpenBabel__OBGenericData(void *x) {
    return (void *)((OpenBabel::OBGenericData *)  ((OpenBabel::OBTorsionData *) x));
}
static void *_p_OpenBabel__OBPairDataTo_p_OpenBabel__OBGenericData(void *x) {
    return (void *)((OpenBabel::OBGenericData *)  ((OpenBabel::OBPairData *) x));
}
static void *_p_OpenBabel__OBAngleDataTo_p_OpenBabel__OBGenericData(void *x) {
    return (void *)((OpenBabel::OBGenericData *)  ((OpenBabel::OBAngleData *) x));
}
static void *_p_OpenBabel__OBChiralDataTo_p_OpenBabel__OBGenericData(void *x) {
    return (void *)((OpenBabel::OBGenericData *)  ((OpenBabel::OBChiralData *) x));
}
static void *_p_OpenBabel__OBRingDataTo_p_OpenBabel__OBGenericData(void *x) {
    return (void *)((OpenBabel::OBGenericData *)  ((OpenBabel::OBRingData *) x));
}
static void *_p_OpenBabel__OBSerialNumsTo_p_OpenBabel__OBGenericData(void *x) {
    return (void *)((OpenBabel::OBGenericData *)  ((OpenBabel::OBSerialNums *) x));
}
static void *_p_OpenBabel__OBExternalBondDataTo_p_OpenBabel__OBGenericData(void *x) {
    return (void *)((OpenBabel::OBGenericData *)  ((OpenBabel::OBExternalBondData *) x));
}
static void *_p_OpenBabel__OBSetDataTo_p_OpenBabel__OBGenericData(void *x) {
    return (void *)((OpenBabel::OBGenericData *)  ((OpenBabel::OBSetData *) x));
}
static void *_p_OpenBabel__OBSymmetryDataTo_p_OpenBabel__OBGenericData(void *x) {
    return (void *)((OpenBabel::OBGenericData *)  ((OpenBabel::OBSymmetryData *) x));
}
static void *_p_OpenBabel__OBCommentDataTo_p_OpenBabel__OBGenericData(void *x) {
    return (void *)((OpenBabel::OBGenericData *)  ((OpenBabel::OBCommentData *) x));
}
static void *_p_OpenBabel__OBVirtualBondTo_p_OpenBabel__OBGenericData(void *x) {
    return (void *)((OpenBabel::OBGenericData *)  ((OpenBabel::OBVirtualBond *) x));
}
static void *_p_OpenBabel__OBConformerDataTo_p_OpenBabel__OBGenericData(void *x) {
    return (void *)((OpenBabel::OBGenericData *)  ((OpenBabel::OBConformerData *) x));
}
static void *_p_OpenBabel__OBUnitCellTo_p_OpenBabel__OBGenericData(void *x) {
    return (void *)((OpenBabel::OBGenericData *)  ((OpenBabel::OBUnitCell *) x));
}
static void *_p_p_OpenBabel__OBVibrationDataTo_p_p_OpenBabel__OBGenericData(void *x) {
    return (void *)((OpenBabel::OBGenericData **)  ((OpenBabel::OBVibrationData **) x));
}
static void *_p_p_OpenBabel__OBTorsionDataTo_p_p_OpenBabel__OBGenericData(void *x) {
    return (void *)((OpenBabel::OBGenericData **)  ((OpenBabel::OBTorsionData **) x));
}
static void *_p_p_OpenBabel__OBPairDataTo_p_p_OpenBabel__OBGenericData(void *x) {
    return (void *)((OpenBabel::OBGenericData **)  ((OpenBabel::OBPairData **) x));
}
static void *_p_p_OpenBabel__OBAngleDataTo_p_p_OpenBabel__OBGenericData(void *x) {
    return (void *)((OpenBabel::OBGenericData **)  ((OpenBabel::OBAngleData **) x));
}
static void *_p_p_OpenBabel__OBChiralDataTo_p_p_OpenBabel__OBGenericData(void *x) {
    return (void *)((OpenBabel::OBGenericData **)  ((OpenBabel::OBChiralData **) x));
}
static void *_p_p_OpenBabel__OBRingDataTo_p_p_OpenBabel__OBGenericData(void *x) {
    return (void *)((OpenBabel::OBGenericData **)  ((OpenBabel::OBRingData **) x));
}
static void *_p_p_OpenBabel__OBSerialNumsTo_p_p_OpenBabel__OBGenericData(void *x) {
    return (void *)((OpenBabel::OBGenericData **)  ((OpenBabel::OBSerialNums **) x));
}
static void *_p_p_OpenBabel__OBExternalBondDataTo_p_p_OpenBabel__OBGenericData(void *x) {
    return (void *)((OpenBabel::OBGenericData **)  ((OpenBabel::OBExternalBondData **) x));
}
static void *_p_p_OpenBabel__OBSetDataTo_p_p_OpenBabel__OBGenericData(void *x) {
    return (void *)((OpenBabel::OBGenericData **)  ((OpenBabel::OBSetData **) x));
}
static void *_p_p_OpenBabel__OBSymmetryDataTo_p_p_OpenBabel__OBGenericData(void *x) {
    return (void *)((OpenBabel::OBGenericData **)  ((OpenBabel::OBSymmetryData **) x));
}
static void *_p_p_OpenBabel__OBCommentDataTo_p_p_OpenBabel__OBGenericData(void *x) {
    return (void *)((OpenBabel::OBGenericData **)  ((OpenBabel::OBCommentData **) x));
}
static void *_p_p_OpenBabel__OBVirtualBondTo_p_p_OpenBabel__OBGenericData(void *x) {
    return (void *)((OpenBabel::OBGenericData **)  ((OpenBabel::OBVirtualBond **) x));
}
static void *_p_p_OpenBabel__OBConformerDataTo_p_p_OpenBabel__OBGenericData(void *x) {
    return (void *)((OpenBabel::OBGenericData **)  ((OpenBabel::OBConformerData **) x));
}
static void *_p_p_OpenBabel__OBUnitCellTo_p_p_OpenBabel__OBGenericData(void *x) {
    return (void *)((OpenBabel::OBGenericData **)  ((OpenBabel::OBUnitCell **) x));
}
static swig_type_info _swigt__p_OpenBabel__CharPtrLess = {"_p_OpenBabel__CharPtrLess", "OpenBabel::CharPtrLess *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__DoubleType = {"_p_OpenBabel__DoubleType", "OpenBabel::DoubleType *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__FMapType__iterator = {"_p_OpenBabel__FMapType__iterator", "OpenBabel::FMapType::iterator *|OpenBabel::Formatpos *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__FastSearch = {"_p_OpenBabel__FastSearch", "OpenBabel::FastSearch *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__FastSearchIndexer = {"_p_OpenBabel__FastSearchIndexer", "OpenBabel::FastSearchIndexer *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__FptIndex = {"_p_OpenBabel__FptIndex", "OpenBabel::FptIndex *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__FptIndexHeader = {"_p_OpenBabel__FptIndexHeader", "OpenBabel::FptIndexHeader *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBAngle = {"_p_OpenBabel__OBAngle", "OpenBabel::OBAngle *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBAngleData = {"_p_OpenBabel__OBAngleData", "OpenBabel::OBAngleData *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBAromaticTyper = {"_p_OpenBabel__OBAromaticTyper", "OpenBabel::OBAromaticTyper *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBAtom = {"_p_OpenBabel__OBAtom", "OpenBabel::OBAtom *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBAtomAtomIter = {"_p_OpenBabel__OBAtomAtomIter", "OpenBabel::OBAtomAtomIter *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBAtomBondIter = {"_p_OpenBabel__OBAtomBondIter", "OpenBabel::OBAtomBondIter *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBAtomTyper = {"_p_OpenBabel__OBAtomTyper", "OpenBabel::OBAtomTyper *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBBase = {"_p_OpenBabel__OBBase", "OpenBabel::OBBase *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBBitVec = {"_p_OpenBabel__OBBitVec", "OpenBabel::OBBitVec *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBBond = {"_p_OpenBabel__OBBond", "OpenBabel::OBBond *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBChainsParser = {"_p_OpenBabel__OBChainsParser", "OpenBabel::OBChainsParser *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBChiralData = {"_p_OpenBabel__OBChiralData", "OpenBabel::OBChiralData *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBCommentData = {"_p_OpenBabel__OBCommentData", "OpenBabel::OBCommentData *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBConformerData = {"_p_OpenBabel__OBConformerData", "OpenBabel::OBConformerData *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBConversion = {"_p_OpenBabel__OBConversion", "OpenBabel::OBConversion *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBElement = {"_p_OpenBabel__OBElement", "OpenBabel::OBElement *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBElementTable = {"_p_OpenBabel__OBElementTable", "OpenBabel::OBElementTable *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBError = {"_p_OpenBabel__OBError", "OpenBabel::OBError *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBExternalBond = {"_p_OpenBabel__OBExternalBond", "OpenBabel::OBExternalBond *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBExternalBondData = {"_p_OpenBabel__OBExternalBondData", "OpenBabel::OBExternalBondData *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBFFCalculation = {"_p_OpenBabel__OBFFCalculation", "OpenBabel::OBFFCalculation *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBFFParameter = {"_p_OpenBabel__OBFFParameter", "OpenBabel::OBFFParameter *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBFingerprint = {"_p_OpenBabel__OBFingerprint", "OpenBabel::OBFingerprint *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBForceField = {"_p_OpenBabel__OBForceField", "OpenBabel::OBForceField *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBFormat = {"_p_OpenBabel__OBFormat", "OpenBabel::OBFormat *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBGenericData = {"_p_OpenBabel__OBGenericData", "OpenBabel::OBGenericData *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBGlobalDataBase = {"_p_OpenBabel__OBGlobalDataBase", "OpenBabel::OBGlobalDataBase *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBInternalCoord = {"_p_OpenBabel__OBInternalCoord", "OpenBabel::OBInternalCoord *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBIsotopeTable = {"_p_OpenBabel__OBIsotopeTable", "OpenBabel::OBIsotopeTable *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBMessageHandler = {"_p_OpenBabel__OBMessageHandler", "OpenBabel::OBMessageHandler *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBMol = {"_p_OpenBabel__OBMol", "OpenBabel::OBMol *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBMolAngleIter = {"_p_OpenBabel__OBMolAngleIter", "OpenBabel::OBMolAngleIter *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBMolAtomBFSIter = {"_p_OpenBabel__OBMolAtomBFSIter", "OpenBabel::OBMolAtomBFSIter *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBMolAtomDFSIter = {"_p_OpenBabel__OBMolAtomDFSIter", "OpenBabel::OBMolAtomDFSIter *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBMolAtomIter = {"_p_OpenBabel__OBMolAtomIter", "OpenBabel::OBMolAtomIter *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBMolBondIter = {"_p_OpenBabel__OBMolBondIter", "OpenBabel::OBMolBondIter *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBMolPairIter = {"_p_OpenBabel__OBMolPairIter", "OpenBabel::OBMolPairIter *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBMolRingIter = {"_p_OpenBabel__OBMolRingIter", "OpenBabel::OBMolRingIter *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBMolTorsionIter = {"_p_OpenBabel__OBMolTorsionIter", "OpenBabel::OBMolTorsionIter *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBPairData = {"_p_OpenBabel__OBPairData", "OpenBabel::OBPairData *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBPairTemplateTdouble_t = {"_p_OpenBabel__OBPairTemplateTdouble_t", "OpenBabel::OBPairTemplate<double > *|OpenBabel::OBPairFloatingPoint *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBPairTemplateTint_t = {"_p_OpenBabel__OBPairTemplateTint_t", "OpenBabel::OBPairTemplate<int > *|OpenBabel::OBPairInteger *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBRTree = {"_p_OpenBabel__OBRTree", "OpenBabel::OBRTree *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBRandom = {"_p_OpenBabel__OBRandom", "OpenBabel::OBRandom *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBResidue = {"_p_OpenBabel__OBResidue", "OpenBabel::OBResidue *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBResidueAtomIter = {"_p_OpenBabel__OBResidueAtomIter", "OpenBabel::OBResidueAtomIter *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBResidueData = {"_p_OpenBabel__OBResidueData", "OpenBabel::OBResidueData *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBResidueIter = {"_p_OpenBabel__OBResidueIter", "OpenBabel::OBResidueIter *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBRing = {"_p_OpenBabel__OBRing", "OpenBabel::OBRing *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBRingData = {"_p_OpenBabel__OBRingData", "OpenBabel::OBRingData *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBRingSearch = {"_p_OpenBabel__OBRingSearch", "OpenBabel::OBRingSearch *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBSSMatch = {"_p_OpenBabel__OBSSMatch", "OpenBabel::OBSSMatch *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBSerialNums = {"_p_OpenBabel__OBSerialNums", "OpenBabel::OBSerialNums *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBSetData = {"_p_OpenBabel__OBSetData", "OpenBabel::OBSetData *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBSmartsPattern = {"_p_OpenBabel__OBSmartsPattern", "OpenBabel::OBSmartsPattern *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBSqrtTbl = {"_p_OpenBabel__OBSqrtTbl", "OpenBabel::OBSqrtTbl *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBStopwatch = {"_p_OpenBabel__OBStopwatch", "OpenBabel::OBStopwatch *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBSymmetryData = {"_p_OpenBabel__OBSymmetryData", "OpenBabel::OBSymmetryData *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBTorsion = {"_p_OpenBabel__OBTorsion", "OpenBabel::OBTorsion *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBTorsionData = {"_p_OpenBabel__OBTorsionData", "OpenBabel::OBTorsionData *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBTypeTable = {"_p_OpenBabel__OBTypeTable", "OpenBabel::OBTypeTable *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBUnitCell = {"_p_OpenBabel__OBUnitCell", "OpenBabel::OBUnitCell *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBVibrationData = {"_p_OpenBabel__OBVibrationData", "OpenBabel::OBVibrationData *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBVirtualBond = {"_p_OpenBabel__OBVirtualBond", "OpenBabel::OBVirtualBond *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__Pattern = {"_p_OpenBabel__Pattern", "OpenBabel::Pattern *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__PluginIterTOpenBabel__OBFingerprint_t = {"_p_OpenBabel__PluginIterTOpenBabel__OBFingerprint_t", "OpenBabel::PluginIter<OpenBabel::OBFingerprint > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__PluginIterTOpenBabel__OBForceField_t = {"_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t", "OpenBabel::PluginIter<OpenBabel::OBForceField > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__Template = {"_p_OpenBabel__Template", "OpenBabel::Template *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__matrix3x3 = {"_p_OpenBabel__matrix3x3", "OpenBabel::matrix3x3 *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__obLogBuf = {"_p_OpenBabel__obLogBuf", "OpenBabel::obLogBuf *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__quadTOpenBabel__OBAtom_p_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_t = {"_p_OpenBabel__quadTOpenBabel__OBAtom_p_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_t", "OpenBabel::quad<OpenBabel::OBAtom *,OpenBabel::OBAtom *,OpenBabel::OBAtom *,OpenBabel::OBAtom * > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__tripleTOpenBabel__OBAtom_p_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_t = {"_p_OpenBabel__tripleTOpenBabel__OBAtom_p_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_t", "OpenBabel::triple<OpenBabel::OBAtom *,OpenBabel::OBAtom *,OpenBabel::OBAtom * > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__vector3 = {"_p_OpenBabel__vector3", "OpenBabel::vector3 *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_a_3__double = {"_p_a_3__double", "double (*)[3]", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_a_4__char = {"_p_a_4__char", "char (*)[4]", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_char = {"_p_char", "char *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_double = {"_p_double", "double *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_int = {"_p_int", "int *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_OpenBabel__OBFormat = {"_p_p_OpenBabel__OBFormat", "OpenBabel::OBFormat **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_OpenBabel__OBGenericData = {"_p_p_OpenBabel__OBGenericData", "OpenBabel::OBGenericData **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_OpenBabel__OBVibrationData = {"_p_p_OpenBabel__OBVibrationData", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_p_OpenBabel__OBTorsionData = {"_p_p_OpenBabel__OBTorsionData", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_p_OpenBabel__OBPairData = {"_p_p_OpenBabel__OBPairData", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_p_OpenBabel__OBAngleData = {"_p_p_OpenBabel__OBAngleData", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_p_OpenBabel__OBChiralData = {"_p_p_OpenBabel__OBChiralData", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_p_OpenBabel__OBRingData = {"_p_p_OpenBabel__OBRingData", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_p_OpenBabel__OBSerialNums = {"_p_p_OpenBabel__OBSerialNums", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_p_OpenBabel__OBExternalBondData = {"_p_p_OpenBabel__OBExternalBondData", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_p_OpenBabel__OBSetData = {"_p_p_OpenBabel__OBSetData", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_p_OpenBabel__OBSymmetryData = {"_p_p_OpenBabel__OBSymmetryData", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_p_OpenBabel__OBCommentData = {"_p_p_OpenBabel__OBCommentData", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_p_OpenBabel__OBVirtualBond = {"_p_p_OpenBabel__OBVirtualBond", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_p_OpenBabel__OBConformerData = {"_p_p_OpenBabel__OBConformerData", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_p_OpenBabel__OBUnitCell = {"_p_p_OpenBabel__OBUnitCell", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_p_double = {"_p_p_double", "double **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_int = {"_p_p_int", "int **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__dequeTint_t = {"_p_std__dequeTint_t", "std::deque<int > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__ifstream = {"_p_std__ifstream", "std::ifstream *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__istream = {"_p_std__istream", "std::istream *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__mapTchar_const_p_OpenBabel__OBFormat_p_OpenBabel__CharPtrLess_t = {"_p_std__mapTchar_const_p_OpenBabel__OBFormat_p_OpenBabel__CharPtrLess_t", "std::map<char const *,OpenBabel::OBFormat *,OpenBabel::CharPtrLess > *|OpenBabel::FMapType *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__mapTint_OpenBabel__OBAtom_p_t = {"_p_std__mapTint_OpenBabel__OBAtom_p_t", "std::map<int,OpenBabel::OBAtom * > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__mapTstd__string_std__string_t = {"_p_std__mapTstd__string_std__string_t", "std::map<std::string,std::string > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__multimapTdouble_unsigned_int_t = {"_p_std__multimapTdouble_unsigned_int_t", "std::multimap<double,unsigned int > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__ostream = {"_p_std__ostream", "std::ostream *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__out_of_range = {"_p_std__out_of_range", "std::out_of_range *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__pairTOpenBabel__OBAtom_p_OpenBabel__OBAtom_p_t = {"_p_std__pairTOpenBabel__OBAtom_p_OpenBabel__OBAtom_p_t", "std::pair<OpenBabel::OBAtom *,OpenBabel::OBAtom * > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__streampos = {"_p_std__streampos", "std::streampos *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__string = {"_p_std__string", "std::string *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__type_info = {"_p_std__type_info", "std::type_info *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorTOpenBabel__OBAtom_p_t = {"_p_std__vectorTOpenBabel__OBAtom_p_t", "std::vector<OpenBabel::OBAtom * > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorTOpenBabel__OBAtom_p_t__iterator = {"_p_std__vectorTOpenBabel__OBAtom_p_t__iterator", "std::vector<OpenBabel::OBAtom * >::iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorTOpenBabel__OBBond_p_t = {"_p_std__vectorTOpenBabel__OBBond_p_t", "std::vector<OpenBabel::OBBond * > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorTOpenBabel__OBBond_p_t__iterator = {"_p_std__vectorTOpenBabel__OBBond_p_t__iterator", "std::vector<OpenBabel::OBBond * >::iterator *|OpenBabel::OBBondIterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorTOpenBabel__OBBond_t = {"_p_std__vectorTOpenBabel__OBBond_t", "std::vector<OpenBabel::OBBond > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorTOpenBabel__OBExternalBond_t = {"_p_std__vectorTOpenBabel__OBExternalBond_t", "std::vector<OpenBabel::OBExternalBond > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorTOpenBabel__OBGenericData_p_t = {"_p_std__vectorTOpenBabel__OBGenericData_p_t", "std::vector<OpenBabel::OBGenericData * > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorTOpenBabel__OBGenericData_p_t__iterator = {"_p_std__vectorTOpenBabel__OBGenericData_p_t__iterator", "std::vector<OpenBabel::OBGenericData * >::iterator *|OpenBabel::OBDataIterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorTOpenBabel__OBInternalCoord_p_t = {"_p_std__vectorTOpenBabel__OBInternalCoord_p_t", "std::vector<OpenBabel::OBInternalCoord * > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorTOpenBabel__OBInternalCoord_p_t__iterator = {"_p_std__vectorTOpenBabel__OBInternalCoord_p_t__iterator", "std::vector<OpenBabel::OBInternalCoord * >::iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorTOpenBabel__OBMol_t = {"_p_std__vectorTOpenBabel__OBMol_t", "std::vector<OpenBabel::OBMol > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorTOpenBabel__OBResidue_p_t__iterator = {"_p_std__vectorTOpenBabel__OBResidue_p_t__iterator", "std::vector<OpenBabel::OBResidue * >::iterator *|OpenBabel::OBResidueIterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorTOpenBabel__OBResidue_t = {"_p_std__vectorTOpenBabel__OBResidue_t", "std::vector<OpenBabel::OBResidue > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorTOpenBabel__OBRing_p_t = {"_p_std__vectorTOpenBabel__OBRing_p_t", "std::vector<OpenBabel::OBRing * > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorTOpenBabel__OBRing_p_t__iterator = {"_p_std__vectorTOpenBabel__OBRing_p_t__iterator", "std::vector<OpenBabel::OBRing * >::iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorTOpenBabel__OBRing_t = {"_p_std__vectorTOpenBabel__OBRing_t", "std::vector<OpenBabel::OBRing > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorTOpenBabel__OBTorsion_t = {"_p_std__vectorTOpenBabel__OBTorsion_t", "std::vector<OpenBabel::OBTorsion > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorTOpenBabel__tripleTOpenBabel__OBAtom_p_OpenBabel__OBAtom_p_double_t_t = {"_p_std__vectorTOpenBabel__tripleTOpenBabel__OBAtom_p_OpenBabel__OBAtom_p_double_t_t", "std::vector<OpenBabel::triple<OpenBabel::OBAtom *,OpenBabel::OBAtom *,double > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorTOpenBabel__vector3_t = {"_p_std__vectorTOpenBabel__vector3_t", "std::vector<OpenBabel::vector3 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorTdouble_p_t = {"_p_std__vectorTdouble_p_t", "std::vector<double * > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorTdouble_p_t__iterator = {"_p_std__vectorTdouble_p_t__iterator", "std::vector<double * >::iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorTdouble_t = {"_p_std__vectorTdouble_t", "std::vector<double > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorTint_t = {"_p_std__vectorTint_t", "std::vector<int > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorTstd__pairTint_int_t_t = {"_p_std__vectorTstd__pairTint_int_t_t", "std::vector<std::pair<int,int > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorTstd__pairTstd__string_std__string_t_t = {"_p_std__vectorTstd__pairTstd__string_std__string_t_t", "std::vector<std::pair<std::string,std::string > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorTstd__string_t = {"_p_std__vectorTstd__string_t", "std::vector<std::string > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorTstd__vectorTOpenBabel__vector3_t_t = {"_p_std__vectorTstd__vectorTOpenBabel__vector3_t_t", "std::vector<std::vector<OpenBabel::vector3 > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorTstd__vectorTint_t_t = {"_p_std__vectorTstd__vectorTint_t_t", "std::vector<std::vector<int > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorTstd__vectorTint_t_t__iterator = {"_p_std__vectorTstd__vectorTint_t_t__iterator", "std::vector<std::vector<int > >::iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorTstd__vectorTunsigned_int_t_t = {"_p_std__vectorTstd__vectorTunsigned_int_t_t", "std::vector<std::vector<unsigned int > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorTunsigned_int_t = {"_p_std__vectorTunsigned_int_t", "std::vector<unsigned int > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorTunsigned_short_t = {"_p_std__vectorTunsigned_short_t", "std::vector<unsigned short > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_unsigned_int = {"_p_unsigned_int", "unsigned int *", 0, 0, (void*)0, 0};

static swig_type_info *swig_type_initial[] = {
  &_swigt__p_OpenBabel__CharPtrLess,
  &_swigt__p_OpenBabel__DoubleType,
  &_swigt__p_OpenBabel__FMapType__iterator,
  &_swigt__p_OpenBabel__FastSearch,
  &_swigt__p_OpenBabel__FastSearchIndexer,
  &_swigt__p_OpenBabel__FptIndex,
  &_swigt__p_OpenBabel__FptIndexHeader,
  &_swigt__p_OpenBabel__OBAngle,
  &_swigt__p_OpenBabel__OBAngleData,
  &_swigt__p_OpenBabel__OBAromaticTyper,
  &_swigt__p_OpenBabel__OBAtom,
  &_swigt__p_OpenBabel__OBAtomAtomIter,
  &_swigt__p_OpenBabel__OBAtomBondIter,
  &_swigt__p_OpenBabel__OBAtomTyper,
  &_swigt__p_OpenBabel__OBBase,
  &_swigt__p_OpenBabel__OBBitVec,
  &_swigt__p_OpenBabel__OBBond,
  &_swigt__p_OpenBabel__OBChainsParser,
  &_swigt__p_OpenBabel__OBChiralData,
  &_swigt__p_OpenBabel__OBCommentData,
  &_swigt__p_OpenBabel__OBConformerData,
  &_swigt__p_OpenBabel__OBConversion,
  &_swigt__p_OpenBabel__OBElement,
  &_swigt__p_OpenBabel__OBElementTable,
  &_swigt__p_OpenBabel__OBError,
  &_swigt__p_OpenBabel__OBExternalBond,
  &_swigt__p_OpenBabel__OBExternalBondData,
  &_swigt__p_OpenBabel__OBFFCalculation,
  &_swigt__p_OpenBabel__OBFFParameter,
  &_swigt__p_OpenBabel__OBFingerprint,
  &_swigt__p_OpenBabel__OBForceField,
  &_swigt__p_OpenBabel__OBFormat,
  &_swigt__p_OpenBabel__OBGenericData,
  &_swigt__p_OpenBabel__OBGlobalDataBase,
  &_swigt__p_OpenBabel__OBInternalCoord,
  &_swigt__p_OpenBabel__OBIsotopeTable,
  &_swigt__p_OpenBabel__OBMessageHandler,
  &_swigt__p_OpenBabel__OBMol,
  &_swigt__p_OpenBabel__OBMolAngleIter,
  &_swigt__p_OpenBabel__OBMolAtomBFSIter,
  &_swigt__p_OpenBabel__OBMolAtomDFSIter,
  &_swigt__p_OpenBabel__OBMolAtomIter,
  &_swigt__p_OpenBabel__OBMolBondIter,
  &_swigt__p_OpenBabel__OBMolPairIter,
  &_swigt__p_OpenBabel__OBMolRingIter,
  &_swigt__p_OpenBabel__OBMolTorsionIter,
  &_swigt__p_OpenBabel__OBPairData,
  &_swigt__p_OpenBabel__OBPairTemplateTdouble_t,
  &_swigt__p_OpenBabel__OBPairTemplateTint_t,
  &_swigt__p_OpenBabel__OBRTree,
  &_swigt__p_OpenBabel__OBRandom,
  &_swigt__p_OpenBabel__OBResidue,
  &_swigt__p_OpenBabel__OBResidueAtomIter,
  &_swigt__p_OpenBabel__OBResidueData,
  &_swigt__p_OpenBabel__OBResidueIter,
  &_swigt__p_OpenBabel__OBRing,
  &_swigt__p_OpenBabel__OBRingData,
  &_swigt__p_OpenBabel__OBRingSearch,
  &_swigt__p_OpenBabel__OBSSMatch,
  &_swigt__p_OpenBabel__OBSerialNums,
  &_swigt__p_OpenBabel__OBSetData,
  &_swigt__p_OpenBabel__OBSmartsPattern,
  &_swigt__p_OpenBabel__OBSqrtTbl,
  &_swigt__p_OpenBabel__OBStopwatch,
  &_swigt__p_OpenBabel__OBSymmetryData,
  &_swigt__p_OpenBabel__OBTorsion,
  &_swigt__p_OpenBabel__OBTorsionData,
  &_swigt__p_OpenBabel__OBTypeTable,
  &_swigt__p_OpenBabel__OBUnitCell,
  &_swigt__p_OpenBabel__OBVibrationData,
  &_swigt__p_OpenBabel__OBVirtualBond,
  &_swigt__p_OpenBabel__Pattern,
  &_swigt__p_OpenBabel__PluginIterTOpenBabel__OBFingerprint_t,
  &_swigt__p_OpenBabel__PluginIterTOpenBabel__OBForceField_t,
  &_swigt__p_OpenBabel__Template,
  &_swigt__p_OpenBabel__matrix3x3,
  &_swigt__p_OpenBabel__obLogBuf,
  &_swigt__p_OpenBabel__quadTOpenBabel__OBAtom_p_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_t,
  &_swigt__p_OpenBabel__tripleTOpenBabel__OBAtom_p_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_t,
  &_swigt__p_OpenBabel__vector3,
  &_swigt__p_a_3__double,
  &_swigt__p_a_4__char,
  &_swigt__p_char,
  &_swigt__p_double,
  &_swigt__p_int,
  &_swigt__p_p_OpenBabel__OBAngleData,
  &_swigt__p_p_OpenBabel__OBChiralData,
  &_swigt__p_p_OpenBabel__OBCommentData,
  &_swigt__p_p_OpenBabel__OBConformerData,
  &_swigt__p_p_OpenBabel__OBExternalBondData,
  &_swigt__p_p_OpenBabel__OBFormat,
  &_swigt__p_p_OpenBabel__OBGenericData,
  &_swigt__p_p_OpenBabel__OBPairData,
  &_swigt__p_p_OpenBabel__OBRingData,
  &_swigt__p_p_OpenBabel__OBSerialNums,
  &_swigt__p_p_OpenBabel__OBSetData,
  &_swigt__p_p_OpenBabel__OBSymmetryData,
  &_swigt__p_p_OpenBabel__OBTorsionData,
  &_swigt__p_p_OpenBabel__OBUnitCell,
  &_swigt__p_p_OpenBabel__OBVibrationData,
  &_swigt__p_p_OpenBabel__OBVirtualBond,
  &_swigt__p_p_double,
  &_swigt__p_p_int,
  &_swigt__p_std__dequeTint_t,
  &_swigt__p_std__ifstream,
  &_swigt__p_std__istream,
  &_swigt__p_std__mapTchar_const_p_OpenBabel__OBFormat_p_OpenBabel__CharPtrLess_t,
  &_swigt__p_std__mapTint_OpenBabel__OBAtom_p_t,
  &_swigt__p_std__mapTstd__string_std__string_t,
  &_swigt__p_std__multimapTdouble_unsigned_int_t,
  &_swigt__p_std__ostream,
  &_swigt__p_std__out_of_range,
  &_swigt__p_std__pairTOpenBabel__OBAtom_p_OpenBabel__OBAtom_p_t,
  &_swigt__p_std__streampos,
  &_swigt__p_std__string,
  &_swigt__p_std__type_info,
  &_swigt__p_std__vectorTOpenBabel__OBAtom_p_t,
  &_swigt__p_std__vectorTOpenBabel__OBAtom_p_t__iterator,
  &_swigt__p_std__vectorTOpenBabel__OBBond_p_t,
  &_swigt__p_std__vectorTOpenBabel__OBBond_p_t__iterator,
  &_swigt__p_std__vectorTOpenBabel__OBBond_t,
  &_swigt__p_std__vectorTOpenBabel__OBExternalBond_t,
  &_swigt__p_std__vectorTOpenBabel__OBGenericData_p_t,
  &_swigt__p_std__vectorTOpenBabel__OBGenericData_p_t__iterator,
  &_swigt__p_std__vectorTOpenBabel__OBInternalCoord_p_t,
  &_swigt__p_std__vectorTOpenBabel__OBInternalCoord_p_t__iterator,
  &_swigt__p_std__vectorTOpenBabel__OBMol_t,
  &_swigt__p_std__vectorTOpenBabel__OBResidue_p_t__iterator,
  &_swigt__p_std__vectorTOpenBabel__OBResidue_t,
  &_swigt__p_std__vectorTOpenBabel__OBRing_p_t,
  &_swigt__p_std__vectorTOpenBabel__OBRing_p_t__iterator,
  &_swigt__p_std__vectorTOpenBabel__OBRing_t,
  &_swigt__p_std__vectorTOpenBabel__OBTorsion_t,
  &_swigt__p_std__vectorTOpenBabel__tripleTOpenBabel__OBAtom_p_OpenBabel__OBAtom_p_double_t_t,
  &_swigt__p_std__vectorTOpenBabel__vector3_t,
  &_swigt__p_std__vectorTdouble_p_t,
  &_swigt__p_std__vectorTdouble_p_t__iterator,
  &_swigt__p_std__vectorTdouble_t,
  &_swigt__p_std__vectorTint_t,
  &_swigt__p_std__vectorTstd__pairTint_int_t_t,
  &_swigt__p_std__vectorTstd__pairTstd__string_std__string_t_t,
  &_swigt__p_std__vectorTstd__string_t,
  &_swigt__p_std__vectorTstd__vectorTOpenBabel__vector3_t_t,
  &_swigt__p_std__vectorTstd__vectorTint_t_t,
  &_swigt__p_std__vectorTstd__vectorTint_t_t__iterator,
  &_swigt__p_std__vectorTstd__vectorTunsigned_int_t_t,
  &_swigt__p_std__vectorTunsigned_int_t,
  &_swigt__p_std__vectorTunsigned_short_t,
  &_swigt__p_unsigned_int,
};

static swig_cast_info _swigc__p_OpenBabel__CharPtrLess[] = {  {&_swigt__p_OpenBabel__CharPtrLess, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__DoubleType[] = {  {&_swigt__p_OpenBabel__DoubleType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__FMapType__iterator[] = {  {&_swigt__p_OpenBabel__FMapType__iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__FastSearch[] = {  {&_swigt__p_OpenBabel__FastSearch, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__FastSearchIndexer[] = {  {&_swigt__p_OpenBabel__FastSearchIndexer, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__FptIndex[] = {  {&_swigt__p_OpenBabel__FptIndex, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__FptIndexHeader[] = {  {&_swigt__p_OpenBabel__FptIndexHeader, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBAngle[] = {  {&_swigt__p_OpenBabel__OBAngle, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBAngleData[] = {  {&_swigt__p_OpenBabel__OBAngleData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBAromaticTyper[] = {  {&_swigt__p_OpenBabel__OBAromaticTyper, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBAtom[] = {  {&_swigt__p_OpenBabel__OBAtom, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBAtomAtomIter[] = {  {&_swigt__p_OpenBabel__OBAtomAtomIter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBAtomBondIter[] = {  {&_swigt__p_OpenBabel__OBAtomBondIter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBAtomTyper[] = {  {&_swigt__p_OpenBabel__OBAtomTyper, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBBase[] = {  {&_swigt__p_OpenBabel__OBMol, _p_OpenBabel__OBMolTo_p_OpenBabel__OBBase, 0, 0},  {&_swigt__p_OpenBabel__OBResidue, _p_OpenBabel__OBResidueTo_p_OpenBabel__OBBase, 0, 0},  {&_swigt__p_OpenBabel__OBBase, 0, 0, 0},  {&_swigt__p_OpenBabel__OBBond, _p_OpenBabel__OBBondTo_p_OpenBabel__OBBase, 0, 0},  {&_swigt__p_OpenBabel__OBAtom, _p_OpenBabel__OBAtomTo_p_OpenBabel__OBBase, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBBitVec[] = {  {&_swigt__p_OpenBabel__OBBitVec, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBBond[] = {  {&_swigt__p_OpenBabel__OBBond, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBChainsParser[] = {  {&_swigt__p_OpenBabel__OBChainsParser, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBChiralData[] = {  {&_swigt__p_OpenBabel__OBChiralData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBCommentData[] = {  {&_swigt__p_OpenBabel__OBCommentData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBConformerData[] = {  {&_swigt__p_OpenBabel__OBConformerData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBConversion[] = {  {&_swigt__p_OpenBabel__OBConversion, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBElement[] = {  {&_swigt__p_OpenBabel__OBElement, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBElementTable[] = {  {&_swigt__p_OpenBabel__OBElementTable, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBError[] = {  {&_swigt__p_OpenBabel__OBError, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBExternalBond[] = {  {&_swigt__p_OpenBabel__OBExternalBond, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBExternalBondData[] = {  {&_swigt__p_OpenBabel__OBExternalBondData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBFFCalculation[] = {  {&_swigt__p_OpenBabel__OBFFCalculation, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBFFParameter[] = {  {&_swigt__p_OpenBabel__OBFFParameter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBFingerprint[] = {  {&_swigt__p_OpenBabel__OBFingerprint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBForceField[] = {  {&_swigt__p_OpenBabel__OBForceField, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBFormat[] = {  {&_swigt__p_OpenBabel__OBFormat, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBGenericData[] = {  {&_swigt__p_OpenBabel__OBVibrationData, _p_OpenBabel__OBVibrationDataTo_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_OpenBabel__OBTorsionData, _p_OpenBabel__OBTorsionDataTo_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_OpenBabel__OBPairData, _p_OpenBabel__OBPairDataTo_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_OpenBabel__OBAngleData, _p_OpenBabel__OBAngleDataTo_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_OpenBabel__OBChiralData, _p_OpenBabel__OBChiralDataTo_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_OpenBabel__OBRingData, _p_OpenBabel__OBRingDataTo_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_OpenBabel__OBSerialNums, _p_OpenBabel__OBSerialNumsTo_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_OpenBabel__OBExternalBondData, _p_OpenBabel__OBExternalBondDataTo_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_OpenBabel__OBSetData, _p_OpenBabel__OBSetDataTo_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_OpenBabel__OBSymmetryData, _p_OpenBabel__OBSymmetryDataTo_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_OpenBabel__OBCommentData, _p_OpenBabel__OBCommentDataTo_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_OpenBabel__OBVirtualBond, _p_OpenBabel__OBVirtualBondTo_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_OpenBabel__OBConformerData, _p_OpenBabel__OBConformerDataTo_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_OpenBabel__OBGenericData, 0, 0, 0},  {&_swigt__p_OpenBabel__OBUnitCell, _p_OpenBabel__OBUnitCellTo_p_OpenBabel__OBGenericData, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBGlobalDataBase[] = {  {&_swigt__p_OpenBabel__OBAtomTyper, _p_OpenBabel__OBAtomTyperTo_p_OpenBabel__OBGlobalDataBase, 0, 0},  {&_swigt__p_OpenBabel__OBAromaticTyper, _p_OpenBabel__OBAromaticTyperTo_p_OpenBabel__OBGlobalDataBase, 0, 0},  {&_swigt__p_OpenBabel__OBGlobalDataBase, 0, 0, 0},  {&_swigt__p_OpenBabel__OBResidueData, _p_OpenBabel__OBResidueDataTo_p_OpenBabel__OBGlobalDataBase, 0, 0},  {&_swigt__p_OpenBabel__OBIsotopeTable, _p_OpenBabel__OBIsotopeTableTo_p_OpenBabel__OBGlobalDataBase, 0, 0},  {&_swigt__p_OpenBabel__OBTypeTable, _p_OpenBabel__OBTypeTableTo_p_OpenBabel__OBGlobalDataBase, 0, 0},  {&_swigt__p_OpenBabel__OBElementTable, _p_OpenBabel__OBElementTableTo_p_OpenBabel__OBGlobalDataBase, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBInternalCoord[] = {  {&_swigt__p_OpenBabel__OBInternalCoord, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBIsotopeTable[] = {  {&_swigt__p_OpenBabel__OBIsotopeTable, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBMessageHandler[] = {  {&_swigt__p_OpenBabel__OBMessageHandler, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBMol[] = {  {&_swigt__p_OpenBabel__OBMol, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBMolAngleIter[] = {  {&_swigt__p_OpenBabel__OBMolAngleIter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBMolAtomBFSIter[] = {  {&_swigt__p_OpenBabel__OBMolAtomBFSIter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBMolAtomDFSIter[] = {  {&_swigt__p_OpenBabel__OBMolAtomDFSIter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBMolAtomIter[] = {  {&_swigt__p_OpenBabel__OBMolAtomIter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBMolBondIter[] = {  {&_swigt__p_OpenBabel__OBMolBondIter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBMolPairIter[] = {  {&_swigt__p_OpenBabel__OBMolPairIter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBMolRingIter[] = {  {&_swigt__p_OpenBabel__OBMolRingIter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBMolTorsionIter[] = {  {&_swigt__p_OpenBabel__OBMolTorsionIter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBPairData[] = {  {&_swigt__p_OpenBabel__OBPairData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBPairTemplateTdouble_t[] = {  {&_swigt__p_OpenBabel__OBPairTemplateTdouble_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBPairTemplateTint_t[] = {  {&_swigt__p_OpenBabel__OBPairTemplateTint_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBRTree[] = {  {&_swigt__p_OpenBabel__OBRTree, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBRandom[] = {  {&_swigt__p_OpenBabel__OBRandom, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBResidue[] = {  {&_swigt__p_OpenBabel__OBResidue, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBResidueAtomIter[] = {  {&_swigt__p_OpenBabel__OBResidueAtomIter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBResidueData[] = {  {&_swigt__p_OpenBabel__OBResidueData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBResidueIter[] = {  {&_swigt__p_OpenBabel__OBResidueIter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBRing[] = {  {&_swigt__p_OpenBabel__OBRing, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBRingData[] = {  {&_swigt__p_OpenBabel__OBRingData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBRingSearch[] = {  {&_swigt__p_OpenBabel__OBRingSearch, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBSSMatch[] = {  {&_swigt__p_OpenBabel__OBSSMatch, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBSerialNums[] = {  {&_swigt__p_OpenBabel__OBSerialNums, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBSetData[] = {  {&_swigt__p_OpenBabel__OBSetData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBSmartsPattern[] = {  {&_swigt__p_OpenBabel__OBSmartsPattern, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBSqrtTbl[] = {  {&_swigt__p_OpenBabel__OBSqrtTbl, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBStopwatch[] = {  {&_swigt__p_OpenBabel__OBStopwatch, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBSymmetryData[] = {  {&_swigt__p_OpenBabel__OBSymmetryData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBTorsion[] = {  {&_swigt__p_OpenBabel__OBTorsion, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBTorsionData[] = {  {&_swigt__p_OpenBabel__OBTorsionData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBTypeTable[] = {  {&_swigt__p_OpenBabel__OBTypeTable, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBUnitCell[] = {  {&_swigt__p_OpenBabel__OBUnitCell, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBVibrationData[] = {  {&_swigt__p_OpenBabel__OBVibrationData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBVirtualBond[] = {  {&_swigt__p_OpenBabel__OBVirtualBond, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__Pattern[] = {  {&_swigt__p_OpenBabel__Pattern, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__PluginIterTOpenBabel__OBFingerprint_t[] = {  {&_swigt__p_OpenBabel__PluginIterTOpenBabel__OBFingerprint_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__PluginIterTOpenBabel__OBForceField_t[] = {  {&_swigt__p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__Template[] = {  {&_swigt__p_OpenBabel__Template, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__matrix3x3[] = {  {&_swigt__p_OpenBabel__matrix3x3, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__obLogBuf[] = {  {&_swigt__p_OpenBabel__obLogBuf, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__quadTOpenBabel__OBAtom_p_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_t[] = {  {&_swigt__p_OpenBabel__quadTOpenBabel__OBAtom_p_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__tripleTOpenBabel__OBAtom_p_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_t[] = {  {&_swigt__p_OpenBabel__tripleTOpenBabel__OBAtom_p_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__vector3[] = {  {&_swigt__p_OpenBabel__vector3, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_a_3__double[] = {  {&_swigt__p_a_3__double, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_a_4__char[] = {  {&_swigt__p_a_4__char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_char[] = {  {&_swigt__p_char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_double[] = {  {&_swigt__p_double, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_int[] = {  {&_swigt__p_int, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_OpenBabel__OBFormat[] = {  {&_swigt__p_p_OpenBabel__OBFormat, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_OpenBabel__OBVibrationData[] = {{&_swigt__p_p_OpenBabel__OBVibrationData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_OpenBabel__OBTorsionData[] = {{&_swigt__p_p_OpenBabel__OBTorsionData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_OpenBabel__OBPairData[] = {{&_swigt__p_p_OpenBabel__OBPairData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_OpenBabel__OBAngleData[] = {{&_swigt__p_p_OpenBabel__OBAngleData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_OpenBabel__OBChiralData[] = {{&_swigt__p_p_OpenBabel__OBChiralData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_OpenBabel__OBRingData[] = {{&_swigt__p_p_OpenBabel__OBRingData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_OpenBabel__OBSerialNums[] = {{&_swigt__p_p_OpenBabel__OBSerialNums, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_OpenBabel__OBExternalBondData[] = {{&_swigt__p_p_OpenBabel__OBExternalBondData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_OpenBabel__OBSetData[] = {{&_swigt__p_p_OpenBabel__OBSetData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_OpenBabel__OBSymmetryData[] = {{&_swigt__p_p_OpenBabel__OBSymmetryData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_OpenBabel__OBCommentData[] = {{&_swigt__p_p_OpenBabel__OBCommentData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_OpenBabel__OBVirtualBond[] = {{&_swigt__p_p_OpenBabel__OBVirtualBond, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_OpenBabel__OBConformerData[] = {{&_swigt__p_p_OpenBabel__OBConformerData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_OpenBabel__OBUnitCell[] = {{&_swigt__p_p_OpenBabel__OBUnitCell, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_OpenBabel__OBGenericData[] = {  {&_swigt__p_p_OpenBabel__OBVibrationData, _p_p_OpenBabel__OBVibrationDataTo_p_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_p_OpenBabel__OBTorsionData, _p_p_OpenBabel__OBTorsionDataTo_p_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_p_OpenBabel__OBPairData, _p_p_OpenBabel__OBPairDataTo_p_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_p_OpenBabel__OBAngleData, _p_p_OpenBabel__OBAngleDataTo_p_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_p_OpenBabel__OBChiralData, _p_p_OpenBabel__OBChiralDataTo_p_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_p_OpenBabel__OBRingData, _p_p_OpenBabel__OBRingDataTo_p_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_p_OpenBabel__OBSerialNums, _p_p_OpenBabel__OBSerialNumsTo_p_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_p_OpenBabel__OBExternalBondData, _p_p_OpenBabel__OBExternalBondDataTo_p_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_p_OpenBabel__OBSetData, _p_p_OpenBabel__OBSetDataTo_p_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_p_OpenBabel__OBSymmetryData, _p_p_OpenBabel__OBSymmetryDataTo_p_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_p_OpenBabel__OBCommentData, _p_p_OpenBabel__OBCommentDataTo_p_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_p_OpenBabel__OBVirtualBond, _p_p_OpenBabel__OBVirtualBondTo_p_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_p_OpenBabel__OBConformerData, _p_p_OpenBabel__OBConformerDataTo_p_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_p_OpenBabel__OBGenericData, 0, 0, 0},  {&_swigt__p_p_OpenBabel__OBUnitCell, _p_p_OpenBabel__OBUnitCellTo_p_p_OpenBabel__OBGenericData, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_double[] = {  {&_swigt__p_p_double, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_int[] = {  {&_swigt__p_p_int, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__dequeTint_t[] = {  {&_swigt__p_std__dequeTint_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__ifstream[] = {  {&_swigt__p_std__ifstream, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__istream[] = {  {&_swigt__p_std__istream, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__mapTchar_const_p_OpenBabel__OBFormat_p_OpenBabel__CharPtrLess_t[] = {  {&_swigt__p_std__mapTchar_const_p_OpenBabel__OBFormat_p_OpenBabel__CharPtrLess_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__mapTint_OpenBabel__OBAtom_p_t[] = {  {&_swigt__p_std__mapTint_OpenBabel__OBAtom_p_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__mapTstd__string_std__string_t[] = {  {&_swigt__p_std__mapTstd__string_std__string_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__multimapTdouble_unsigned_int_t[] = {  {&_swigt__p_std__multimapTdouble_unsigned_int_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__ostream[] = {  {&_swigt__p_std__ostream, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__out_of_range[] = {  {&_swigt__p_std__out_of_range, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__pairTOpenBabel__OBAtom_p_OpenBabel__OBAtom_p_t[] = {  {&_swigt__p_std__pairTOpenBabel__OBAtom_p_OpenBabel__OBAtom_p_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__streampos[] = {  {&_swigt__p_std__streampos, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__string[] = {  {&_swigt__p_std__string, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__type_info[] = {  {&_swigt__p_std__type_info, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTOpenBabel__OBAtom_p_t[] = {  {&_swigt__p_std__vectorTOpenBabel__OBAtom_p_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTOpenBabel__OBAtom_p_t__iterator[] = {  {&_swigt__p_std__vectorTOpenBabel__OBAtom_p_t__iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTOpenBabel__OBBond_p_t[] = {  {&_swigt__p_std__vectorTOpenBabel__OBBond_p_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTOpenBabel__OBBond_p_t__iterator[] = {  {&_swigt__p_std__vectorTOpenBabel__OBBond_p_t__iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTOpenBabel__OBBond_t[] = {  {&_swigt__p_std__vectorTOpenBabel__OBBond_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTOpenBabel__OBExternalBond_t[] = {  {&_swigt__p_std__vectorTOpenBabel__OBExternalBond_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTOpenBabel__OBGenericData_p_t[] = {  {&_swigt__p_std__vectorTOpenBabel__OBGenericData_p_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTOpenBabel__OBGenericData_p_t__iterator[] = {  {&_swigt__p_std__vectorTOpenBabel__OBGenericData_p_t__iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTOpenBabel__OBInternalCoord_p_t[] = {  {&_swigt__p_std__vectorTOpenBabel__OBInternalCoord_p_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTOpenBabel__OBInternalCoord_p_t__iterator[] = {  {&_swigt__p_std__vectorTOpenBabel__OBInternalCoord_p_t__iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTOpenBabel__OBMol_t[] = {  {&_swigt__p_std__vectorTOpenBabel__OBMol_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTOpenBabel__OBResidue_p_t__iterator[] = {  {&_swigt__p_std__vectorTOpenBabel__OBResidue_p_t__iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTOpenBabel__OBResidue_t[] = {  {&_swigt__p_std__vectorTOpenBabel__OBResidue_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTOpenBabel__OBRing_p_t[] = {  {&_swigt__p_std__vectorTOpenBabel__OBRing_p_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTOpenBabel__OBRing_p_t__iterator[] = {  {&_swigt__p_std__vectorTOpenBabel__OBRing_p_t__iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTOpenBabel__OBRing_t[] = {  {&_swigt__p_std__vectorTOpenBabel__OBRing_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTOpenBabel__OBTorsion_t[] = {  {&_swigt__p_std__vectorTOpenBabel__OBTorsion_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTOpenBabel__tripleTOpenBabel__OBAtom_p_OpenBabel__OBAtom_p_double_t_t[] = {  {&_swigt__p_std__vectorTOpenBabel__tripleTOpenBabel__OBAtom_p_OpenBabel__OBAtom_p_double_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTOpenBabel__vector3_t[] = {  {&_swigt__p_std__vectorTOpenBabel__vector3_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTdouble_p_t[] = {  {&_swigt__p_std__vectorTdouble_p_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTdouble_p_t__iterator[] = {  {&_swigt__p_std__vectorTdouble_p_t__iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTdouble_t[] = {  {&_swigt__p_std__vectorTdouble_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTint_t[] = {  {&_swigt__p_std__vectorTint_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTstd__pairTint_int_t_t[] = {  {&_swigt__p_std__vectorTstd__pairTint_int_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTstd__pairTstd__string_std__string_t_t[] = {  {&_swigt__p_std__vectorTstd__pairTstd__string_std__string_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTstd__string_t[] = {  {&_swigt__p_std__vectorTstd__string_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTstd__vectorTOpenBabel__vector3_t_t[] = {  {&_swigt__p_std__vectorTstd__vectorTOpenBabel__vector3_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTstd__vectorTint_t_t[] = {  {&_swigt__p_std__vectorTstd__vectorTint_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTstd__vectorTint_t_t__iterator[] = {  {&_swigt__p_std__vectorTstd__vectorTint_t_t__iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTstd__vectorTunsigned_int_t_t[] = {  {&_swigt__p_std__vectorTstd__vectorTunsigned_int_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTunsigned_int_t[] = {  {&_swigt__p_std__vectorTunsigned_int_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTunsigned_short_t[] = {  {&_swigt__p_std__vectorTunsigned_short_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_unsigned_int[] = {  {&_swigt__p_unsigned_int, 0, 0, 0},{0, 0, 0, 0}};

static swig_cast_info *swig_cast_initial[] = {
  _swigc__p_OpenBabel__CharPtrLess,
  _swigc__p_OpenBabel__DoubleType,
  _swigc__p_OpenBabel__FMapType__iterator,
  _swigc__p_OpenBabel__FastSearch,
  _swigc__p_OpenBabel__FastSearchIndexer,
  _swigc__p_OpenBabel__FptIndex,
  _swigc__p_OpenBabel__FptIndexHeader,
  _swigc__p_OpenBabel__OBAngle,
  _swigc__p_OpenBabel__OBAngleData,
  _swigc__p_OpenBabel__OBAromaticTyper,
  _swigc__p_OpenBabel__OBAtom,
  _swigc__p_OpenBabel__OBAtomAtomIter,
  _swigc__p_OpenBabel__OBAtomBondIter,
  _swigc__p_OpenBabel__OBAtomTyper,
  _swigc__p_OpenBabel__OBBase,
  _swigc__p_OpenBabel__OBBitVec,
  _swigc__p_OpenBabel__OBBond,
  _swigc__p_OpenBabel__OBChainsParser,
  _swigc__p_OpenBabel__OBChiralData,
  _swigc__p_OpenBabel__OBCommentData,
  _swigc__p_OpenBabel__OBConformerData,
  _swigc__p_OpenBabel__OBConversion,
  _swigc__p_OpenBabel__OBElement,
  _swigc__p_OpenBabel__OBElementTable,
  _swigc__p_OpenBabel__OBError,
  _swigc__p_OpenBabel__OBExternalBond,
  _swigc__p_OpenBabel__OBExternalBondData,
  _swigc__p_OpenBabel__OBFFCalculation,
  _swigc__p_OpenBabel__OBFFParameter,
  _swigc__p_OpenBabel__OBFingerprint,
  _swigc__p_OpenBabel__OBForceField,
  _swigc__p_OpenBabel__OBFormat,
  _swigc__p_OpenBabel__OBGenericData,
  _swigc__p_OpenBabel__OBGlobalDataBase,
  _swigc__p_OpenBabel__OBInternalCoord,
  _swigc__p_OpenBabel__OBIsotopeTable,
  _swigc__p_OpenBabel__OBMessageHandler,
  _swigc__p_OpenBabel__OBMol,
  _swigc__p_OpenBabel__OBMolAngleIter,
  _swigc__p_OpenBabel__OBMolAtomBFSIter,
  _swigc__p_OpenBabel__OBMolAtomDFSIter,
  _swigc__p_OpenBabel__OBMolAtomIter,
  _swigc__p_OpenBabel__OBMolBondIter,
  _swigc__p_OpenBabel__OBMolPairIter,
  _swigc__p_OpenBabel__OBMolRingIter,
  _swigc__p_OpenBabel__OBMolTorsionIter,
  _swigc__p_OpenBabel__OBPairData,
  _swigc__p_OpenBabel__OBPairTemplateTdouble_t,
  _swigc__p_OpenBabel__OBPairTemplateTint_t,
  _swigc__p_OpenBabel__OBRTree,
  _swigc__p_OpenBabel__OBRandom,
  _swigc__p_OpenBabel__OBResidue,
  _swigc__p_OpenBabel__OBResidueAtomIter,
  _swigc__p_OpenBabel__OBResidueData,
  _swigc__p_OpenBabel__OBResidueIter,
  _swigc__p_OpenBabel__OBRing,
  _swigc__p_OpenBabel__OBRingData,
  _swigc__p_OpenBabel__OBRingSearch,
  _swigc__p_OpenBabel__OBSSMatch,
  _swigc__p_OpenBabel__OBSerialNums,
  _swigc__p_OpenBabel__OBSetData,
  _swigc__p_OpenBabel__OBSmartsPattern,
  _swigc__p_OpenBabel__OBSqrtTbl,
  _swigc__p_OpenBabel__OBStopwatch,
  _swigc__p_OpenBabel__OBSymmetryData,
  _swigc__p_OpenBabel__OBTorsion,
  _swigc__p_OpenBabel__OBTorsionData,
  _swigc__p_OpenBabel__OBTypeTable,
  _swigc__p_OpenBabel__OBUnitCell,
  _swigc__p_OpenBabel__OBVibrationData,
  _swigc__p_OpenBabel__OBVirtualBond,
  _swigc__p_OpenBabel__Pattern,
  _swigc__p_OpenBabel__PluginIterTOpenBabel__OBFingerprint_t,
  _swigc__p_OpenBabel__PluginIterTOpenBabel__OBForceField_t,
  _swigc__p_OpenBabel__Template,
  _swigc__p_OpenBabel__matrix3x3,
  _swigc__p_OpenBabel__obLogBuf,
  _swigc__p_OpenBabel__quadTOpenBabel__OBAtom_p_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_t,
  _swigc__p_OpenBabel__tripleTOpenBabel__OBAtom_p_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_t,
  _swigc__p_OpenBabel__vector3,
  _swigc__p_a_3__double,
  _swigc__p_a_4__char,
  _swigc__p_char,
  _swigc__p_double,
  _swigc__p_int,
  _swigc__p_p_OpenBabel__OBAngleData,
  _swigc__p_p_OpenBabel__OBChiralData,
  _swigc__p_p_OpenBabel__OBCommentData,
  _swigc__p_p_OpenBabel__OBConformerData,
  _swigc__p_p_OpenBabel__OBExternalBondData,
  _swigc__p_p_OpenBabel__OBFormat,
  _swigc__p_p_OpenBabel__OBGenericData,
  _swigc__p_p_OpenBabel__OBPairData,
  _swigc__p_p_OpenBabel__OBRingData,
  _swigc__p_p_OpenBabel__OBSerialNums,
  _swigc__p_p_OpenBabel__OBSetData,
  _swigc__p_p_OpenBabel__OBSymmetryData,
  _swigc__p_p_OpenBabel__OBTorsionData,
  _swigc__p_p_OpenBabel__OBUnitCell,
  _swigc__p_p_OpenBabel__OBVibrationData,
  _swigc__p_p_OpenBabel__OBVirtualBond,
  _swigc__p_p_double,
  _swigc__p_p_int,
  _swigc__p_std__dequeTint_t,
  _swigc__p_std__ifstream,
  _swigc__p_std__istream,
  _swigc__p_std__mapTchar_const_p_OpenBabel__OBFormat_p_OpenBabel__CharPtrLess_t,
  _swigc__p_std__mapTint_OpenBabel__OBAtom_p_t,
  _swigc__p_std__mapTstd__string_std__string_t,
  _swigc__p_std__multimapTdouble_unsigned_int_t,
  _swigc__p_std__ostream,
  _swigc__p_std__out_of_range,
  _swigc__p_std__pairTOpenBabel__OBAtom_p_OpenBabel__OBAtom_p_t,
  _swigc__p_std__streampos,
  _swigc__p_std__string,
  _swigc__p_std__type_info,
  _swigc__p_std__vectorTOpenBabel__OBAtom_p_t,
  _swigc__p_std__vectorTOpenBabel__OBAtom_p_t__iterator,
  _swigc__p_std__vectorTOpenBabel__OBBond_p_t,
  _swigc__p_std__vectorTOpenBabel__OBBond_p_t__iterator,
  _swigc__p_std__vectorTOpenBabel__OBBond_t,
  _swigc__p_std__vectorTOpenBabel__OBExternalBond_t,
  _swigc__p_std__vectorTOpenBabel__OBGenericData_p_t,
  _swigc__p_std__vectorTOpenBabel__OBGenericData_p_t__iterator,
  _swigc__p_std__vectorTOpenBabel__OBInternalCoord_p_t,
  _swigc__p_std__vectorTOpenBabel__OBInternalCoord_p_t__iterator,
  _swigc__p_std__vectorTOpenBabel__OBMol_t,
  _swigc__p_std__vectorTOpenBabel__OBResidue_p_t__iterator,
  _swigc__p_std__vectorTOpenBabel__OBResidue_t,
  _swigc__p_std__vectorTOpenBabel__OBRing_p_t,
  _swigc__p_std__vectorTOpenBabel__OBRing_p_t__iterator,
  _swigc__p_std__vectorTOpenBabel__OBRing_t,
  _swigc__p_std__vectorTOpenBabel__OBTorsion_t,
  _swigc__p_std__vectorTOpenBabel__tripleTOpenBabel__OBAtom_p_OpenBabel__OBAtom_p_double_t_t,
  _swigc__p_std__vectorTOpenBabel__vector3_t,
  _swigc__p_std__vectorTdouble_p_t,
  _swigc__p_std__vectorTdouble_p_t__iterator,
  _swigc__p_std__vectorTdouble_t,
  _swigc__p_std__vectorTint_t,
  _swigc__p_std__vectorTstd__pairTint_int_t_t,
  _swigc__p_std__vectorTstd__pairTstd__string_std__string_t_t,
  _swigc__p_std__vectorTstd__string_t,
  _swigc__p_std__vectorTstd__vectorTOpenBabel__vector3_t_t,
  _swigc__p_std__vectorTstd__vectorTint_t_t,
  _swigc__p_std__vectorTstd__vectorTint_t_t__iterator,
  _swigc__p_std__vectorTstd__vectorTunsigned_int_t_t,
  _swigc__p_std__vectorTunsigned_int_t,
  _swigc__p_std__vectorTunsigned_short_t,
  _swigc__p_unsigned_int,
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */

/* -----------------------------------------------------------------------------
 * Type initialization:
 * This problem is tough by the requirement that no dynamic 
 * memory is used. Also, since swig_type_info structures store pointers to 
 * swig_cast_info structures and swig_cast_info structures store pointers back
 * to swig_type_info structures, we need some lookup code at initialization. 
 * The idea is that swig generates all the structures that are needed. 
 * The runtime then collects these partially filled structures. 
 * The SWIG_InitializeModule function takes these initial arrays out of 
 * swig_module, and does all the lookup, filling in the swig_module.types
 * array with the correct data and linking the correct swig_cast_info
 * structures together.
 *
 * The generated swig_type_info structures are assigned staticly to an initial 
 * array. We just loop through that array, and handle each type individually.
 * First we lookup if this type has been already loaded, and if so, use the
 * loaded structure instead of the generated one. Then we have to fill in the
 * cast linked list. The cast data is initially stored in something like a
 * two-dimensional array. Each row corresponds to a type (there are the same
 * number of rows as there are in the swig_type_initial array). Each entry in
 * a column is one of the swig_cast_info structures for that type.
 * The cast_initial array is actually an array of arrays, because each row has
 * a variable number of columns. So to actually build the cast linked list,
 * we find the array of casts associated with the type, and loop through it 
 * adding the casts to the list. The one last trick we need to do is making
 * sure the type pointer in the swig_cast_info struct is correct.
 *
 * First off, we lookup the cast->type name to see if it is already loaded. 
 * There are three cases to handle:
 *  1) If the cast->type has already been loaded AND the type we are adding
 *     casting info to has not been loaded (it is in this module), THEN we
 *     replace the cast->type pointer with the type pointer that has already
 *     been loaded.
 *  2) If BOTH types (the one we are adding casting info to, and the 
 *     cast->type) are loaded, THEN the cast info has already been loaded by
 *     the previous module so we just ignore it.
 *  3) Finally, if cast->type has not already been loaded, then we add that
 *     swig_cast_info to the linked list (because the cast->type) pointer will
 *     be correct.
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#if 0
} /* c-mode */
#endif
#endif

#if 0
#define SWIGRUNTIME_DEBUG
#endif


SWIGRUNTIME void
SWIG_InitializeModule(void *clientdata) {
  size_t i;
  swig_module_info *module_head, *iter;
  int found;

  clientdata = clientdata;

  /* check to see if the circular list has been setup, if not, set it up */
  if (swig_module.next==0) {
    /* Initialize the swig_module */
    swig_module.type_initial = swig_type_initial;
    swig_module.cast_initial = swig_cast_initial;
    swig_module.next = &swig_module;
  }

  /* Try and load any already created modules */
  module_head = SWIG_GetModule(clientdata);
  if (!module_head) {
    /* This is the first module loaded for this interpreter */
    /* so set the swig module into the interpreter */
    SWIG_SetModule(clientdata, &swig_module);
    module_head = &swig_module;
  } else {
    /* the interpreter has loaded a SWIG module, but has it loaded this one? */
    found=0;
    iter=module_head;
    do {
      if (iter==&swig_module) {
        found=1;
        break;
      }
      iter=iter->next;
    } while (iter!= module_head);

    /* if the is found in the list, then all is done and we may leave */
    if (found) return;
    /* otherwise we must add out module into the list */
    swig_module.next = module_head->next;
    module_head->next = &swig_module;
  }

  /* Now work on filling in swig_module.types */
#ifdef SWIGRUNTIME_DEBUG
  printf("SWIG_InitializeModule: size %d\n", swig_module.size);
#endif
  for (i = 0; i < swig_module.size; ++i) {
    swig_type_info *type = 0;
    swig_type_info *ret;
    swig_cast_info *cast;
  
#ifdef SWIGRUNTIME_DEBUG
    printf("SWIG_InitializeModule: type %d %s\n", i, swig_module.type_initial[i]->name);
#endif

    /* if there is another module already loaded */
    if (swig_module.next != &swig_module) {
      type = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, swig_module.type_initial[i]->name);
    }
    if (type) {
      /* Overwrite clientdata field */
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: found type %s\n", type->name);
#endif
      if (swig_module.type_initial[i]->clientdata) {
	type->clientdata = swig_module.type_initial[i]->clientdata;
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: found and overwrite type %s \n", type->name);
#endif
      }
    } else {
      type = swig_module.type_initial[i];
    }

    /* Insert casting types */
    cast = swig_module.cast_initial[i];
    while (cast->type) {
    
      /* Don't need to add information already in the list */
      ret = 0;
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: look cast %s\n", cast->type->name);
#endif
      if (swig_module.next != &swig_module) {
        ret = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, cast->type->name);
#ifdef SWIGRUNTIME_DEBUG
	if (ret) printf("SWIG_InitializeModule: found cast %s\n", ret->name);
#endif
      }
      if (ret) {
	if (type == swig_module.type_initial[i]) {
#ifdef SWIGRUNTIME_DEBUG
	  printf("SWIG_InitializeModule: skip old type %s\n", ret->name);
#endif
	  cast->type = ret;
	  ret = 0;
	} else {
	  /* Check for casting already in the list */
	  swig_cast_info *ocast = SWIG_TypeCheck(ret->name, type);
#ifdef SWIGRUNTIME_DEBUG
	  if (ocast) printf("SWIG_InitializeModule: skip old cast %s\n", ret->name);
#endif
	  if (!ocast) ret = 0;
	}
      }

      if (!ret) {
#ifdef SWIGRUNTIME_DEBUG
	printf("SWIG_InitializeModule: adding cast %s\n", cast->type->name);
#endif
        if (type->cast) {
          type->cast->prev = cast;
          cast->next = type->cast;
        }
        type->cast = cast;
      }
      cast++;
    }
    /* Set entry in modules->types array equal to the type */
    swig_module.types[i] = type;
  }
  swig_module.types[i] = 0;

#ifdef SWIGRUNTIME_DEBUG
  printf("**** SWIG_InitializeModule: Cast List ******\n");
  for (i = 0; i < swig_module.size; ++i) {
    int j = 0;
    swig_cast_info *cast = swig_module.cast_initial[i];
    printf("SWIG_InitializeModule: type %d %s\n", i, swig_module.type_initial[i]->name);
    while (cast->type) {
      printf("SWIG_InitializeModule: cast type %s\n", cast->type->name);
      cast++;
      ++j;
    }
  printf("---- Total casts: %d\n",j);
  }
  printf("**** SWIG_InitializeModule: Cast List ******\n");
#endif
}

/* This function will propagate the clientdata field of type to
* any new swig_type_info structures that have been added into the list
* of equivalent types.  It is like calling
* SWIG_TypeClientData(type, clientdata) a second time.
*/
SWIGRUNTIME void
SWIG_PropagateClientData(void) {
  size_t i;
  swig_cast_info *equiv;
  static int init_run = 0;

  if (init_run) return;
  init_run = 1;

  for (i = 0; i < swig_module.size; i++) {
    if (swig_module.types[i]->clientdata) {
      equiv = swig_module.types[i]->cast;
      while (equiv) {
        if (!equiv->converter) {
          if (equiv->type && !equiv->type->clientdata)
            SWIG_TypeClientData(equiv->type, swig_module.types[i]->clientdata);
        }
        equiv = equiv->next;
      }
    }
  }
}

#ifdef __cplusplus
#if 0
{ /* c-mode */
#endif
}
#endif


#ifdef __cplusplus
extern "C"
#endif
SWIGEXPORT void Init_openbabel(void) {
  size_t i;
  
  SWIG_InitRuntime();
  mOpenbabel = rb_define_module("OpenBabel");
  
  SWIG_InitializeModule(0);
  for (i = 0; i < swig_module.size; i++) {
    SWIG_define_class(swig_module.types[i]);
  }
  
  SWIG_RubyInitializeTrackings();
  
  cVectorInt.klass = rb_define_class_under(mOpenbabel, "VectorInt", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_std__vectorTint_t, (void *) &cVectorInt);
  rb_include_module(cVectorInt.klass, rb_eval_string("Enumerable"));
  rb_define_alloc_func(cVectorInt.klass, _wrap_vectorInt_allocate);
  rb_define_method(cVectorInt.klass, "initialize", VALUEFUNC(_wrap_new_vectorInt), -1);
  rb_define_method(cVectorInt.klass, "length", VALUEFUNC(_wrap_vectorInt___len__), -1);
  rb_define_method(cVectorInt.klass, "empty?", VALUEFUNC(_wrap_vectorInt_emptyq___), -1);
  rb_define_method(cVectorInt.klass, "clear", VALUEFUNC(_wrap_vectorInt_clear), -1);
  rb_define_method(cVectorInt.klass, "push", VALUEFUNC(_wrap_vectorInt_push), -1);
  rb_define_method(cVectorInt.klass, "pop", VALUEFUNC(_wrap_vectorInt_pop), -1);
  rb_define_method(cVectorInt.klass, "[]", VALUEFUNC(_wrap_vectorInt___getitem__), -1);
  rb_define_method(cVectorInt.klass, "[]=", VALUEFUNC(_wrap_vectorInt___setitem__), -1);
  rb_define_method(cVectorInt.klass, "each", VALUEFUNC(_wrap_vectorInt_each), -1);
  cVectorInt.mark = 0;
  cVectorInt.destroy = (void (*)(void *)) free_std_vector_Sl_int_Sg_;
  cVectorInt.trackObjects = 0;
  
  cVectorUnsignedInt.klass = rb_define_class_under(mOpenbabel, "VectorUnsignedInt", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_std__vectorTunsigned_int_t, (void *) &cVectorUnsignedInt);
  rb_include_module(cVectorUnsignedInt.klass, rb_eval_string("Enumerable"));
  rb_define_alloc_func(cVectorUnsignedInt.klass, _wrap_vectorUnsignedInt_allocate);
  rb_define_method(cVectorUnsignedInt.klass, "initialize", VALUEFUNC(_wrap_new_vectorUnsignedInt), -1);
  rb_define_method(cVectorUnsignedInt.klass, "length", VALUEFUNC(_wrap_vectorUnsignedInt___len__), -1);
  rb_define_method(cVectorUnsignedInt.klass, "empty?", VALUEFUNC(_wrap_vectorUnsignedInt_emptyq___), -1);
  rb_define_method(cVectorUnsignedInt.klass, "clear", VALUEFUNC(_wrap_vectorUnsignedInt_clear), -1);
  rb_define_method(cVectorUnsignedInt.klass, "push", VALUEFUNC(_wrap_vectorUnsignedInt_push), -1);
  rb_define_method(cVectorUnsignedInt.klass, "pop", VALUEFUNC(_wrap_vectorUnsignedInt_pop), -1);
  rb_define_method(cVectorUnsignedInt.klass, "[]", VALUEFUNC(_wrap_vectorUnsignedInt___getitem__), -1);
  rb_define_method(cVectorUnsignedInt.klass, "[]=", VALUEFUNC(_wrap_vectorUnsignedInt___setitem__), -1);
  rb_define_method(cVectorUnsignedInt.klass, "each", VALUEFUNC(_wrap_vectorUnsignedInt_each), -1);
  cVectorUnsignedInt.mark = 0;
  cVectorUnsignedInt.destroy = (void (*)(void *)) free_std_vector_Sl_unsigned_SS_int_Sg_;
  cVectorUnsignedInt.trackObjects = 0;
  
  cVvInt.klass = rb_define_class_under(mOpenbabel, "VvInt", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_std__vectorTstd__vectorTint_t_t, (void *) &cVvInt);
  rb_include_module(cVvInt.klass, rb_eval_string("Enumerable"));
  rb_define_alloc_func(cVvInt.klass, _wrap_vvInt_allocate);
  rb_define_method(cVvInt.klass, "initialize", VALUEFUNC(_wrap_new_vvInt), -1);
  rb_define_method(cVvInt.klass, "size", VALUEFUNC(_wrap_vvInt_size), -1);
  rb_define_method(cVvInt.klass, "empty", VALUEFUNC(_wrap_vvInt_empty), -1);
  rb_define_method(cVvInt.klass, "clear", VALUEFUNC(_wrap_vvInt_clear), -1);
  rb_define_method(cVvInt.klass, "push_back", VALUEFUNC(_wrap_vvInt_push_back), -1);
  rb_define_method(cVvInt.klass, "pop", VALUEFUNC(_wrap_vvInt_pop), -1);
  rb_define_method(cVvInt.klass, "[]", VALUEFUNC(_wrap_vvInt___getitem__), -1);
  rb_define_method(cVvInt.klass, "[]=", VALUEFUNC(_wrap_vvInt___setitem__), -1);
  rb_define_method(cVvInt.klass, "each", VALUEFUNC(_wrap_vvInt_each), -1);
  cVvInt.mark = 0;
  cVvInt.destroy = (void (*)(void *)) free_std_vector_Sl_std_vector_Sl_int_Sg__Sg_;
  cVvInt.trackObjects = 0;
  
  cVectorDouble.klass = rb_define_class_under(mOpenbabel, "VectorDouble", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_std__vectorTdouble_t, (void *) &cVectorDouble);
  rb_include_module(cVectorDouble.klass, rb_eval_string("Enumerable"));
  rb_define_alloc_func(cVectorDouble.klass, _wrap_vectorDouble_allocate);
  rb_define_method(cVectorDouble.klass, "initialize", VALUEFUNC(_wrap_new_vectorDouble), -1);
  rb_define_method(cVectorDouble.klass, "length", VALUEFUNC(_wrap_vectorDouble___len__), -1);
  rb_define_method(cVectorDouble.klass, "empty?", VALUEFUNC(_wrap_vectorDouble_emptyq___), -1);
  rb_define_method(cVectorDouble.klass, "clear", VALUEFUNC(_wrap_vectorDouble_clear), -1);
  rb_define_method(cVectorDouble.klass, "push", VALUEFUNC(_wrap_vectorDouble_push), -1);
  rb_define_method(cVectorDouble.klass, "pop", VALUEFUNC(_wrap_vectorDouble_pop), -1);
  rb_define_method(cVectorDouble.klass, "[]", VALUEFUNC(_wrap_vectorDouble___getitem__), -1);
  rb_define_method(cVectorDouble.klass, "[]=", VALUEFUNC(_wrap_vectorDouble___setitem__), -1);
  rb_define_method(cVectorDouble.klass, "each", VALUEFUNC(_wrap_vectorDouble_each), -1);
  cVectorDouble.mark = 0;
  cVectorDouble.destroy = (void (*)(void *)) free_std_vector_Sl_double_Sg_;
  cVectorDouble.trackObjects = 0;
  
  cVVector3.klass = rb_define_class_under(mOpenbabel, "VVector3", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_std__vectorTOpenBabel__vector3_t, (void *) &cVVector3);
  rb_include_module(cVVector3.klass, rb_eval_string("Enumerable"));
  rb_define_alloc_func(cVVector3.klass, _wrap_vVector3_allocate);
  rb_define_method(cVVector3.klass, "initialize", VALUEFUNC(_wrap_new_vVector3), -1);
  rb_define_method(cVVector3.klass, "size", VALUEFUNC(_wrap_vVector3_size), -1);
  rb_define_method(cVVector3.klass, "empty", VALUEFUNC(_wrap_vVector3_empty), -1);
  rb_define_method(cVVector3.klass, "clear", VALUEFUNC(_wrap_vVector3_clear), -1);
  rb_define_method(cVVector3.klass, "push_back", VALUEFUNC(_wrap_vVector3_push_back), -1);
  rb_define_method(cVVector3.klass, "pop", VALUEFUNC(_wrap_vVector3_pop), -1);
  rb_define_method(cVVector3.klass, "[]", VALUEFUNC(_wrap_vVector3___getitem__), -1);
  rb_define_method(cVVector3.klass, "[]=", VALUEFUNC(_wrap_vVector3___setitem__), -1);
  rb_define_method(cVVector3.klass, "each", VALUEFUNC(_wrap_vVector3_each), -1);
  cVVector3.mark = 0;
  cVVector3.destroy = (void (*)(void *)) free_std_vector_Sl_OpenBabel_vector3_Sg_;
  cVVector3.trackObjects = 0;
  
  cVectorMol.klass = rb_define_class_under(mOpenbabel, "VectorMol", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_std__vectorTOpenBabel__OBMol_t, (void *) &cVectorMol);
  rb_include_module(cVectorMol.klass, rb_eval_string("Enumerable"));
  rb_define_alloc_func(cVectorMol.klass, _wrap_vectorMol_allocate);
  rb_define_method(cVectorMol.klass, "initialize", VALUEFUNC(_wrap_new_vectorMol), -1);
  rb_define_method(cVectorMol.klass, "size", VALUEFUNC(_wrap_vectorMol_size), -1);
  rb_define_method(cVectorMol.klass, "empty", VALUEFUNC(_wrap_vectorMol_empty), -1);
  rb_define_method(cVectorMol.klass, "clear", VALUEFUNC(_wrap_vectorMol_clear), -1);
  rb_define_method(cVectorMol.klass, "push_back", VALUEFUNC(_wrap_vectorMol_push_back), -1);
  rb_define_method(cVectorMol.klass, "pop", VALUEFUNC(_wrap_vectorMol_pop), -1);
  rb_define_method(cVectorMol.klass, "[]", VALUEFUNC(_wrap_vectorMol___getitem__), -1);
  rb_define_method(cVectorMol.klass, "[]=", VALUEFUNC(_wrap_vectorMol___setitem__), -1);
  rb_define_method(cVectorMol.klass, "each", VALUEFUNC(_wrap_vectorMol_each), -1);
  cVectorMol.mark = 0;
  cVectorMol.destroy = (void (*)(void *)) free_std_vector_Sl_OpenBabel_OBMol_Sg_;
  cVectorMol.trackObjects = 0;
  
  cVectorBond.klass = rb_define_class_under(mOpenbabel, "VectorBond", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_std__vectorTOpenBabel__OBBond_t, (void *) &cVectorBond);
  rb_include_module(cVectorBond.klass, rb_eval_string("Enumerable"));
  rb_define_alloc_func(cVectorBond.klass, _wrap_vectorBond_allocate);
  rb_define_method(cVectorBond.klass, "initialize", VALUEFUNC(_wrap_new_vectorBond), -1);
  rb_define_method(cVectorBond.klass, "size", VALUEFUNC(_wrap_vectorBond_size), -1);
  rb_define_method(cVectorBond.klass, "empty", VALUEFUNC(_wrap_vectorBond_empty), -1);
  rb_define_method(cVectorBond.klass, "clear", VALUEFUNC(_wrap_vectorBond_clear), -1);
  rb_define_method(cVectorBond.klass, "push_back", VALUEFUNC(_wrap_vectorBond_push_back), -1);
  rb_define_method(cVectorBond.klass, "pop", VALUEFUNC(_wrap_vectorBond_pop), -1);
  rb_define_method(cVectorBond.klass, "[]", VALUEFUNC(_wrap_vectorBond___getitem__), -1);
  rb_define_method(cVectorBond.klass, "[]=", VALUEFUNC(_wrap_vectorBond___setitem__), -1);
  rb_define_method(cVectorBond.klass, "each", VALUEFUNC(_wrap_vectorBond_each), -1);
  cVectorBond.mark = 0;
  cVectorBond.destroy = (void (*)(void *)) free_std_vector_Sl_OpenBabel_OBBond_Sg_;
  cVectorBond.trackObjects = 0;
  
  cVectorResidue.klass = rb_define_class_under(mOpenbabel, "VectorResidue", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_std__vectorTOpenBabel__OBResidue_t, (void *) &cVectorResidue);
  rb_include_module(cVectorResidue.klass, rb_eval_string("Enumerable"));
  rb_define_alloc_func(cVectorResidue.klass, _wrap_vectorResidue_allocate);
  rb_define_method(cVectorResidue.klass, "initialize", VALUEFUNC(_wrap_new_vectorResidue), -1);
  rb_define_method(cVectorResidue.klass, "size", VALUEFUNC(_wrap_vectorResidue_size), -1);
  rb_define_method(cVectorResidue.klass, "empty", VALUEFUNC(_wrap_vectorResidue_empty), -1);
  rb_define_method(cVectorResidue.klass, "clear", VALUEFUNC(_wrap_vectorResidue_clear), -1);
  rb_define_method(cVectorResidue.klass, "push_back", VALUEFUNC(_wrap_vectorResidue_push_back), -1);
  rb_define_method(cVectorResidue.klass, "pop", VALUEFUNC(_wrap_vectorResidue_pop), -1);
  rb_define_method(cVectorResidue.klass, "[]", VALUEFUNC(_wrap_vectorResidue___getitem__), -1);
  rb_define_method(cVectorResidue.klass, "[]=", VALUEFUNC(_wrap_vectorResidue___setitem__), -1);
  rb_define_method(cVectorResidue.klass, "each", VALUEFUNC(_wrap_vectorResidue_each), -1);
  cVectorResidue.mark = 0;
  cVectorResidue.destroy = (void (*)(void *)) free_std_vector_Sl_OpenBabel_OBResidue_Sg_;
  cVectorResidue.trackObjects = 0;
  
  cVectorRing.klass = rb_define_class_under(mOpenbabel, "VectorRing", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_std__vectorTOpenBabel__OBRing_t, (void *) &cVectorRing);
  rb_include_module(cVectorRing.klass, rb_eval_string("Enumerable"));
  rb_define_alloc_func(cVectorRing.klass, _wrap_vectorRing_allocate);
  rb_define_method(cVectorRing.klass, "initialize", VALUEFUNC(_wrap_new_vectorRing), -1);
  rb_define_method(cVectorRing.klass, "size", VALUEFUNC(_wrap_vectorRing_size), -1);
  rb_define_method(cVectorRing.klass, "empty", VALUEFUNC(_wrap_vectorRing_empty), -1);
  rb_define_method(cVectorRing.klass, "clear", VALUEFUNC(_wrap_vectorRing_clear), -1);
  rb_define_method(cVectorRing.klass, "push_back", VALUEFUNC(_wrap_vectorRing_push_back), -1);
  rb_define_method(cVectorRing.klass, "pop", VALUEFUNC(_wrap_vectorRing_pop), -1);
  rb_define_method(cVectorRing.klass, "[]", VALUEFUNC(_wrap_vectorRing___getitem__), -1);
  rb_define_method(cVectorRing.klass, "[]=", VALUEFUNC(_wrap_vectorRing___setitem__), -1);
  rb_define_method(cVectorRing.klass, "each", VALUEFUNC(_wrap_vectorRing_each), -1);
  cVectorRing.mark = 0;
  cVectorRing.destroy = (void (*)(void *)) free_std_vector_Sl_OpenBabel_OBRing_Sg_;
  cVectorRing.trackObjects = 0;
  
  cVectorData.klass = rb_define_class_under(mOpenbabel, "VectorData", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_std__vectorTOpenBabel__OBGenericData_p_t, (void *) &cVectorData);
  rb_include_module(cVectorData.klass, rb_eval_string("Enumerable"));
  rb_define_alloc_func(cVectorData.klass, _wrap_vectorData_allocate);
  rb_define_method(cVectorData.klass, "initialize", VALUEFUNC(_wrap_new_vectorData), -1);
  rb_define_method(cVectorData.klass, "size", VALUEFUNC(_wrap_vectorData_size), -1);
  rb_define_method(cVectorData.klass, "empty", VALUEFUNC(_wrap_vectorData_empty), -1);
  rb_define_method(cVectorData.klass, "clear", VALUEFUNC(_wrap_vectorData_clear), -1);
  rb_define_method(cVectorData.klass, "push_back", VALUEFUNC(_wrap_vectorData_push_back), -1);
  rb_define_method(cVectorData.klass, "pop", VALUEFUNC(_wrap_vectorData_pop), -1);
  rb_define_method(cVectorData.klass, "[]", VALUEFUNC(_wrap_vectorData___getitem__), -1);
  rb_define_method(cVectorData.klass, "[]=", VALUEFUNC(_wrap_vectorData___setitem__), -1);
  rb_define_method(cVectorData.klass, "each", VALUEFUNC(_wrap_vectorData_each), -1);
  cVectorData.mark = 0;
  cVectorData.destroy = (void (*)(void *)) free_std_vector_Sl_OpenBabel_OBGenericData_Sm__Sg_;
  cVectorData.trackObjects = 0;
  
  cOBGlobalDataBase.klass = rb_define_class_under(mOpenbabel, "OBGlobalDataBase", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBGlobalDataBase, (void *) &cOBGlobalDataBase);
  rb_define_alloc_func(cOBGlobalDataBase.klass, _wrap_OBGlobalDataBase_allocate);
  rb_define_method(cOBGlobalDataBase.klass, "initialize", VALUEFUNC(_wrap_new_OBGlobalDataBase), -1);
  rb_define_method(cOBGlobalDataBase.klass, "init", VALUEFUNC(_wrap_OBGlobalDataBase_init), -1);
  rb_define_method(cOBGlobalDataBase.klass, "get_size", VALUEFUNC(_wrap_OBGlobalDataBase_get_size), -1);
  rb_define_method(cOBGlobalDataBase.klass, "set_read_directory", VALUEFUNC(_wrap_OBGlobalDataBase_set_read_directory), -1);
  rb_define_method(cOBGlobalDataBase.klass, "set_environment_variable", VALUEFUNC(_wrap_OBGlobalDataBase_set_environment_variable), -1);
  rb_define_method(cOBGlobalDataBase.klass, "parse_line", VALUEFUNC(_wrap_OBGlobalDataBase_parse_line), -1);
  cOBGlobalDataBase.mark = 0;
  cOBGlobalDataBase.destroy = (void (*)(void *)) free_OpenBabel_OBGlobalDataBase;
  cOBGlobalDataBase.trackObjects = 0;
  
  cOBElement.klass = rb_define_class_under(mOpenbabel, "OBElement", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBElement, (void *) &cOBElement);
  rb_define_alloc_func(cOBElement.klass, _wrap_OBElement_allocate);
  rb_define_method(cOBElement.klass, "initialize", VALUEFUNC(_wrap_new_OBElement), -1);
  rb_define_method(cOBElement.klass, "get_atomic_num", VALUEFUNC(_wrap_OBElement_get_atomic_num), -1);
  rb_define_method(cOBElement.klass, "get_symbol", VALUEFUNC(_wrap_OBElement_get_symbol), -1);
  rb_define_method(cOBElement.klass, "get_covalent_rad", VALUEFUNC(_wrap_OBElement_get_covalent_rad), -1);
  rb_define_method(cOBElement.klass, "get_vdw_rad", VALUEFUNC(_wrap_OBElement_get_vdw_rad), -1);
  rb_define_method(cOBElement.klass, "get_mass", VALUEFUNC(_wrap_OBElement_get_mass), -1);
  rb_define_method(cOBElement.klass, "get_max_bonds", VALUEFUNC(_wrap_OBElement_get_max_bonds), -1);
  rb_define_method(cOBElement.klass, "get_electro_neg", VALUEFUNC(_wrap_OBElement_get_electro_neg), -1);
  rb_define_method(cOBElement.klass, "get_ionization", VALUEFUNC(_wrap_OBElement_get_ionization), -1);
  rb_define_method(cOBElement.klass, "get_electron_affinity", VALUEFUNC(_wrap_OBElement_get_electron_affinity), -1);
  rb_define_method(cOBElement.klass, "get_name", VALUEFUNC(_wrap_OBElement_get_name), -1);
  rb_define_method(cOBElement.klass, "get_red", VALUEFUNC(_wrap_OBElement_get_red), -1);
  rb_define_method(cOBElement.klass, "get_green", VALUEFUNC(_wrap_OBElement_get_green), -1);
  rb_define_method(cOBElement.klass, "get_blue", VALUEFUNC(_wrap_OBElement_get_blue), -1);
  cOBElement.mark = 0;
  cOBElement.destroy = (void (*)(void *)) free_OpenBabel_OBElement;
  cOBElement.trackObjects = 0;
  
  cOBElementTable.klass = rb_define_class_under(mOpenbabel, "OBElementTable", ((swig_class *) SWIGTYPE_p_OpenBabel__OBGlobalDataBase->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBElementTable, (void *) &cOBElementTable);
  rb_define_alloc_func(cOBElementTable.klass, _wrap_OBElementTable_allocate);
  rb_define_method(cOBElementTable.klass, "initialize", VALUEFUNC(_wrap_new_OBElementTable), -1);
  rb_define_method(cOBElementTable.klass, "parse_line", VALUEFUNC(_wrap_OBElementTable_parse_line), -1);
  rb_define_method(cOBElementTable.klass, "get_number_of_elements", VALUEFUNC(_wrap_OBElementTable_get_number_of_elements), -1);
  rb_define_method(cOBElementTable.klass, "get_size", VALUEFUNC(_wrap_OBElementTable_get_size), -1);
  rb_define_method(cOBElementTable.klass, "get_atomic_num", VALUEFUNC(_wrap_OBElementTable_get_atomic_num), -1);
  rb_define_method(cOBElementTable.klass, "get_symbol", VALUEFUNC(_wrap_OBElementTable_get_symbol), -1);
  rb_define_method(cOBElementTable.klass, "get_vdw_rad", VALUEFUNC(_wrap_OBElementTable_get_vdw_rad), -1);
  rb_define_method(cOBElementTable.klass, "get_covalent_rad", VALUEFUNC(_wrap_OBElementTable_get_covalent_rad), -1);
  rb_define_method(cOBElementTable.klass, "get_mass", VALUEFUNC(_wrap_OBElementTable_get_mass), -1);
  rb_define_method(cOBElementTable.klass, "corrected_bond_rad", VALUEFUNC(_wrap_OBElementTable_corrected_bond_rad), -1);
  rb_define_method(cOBElementTable.klass, "corrected_vdw_rad", VALUEFUNC(_wrap_OBElementTable_corrected_vdw_rad), -1);
  rb_define_method(cOBElementTable.klass, "get_max_bonds", VALUEFUNC(_wrap_OBElementTable_get_max_bonds), -1);
  rb_define_method(cOBElementTable.klass, "get_electro_neg", VALUEFUNC(_wrap_OBElementTable_get_electro_neg), -1);
  rb_define_method(cOBElementTable.klass, "get_ionization", VALUEFUNC(_wrap_OBElementTable_get_ionization), -1);
  rb_define_method(cOBElementTable.klass, "get_electron_affinity", VALUEFUNC(_wrap_OBElementTable_get_electron_affinity), -1);
  rb_define_method(cOBElementTable.klass, "get_rgb", VALUEFUNC(_wrap_OBElementTable_get_rgb), -1);
  rb_define_method(cOBElementTable.klass, "get_name", VALUEFUNC(_wrap_OBElementTable_get_name), -1);
  cOBElementTable.mark = 0;
  cOBElementTable.destroy = (void (*)(void *)) free_OpenBabel_OBElementTable;
  cOBElementTable.trackObjects = 0;
  
  cOBIsotopeTable.klass = rb_define_class_under(mOpenbabel, "OBIsotopeTable", ((swig_class *) SWIGTYPE_p_OpenBabel__OBGlobalDataBase->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBIsotopeTable, (void *) &cOBIsotopeTable);
  rb_define_alloc_func(cOBIsotopeTable.klass, _wrap_OBIsotopeTable_allocate);
  rb_define_method(cOBIsotopeTable.klass, "initialize", VALUEFUNC(_wrap_new_OBIsotopeTable), -1);
  rb_define_method(cOBIsotopeTable.klass, "get_size", VALUEFUNC(_wrap_OBIsotopeTable_get_size), -1);
  rb_define_method(cOBIsotopeTable.klass, "parse_line", VALUEFUNC(_wrap_OBIsotopeTable_parse_line), -1);
  rb_define_method(cOBIsotopeTable.klass, "get_exact_mass", VALUEFUNC(_wrap_OBIsotopeTable_get_exact_mass), -1);
  cOBIsotopeTable.mark = 0;
  cOBIsotopeTable.destroy = (void (*)(void *)) free_OpenBabel_OBIsotopeTable;
  cOBIsotopeTable.trackObjects = 0;
  
  cOBTypeTable.klass = rb_define_class_under(mOpenbabel, "OBTypeTable", ((swig_class *) SWIGTYPE_p_OpenBabel__OBGlobalDataBase->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBTypeTable, (void *) &cOBTypeTable);
  rb_define_alloc_func(cOBTypeTable.klass, _wrap_OBTypeTable_allocate);
  rb_define_method(cOBTypeTable.klass, "initialize", VALUEFUNC(_wrap_new_OBTypeTable), -1);
  rb_define_method(cOBTypeTable.klass, "parse_line", VALUEFUNC(_wrap_OBTypeTable_parse_line), -1);
  rb_define_method(cOBTypeTable.klass, "get_size", VALUEFUNC(_wrap_OBTypeTable_get_size), -1);
  rb_define_method(cOBTypeTable.klass, "set_from_type", VALUEFUNC(_wrap_OBTypeTable_set_from_type), -1);
  rb_define_method(cOBTypeTable.klass, "set_to_type", VALUEFUNC(_wrap_OBTypeTable_set_to_type), -1);
  rb_define_method(cOBTypeTable.klass, "translate", VALUEFUNC(_wrap_OBTypeTable_translate), -1);
  rb_define_method(cOBTypeTable.klass, "get_from_type", VALUEFUNC(_wrap_OBTypeTable_get_from_type), -1);
  rb_define_method(cOBTypeTable.klass, "get_to_type", VALUEFUNC(_wrap_OBTypeTable_get_to_type), -1);
  cOBTypeTable.mark = 0;
  cOBTypeTable.destroy = (void (*)(void *)) free_OpenBabel_OBTypeTable;
  cOBTypeTable.trackObjects = 0;
  
  cOBResidueData.klass = rb_define_class_under(mOpenbabel, "OBResidueData", ((swig_class *) SWIGTYPE_p_OpenBabel__OBGlobalDataBase->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBResidueData, (void *) &cOBResidueData);
  rb_define_alloc_func(cOBResidueData.klass, _wrap_OBResidueData_allocate);
  rb_define_method(cOBResidueData.klass, "initialize", VALUEFUNC(_wrap_new_OBResidueData), -1);
  rb_define_method(cOBResidueData.klass, "parse_line", VALUEFUNC(_wrap_OBResidueData_parse_line), -1);
  rb_define_method(cOBResidueData.klass, "get_size", VALUEFUNC(_wrap_OBResidueData_get_size), -1);
  rb_define_method(cOBResidueData.klass, "set_res_name", VALUEFUNC(_wrap_OBResidueData_set_res_name), -1);
  rb_define_method(cOBResidueData.klass, "lookup_bo", VALUEFUNC(_wrap_OBResidueData_lookup_bo), -1);
  rb_define_method(cOBResidueData.klass, "lookup_type", VALUEFUNC(_wrap_OBResidueData_lookup_type), -1);
  rb_define_method(cOBResidueData.klass, "assign_bonds", VALUEFUNC(_wrap_OBResidueData_assign_bonds), -1);
  cOBResidueData.mark = 0;
  cOBResidueData.destroy = (void (*)(void *)) free_OpenBabel_OBResidueData;
  cOBResidueData.trackObjects = 0;
  rb_define_module_function(mOpenbabel, "open_datafile", VALUEFUNC(_wrap_open_datafile), -1);
  rb_define_const(mOpenbabel, "FILE_SEP_CHAR", SWIG_FromCharPtr("/"));
  
  cDoubleType.klass = rb_define_class_under(mOpenbabel, "DoubleType", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__DoubleType, (void *) &cDoubleType);
  rb_define_alloc_func(cDoubleType.klass, _wrap_DoubleType_allocate);
  rb_define_method(cDoubleType.klass, "initialize", VALUEFUNC(_wrap_new_DoubleType), -1);
  rb_define_method(cDoubleType.klass, "hi=", VALUEFUNC(_wrap_DoubleType_hi_set), -1);
  rb_define_method(cDoubleType.klass, "hi", VALUEFUNC(_wrap_DoubleType_hi_get), -1);
  rb_define_method(cDoubleType.klass, "lo=", VALUEFUNC(_wrap_DoubleType_lo_set), -1);
  rb_define_method(cDoubleType.klass, "lo", VALUEFUNC(_wrap_DoubleType_lo_get), -1);
  cDoubleType.mark = 0;
  cDoubleType.destroy = (void (*)(void *)) free_OpenBabel_DoubleType;
  cDoubleType.trackObjects = 0;
  rb_define_module_function(mOpenbabel, "double_multiply", VALUEFUNC(_wrap_double_multiply), -1);
  rb_define_module_function(mOpenbabel, "double_add", VALUEFUNC(_wrap_double_add), -1);
  rb_define_module_function(mOpenbabel, "double_modulus", VALUEFUNC(_wrap_double_modulus), -1);
  
  cOBRandom.klass = rb_define_class_under(mOpenbabel, "OBRandom", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBRandom, (void *) &cOBRandom);
  rb_define_alloc_func(cOBRandom.klass, _wrap_OBRandom_allocate);
  rb_define_method(cOBRandom.klass, "initialize", VALUEFUNC(_wrap_new_OBRandom), -1);
  rb_define_method(cOBRandom.klass, "seed", VALUEFUNC(_wrap_OBRandom_seed), -1);
  rb_define_method(cOBRandom.klass, "time_seed", VALUEFUNC(_wrap_OBRandom_time_seed), -1);
  rb_define_method(cOBRandom.klass, "next_int", VALUEFUNC(_wrap_OBRandom_next_int), -1);
  rb_define_method(cOBRandom.klass, "next_float", VALUEFUNC(_wrap_OBRandom_next_float), -1);
  cOBRandom.mark = 0;
  cOBRandom.destroy = (void (*)(void *)) free_OpenBabel_OBRandom;
  cOBRandom.trackObjects = 0;
  rb_define_const(mOpenbabel, "M_PI", SWIG_From_double(static_cast< double >(3.14159265358979323846)));
  
  cOBStopwatch.klass = rb_define_class_under(mOpenbabel, "OBStopwatch", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBStopwatch, (void *) &cOBStopwatch);
  rb_define_alloc_func(cOBStopwatch.klass, _wrap_OBStopwatch_allocate);
  rb_define_method(cOBStopwatch.klass, "initialize", VALUEFUNC(_wrap_new_OBStopwatch), -1);
  rb_define_method(cOBStopwatch.klass, "start", VALUEFUNC(_wrap_OBStopwatch_start), -1);
  rb_define_method(cOBStopwatch.klass, "lap", VALUEFUNC(_wrap_OBStopwatch_lap), -1);
  rb_define_method(cOBStopwatch.klass, "elapsed", VALUEFUNC(_wrap_OBStopwatch_elapsed), -1);
  cOBStopwatch.mark = 0;
  cOBStopwatch.destroy = (void (*)(void *)) free_OpenBabel_OBStopwatch;
  cOBStopwatch.trackObjects = 0;
  
  cOBSqrtTbl.klass = rb_define_class_under(mOpenbabel, "OBSqrtTbl", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBSqrtTbl, (void *) &cOBSqrtTbl);
  rb_define_alloc_func(cOBSqrtTbl.klass, _wrap_OBSqrtTbl_allocate);
  rb_define_method(cOBSqrtTbl.klass, "initialize", VALUEFUNC(_wrap_new_OBSqrtTbl), -1);
  rb_define_method(cOBSqrtTbl.klass, "sqrt", VALUEFUNC(_wrap_OBSqrtTbl_sqrt), -1);
  rb_define_method(cOBSqrtTbl.klass, "init", VALUEFUNC(_wrap_OBSqrtTbl_init), -1);
  cOBSqrtTbl.mark = 0;
  cOBSqrtTbl.destroy = (void (*)(void *)) free_OpenBabel_OBSqrtTbl;
  cOBSqrtTbl.trackObjects = 0;
  rb_define_const(mOpenbabel, "RAD_TO_DEG", SWIG_From_double(static_cast< double >((180.0/3.14159265358979323846))));
  rb_define_const(mOpenbabel, "DEG_TO_RAD", SWIG_From_double(static_cast< double >((3.14159265358979323846/180.0))));
  
  cVector3.klass = rb_define_class_under(mOpenbabel, "Vector3", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__vector3, (void *) &cVector3);
  rb_define_alloc_func(cVector3.klass, _wrap_Vector3_allocate);
  rb_define_method(cVector3.klass, "initialize", VALUEFUNC(_wrap_new_Vector3), -1);
  rb_define_method(cVector3.klass, "set", VALUEFUNC(_wrap_Vector3_set), -1);
  rb_define_method(cVector3.klass, "set_x", VALUEFUNC(_wrap_Vector3_set_x), -1);
  rb_define_method(cVector3.klass, "set_y", VALUEFUNC(_wrap_Vector3_set_y), -1);
  rb_define_method(cVector3.klass, "set_z", VALUEFUNC(_wrap_Vector3_set_z), -1);
  rb_define_method(cVector3.klass, "get", VALUEFUNC(_wrap_Vector3_get), -1);
  rb_define_method(cVector3.klass, "as_array", VALUEFUNC(_wrap_Vector3_as_array), -1);
  rb_define_method(cVector3.klass, "random_unit_vector", VALUEFUNC(_wrap_Vector3_random_unit_vector), -1);
  rb_define_method(cVector3.klass, "normalize", VALUEFUNC(_wrap_Vector3_normalize), -1);
  rb_define_method(cVector3.klass, "can_be_normalized", VALUEFUNC(_wrap_Vector3_can_be_normalized), -1);
  rb_define_method(cVector3.klass, "length_2", VALUEFUNC(_wrap_Vector3_length_2), -1);
  rb_define_method(cVector3.klass, "length", VALUEFUNC(_wrap_Vector3_length), -1);
  rb_define_method(cVector3.klass, "x", VALUEFUNC(_wrap_Vector3_x), -1);
  rb_define_method(cVector3.klass, "y", VALUEFUNC(_wrap_Vector3_y), -1);
  rb_define_method(cVector3.klass, "z", VALUEFUNC(_wrap_Vector3_z), -1);
  rb_define_method(cVector3.klass, "==", VALUEFUNC(_wrap_Vector3___eq__), -1);
  rb_define_method(cVector3.klass, "is_approx", VALUEFUNC(_wrap_Vector3_is_approx), -1);
  rb_define_method(cVector3.klass, "dist_sq", VALUEFUNC(_wrap_Vector3_dist_sq), -1);
  rb_define_method(cVector3.klass, "create_ortho_vector", VALUEFUNC(_wrap_Vector3_create_ortho_vector), -1);
  cVector3.mark = 0;
  cVector3.destroy = (void (*)(void *)) free_OpenBabel_vector3;
  cVector3.trackObjects = 0;
  rb_define_module_function(mOpenbabel, "<<", VALUEFUNC(_wrap___lshift__), -1);
  rb_define_module_function(mOpenbabel, "+", VALUEFUNC(_wrap___add__), -1);
  rb_define_module_function(mOpenbabel, "-", VALUEFUNC(_wrap___sub__), -1);
  rb_define_module_function(mOpenbabel, "/", VALUEFUNC(_wrap___div__), -1);
  rb_define_module_function(mOpenbabel, "*", VALUEFUNC(_wrap___mul__), -1);
  rb_define_module_function(mOpenbabel, "dot", VALUEFUNC(_wrap_dot), -1);
  rb_define_module_function(mOpenbabel, "cross", VALUEFUNC(_wrap_cross), -1);
  rb_define_module_function(mOpenbabel, "vector_angle", VALUEFUNC(_wrap_vector_angle), -1);
  rb_define_module_function(mOpenbabel, "calc_torsion_angle", VALUEFUNC(_wrap_calc_torsion_angle), -1);
  rb_define_module_function(mOpenbabel, "point_2plane", VALUEFUNC(_wrap_point_2plane), -1);
  rb_define_module_function(mOpenbabel, "point_2plane_angle", VALUEFUNC(_wrap_point_2plane_angle), -1);
  rb_define_singleton_method(mOpenbabel, "VZero", VALUEFUNC(VZero_get), 0);
  rb_define_singleton_method(mOpenbabel, "VX", VALUEFUNC(VX_get), 0);
  rb_define_singleton_method(mOpenbabel, "VY", VALUEFUNC(VY_get), 0);
  rb_define_singleton_method(mOpenbabel, "VZ", VALUEFUNC(VZ_get), 0);
  rb_define_module_function(mOpenbabel, "trim", VALUEFUNC(_wrap_trim), -1);
  rb_define_const(mOpenbabel, "UndefinedData", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::UndefinedData)));
  rb_define_const(mOpenbabel, "PairData", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::PairData)));
  rb_define_const(mOpenbabel, "EnergyData", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::EnergyData)));
  rb_define_const(mOpenbabel, "CommentData", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::CommentData)));
  rb_define_const(mOpenbabel, "ConformerData", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::ConformerData)));
  rb_define_const(mOpenbabel, "ExternalBondData", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::ExternalBondData)));
  rb_define_const(mOpenbabel, "RotamerList", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::RotamerList)));
  rb_define_const(mOpenbabel, "VirtualBondData", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::VirtualBondData)));
  rb_define_const(mOpenbabel, "RingData", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::RingData)));
  rb_define_const(mOpenbabel, "TorsionData", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::TorsionData)));
  rb_define_const(mOpenbabel, "AngleData", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::AngleData)));
  rb_define_const(mOpenbabel, "SerialNums", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::SerialNums)));
  rb_define_const(mOpenbabel, "UnitCell", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::UnitCell)));
  rb_define_const(mOpenbabel, "SpinData", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::SpinData)));
  rb_define_const(mOpenbabel, "ChargeData", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::ChargeData)));
  rb_define_const(mOpenbabel, "SymmetryData", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::SymmetryData)));
  rb_define_const(mOpenbabel, "ChiralData", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::ChiralData)));
  rb_define_const(mOpenbabel, "OccupationData", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::OccupationData)));
  rb_define_const(mOpenbabel, "DensityData", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::DensityData)));
  rb_define_const(mOpenbabel, "ElectronicData", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::ElectronicData)));
  rb_define_const(mOpenbabel, "VibrationData", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::VibrationData)));
  rb_define_const(mOpenbabel, "RotationData", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::RotationData)));
  rb_define_const(mOpenbabel, "NuclearData", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::NuclearData)));
  rb_define_const(mOpenbabel, "SetData", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::SetData)));
  rb_define_const(mOpenbabel, "CustomData0", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::CustomData0)));
  rb_define_const(mOpenbabel, "CustomData1", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::CustomData1)));
  rb_define_const(mOpenbabel, "CustomData2", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::CustomData2)));
  rb_define_const(mOpenbabel, "CustomData3", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::CustomData3)));
  rb_define_const(mOpenbabel, "CustomData4", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::CustomData4)));
  rb_define_const(mOpenbabel, "CustomData5", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::CustomData5)));
  rb_define_const(mOpenbabel, "CustomData6", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::CustomData6)));
  rb_define_const(mOpenbabel, "CustomData7", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::CustomData7)));
  rb_define_const(mOpenbabel, "CustomData8", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::CustomData8)));
  rb_define_const(mOpenbabel, "CustomData9", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::CustomData9)));
  rb_define_const(mOpenbabel, "CustomData10", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::CustomData10)));
  rb_define_const(mOpenbabel, "CustomData11", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::CustomData11)));
  rb_define_const(mOpenbabel, "CustomData12", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::CustomData12)));
  rb_define_const(mOpenbabel, "CustomData13", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::CustomData13)));
  rb_define_const(mOpenbabel, "CustomData14", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::CustomData14)));
  rb_define_const(mOpenbabel, "CustomData15", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::CustomData15)));
  rb_define_const(mOpenbabel, "Any", SWIG_From_int(static_cast< int >(OpenBabel::any)));
  rb_define_const(mOpenbabel, "FileformatInput", SWIG_From_int(static_cast< int >(OpenBabel::fileformatInput)));
  rb_define_const(mOpenbabel, "UserInput", SWIG_From_int(static_cast< int >(OpenBabel::userInput)));
  rb_define_const(mOpenbabel, "Perceived", SWIG_From_int(static_cast< int >(OpenBabel::perceived)));
  rb_define_const(mOpenbabel, "External", SWIG_From_int(static_cast< int >(OpenBabel::external)));
  
  cOBGenericData.klass = rb_define_class_under(mOpenbabel, "OBGenericData", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBGenericData, (void *) &cOBGenericData);
  rb_define_alloc_func(cOBGenericData.klass, _wrap_OBGenericData_allocate);
  rb_define_method(cOBGenericData.klass, "initialize", VALUEFUNC(_wrap_new_OBGenericData), -1);
  rb_define_method(cOBGenericData.klass, "clone", VALUEFUNC(_wrap_OBGenericData_clone), -1);
  rb_define_method(cOBGenericData.klass, "set_attribute", VALUEFUNC(_wrap_OBGenericData_set_attribute), -1);
  rb_define_method(cOBGenericData.klass, "set_origin", VALUEFUNC(_wrap_OBGenericData_set_origin), -1);
  rb_define_method(cOBGenericData.klass, "get_attribute", VALUEFUNC(_wrap_OBGenericData_get_attribute), -1);
  rb_define_method(cOBGenericData.klass, "get_data_type", VALUEFUNC(_wrap_OBGenericData_get_data_type), -1);
  rb_define_method(cOBGenericData.klass, "get_value", VALUEFUNC(_wrap_OBGenericData_get_value), -1);
  rb_define_method(cOBGenericData.klass, "get_origin", VALUEFUNC(_wrap_OBGenericData_get_origin), -1);
  cOBGenericData.mark = 0;
  cOBGenericData.destroy = (void (*)(void *)) free_OpenBabel_OBGenericData;
  cOBGenericData.trackObjects = 0;
  
  cOBCommentData.klass = rb_define_class_under(mOpenbabel, "OBCommentData", ((swig_class *) SWIGTYPE_p_OpenBabel__OBGenericData->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBCommentData, (void *) &cOBCommentData);
  rb_define_alloc_func(cOBCommentData.klass, _wrap_OBCommentData_allocate);
  rb_define_method(cOBCommentData.klass, "initialize", VALUEFUNC(_wrap_new_OBCommentData), -1);
  rb_define_method(cOBCommentData.klass, "clone", VALUEFUNC(_wrap_OBCommentData_clone), -1);
  rb_define_method(cOBCommentData.klass, "set_data", VALUEFUNC(_wrap_OBCommentData_set_data), -1);
  rb_define_method(cOBCommentData.klass, "get_data", VALUEFUNC(_wrap_OBCommentData_get_data), -1);
  rb_define_method(cOBCommentData.klass, "get_value", VALUEFUNC(_wrap_OBCommentData_get_value), -1);
  cOBCommentData.mark = 0;
  cOBCommentData.destroy = (void (*)(void *)) free_OpenBabel_OBCommentData;
  cOBCommentData.trackObjects = 0;
  
  cOBExternalBond.klass = rb_define_class_under(mOpenbabel, "OBExternalBond", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBExternalBond, (void *) &cOBExternalBond);
  rb_define_alloc_func(cOBExternalBond.klass, _wrap_OBExternalBond_allocate);
  rb_define_method(cOBExternalBond.klass, "initialize", VALUEFUNC(_wrap_new_OBExternalBond), -1);
  rb_define_method(cOBExternalBond.klass, "get_idx", VALUEFUNC(_wrap_OBExternalBond_get_idx), -1);
  rb_define_method(cOBExternalBond.klass, "get_atom", VALUEFUNC(_wrap_OBExternalBond_get_atom), -1);
  rb_define_method(cOBExternalBond.klass, "get_bond", VALUEFUNC(_wrap_OBExternalBond_get_bond), -1);
  rb_define_method(cOBExternalBond.klass, "set_idx", VALUEFUNC(_wrap_OBExternalBond_set_idx), -1);
  rb_define_method(cOBExternalBond.klass, "set_atom", VALUEFUNC(_wrap_OBExternalBond_set_atom), -1);
  rb_define_method(cOBExternalBond.klass, "set_bond", VALUEFUNC(_wrap_OBExternalBond_set_bond), -1);
  cOBExternalBond.mark = 0;
  cOBExternalBond.destroy = (void (*)(void *)) free_OpenBabel_OBExternalBond;
  cOBExternalBond.trackObjects = 0;
  
  cOBExternalBondData.klass = rb_define_class_under(mOpenbabel, "OBExternalBondData", ((swig_class *) SWIGTYPE_p_OpenBabel__OBGenericData->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBExternalBondData, (void *) &cOBExternalBondData);
  rb_define_alloc_func(cOBExternalBondData.klass, _wrap_OBExternalBondData_allocate);
  rb_define_method(cOBExternalBondData.klass, "initialize", VALUEFUNC(_wrap_new_OBExternalBondData), -1);
  rb_define_method(cOBExternalBondData.klass, "clone", VALUEFUNC(_wrap_OBExternalBondData_clone), -1);
  rb_define_method(cOBExternalBondData.klass, "set_data", VALUEFUNC(_wrap_OBExternalBondData_set_data), -1);
  rb_define_method(cOBExternalBondData.klass, "get_data", VALUEFUNC(_wrap_OBExternalBondData_get_data), -1);
  cOBExternalBondData.mark = 0;
  cOBExternalBondData.destroy = (void (*)(void *)) free_OpenBabel_OBExternalBondData;
  cOBExternalBondData.trackObjects = 0;
  
  cOBPairData.klass = rb_define_class_under(mOpenbabel, "OBPairData", ((swig_class *) SWIGTYPE_p_OpenBabel__OBGenericData->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBPairData, (void *) &cOBPairData);
  rb_define_alloc_func(cOBPairData.klass, _wrap_OBPairData_allocate);
  rb_define_method(cOBPairData.klass, "initialize", VALUEFUNC(_wrap_new_OBPairData), -1);
  rb_define_method(cOBPairData.klass, "clone", VALUEFUNC(_wrap_OBPairData_clone), -1);
  rb_define_method(cOBPairData.klass, "set_value", VALUEFUNC(_wrap_OBPairData_set_value), -1);
  rb_define_method(cOBPairData.klass, "get_value", VALUEFUNC(_wrap_OBPairData_get_value), -1);
  cOBPairData.mark = 0;
  cOBPairData.destroy = (void (*)(void *)) free_OpenBabel_OBPairData;
  cOBPairData.trackObjects = 0;
  
  cOBSetData.klass = rb_define_class_under(mOpenbabel, "OBSetData", ((swig_class *) SWIGTYPE_p_OpenBabel__OBGenericData->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBSetData, (void *) &cOBSetData);
  rb_define_alloc_func(cOBSetData.klass, _wrap_OBSetData_allocate);
  rb_define_method(cOBSetData.klass, "initialize", VALUEFUNC(_wrap_new_OBSetData), -1);
  rb_define_method(cOBSetData.klass, "clone", VALUEFUNC(_wrap_OBSetData_clone), -1);
  rb_define_method(cOBSetData.klass, "add_data", VALUEFUNC(_wrap_OBSetData_add_data), -1);
  rb_define_method(cOBSetData.klass, "set_data", VALUEFUNC(_wrap_OBSetData_set_data), -1);
  rb_define_method(cOBSetData.klass, "get_data", VALUEFUNC(_wrap_OBSetData_get_data), -1);
  rb_define_method(cOBSetData.klass, "get_begin", VALUEFUNC(_wrap_OBSetData_get_begin), -1);
  rb_define_method(cOBSetData.klass, "get_end", VALUEFUNC(_wrap_OBSetData_get_end), -1);
  rb_define_method(cOBSetData.klass, "delete_data", VALUEFUNC(_wrap_OBSetData_delete_data), -1);
  cOBSetData.mark = 0;
  cOBSetData.destroy = (void (*)(void *)) free_OpenBabel_OBSetData;
  cOBSetData.trackObjects = 0;
  
  cOBVirtualBond.klass = rb_define_class_under(mOpenbabel, "OBVirtualBond", ((swig_class *) SWIGTYPE_p_OpenBabel__OBGenericData->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBVirtualBond, (void *) &cOBVirtualBond);
  rb_define_alloc_func(cOBVirtualBond.klass, _wrap_OBVirtualBond_allocate);
  rb_define_method(cOBVirtualBond.klass, "initialize", VALUEFUNC(_wrap_new_OBVirtualBond), -1);
  rb_define_method(cOBVirtualBond.klass, "clone", VALUEFUNC(_wrap_OBVirtualBond_clone), -1);
  rb_define_method(cOBVirtualBond.klass, "get_bgn", VALUEFUNC(_wrap_OBVirtualBond_get_bgn), -1);
  rb_define_method(cOBVirtualBond.klass, "get_end", VALUEFUNC(_wrap_OBVirtualBond_get_end), -1);
  rb_define_method(cOBVirtualBond.klass, "get_order", VALUEFUNC(_wrap_OBVirtualBond_get_order), -1);
  rb_define_method(cOBVirtualBond.klass, "get_stereo", VALUEFUNC(_wrap_OBVirtualBond_get_stereo), -1);
  cOBVirtualBond.mark = 0;
  cOBVirtualBond.destroy = (void (*)(void *)) free_OpenBabel_OBVirtualBond;
  cOBVirtualBond.trackObjects = 0;
  
  cOBRingData.klass = rb_define_class_under(mOpenbabel, "OBRingData", ((swig_class *) SWIGTYPE_p_OpenBabel__OBGenericData->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBRingData, (void *) &cOBRingData);
  rb_define_alloc_func(cOBRingData.klass, _wrap_OBRingData_allocate);
  rb_define_method(cOBRingData.klass, "initialize", VALUEFUNC(_wrap_new_OBRingData), -1);
  rb_define_method(cOBRingData.klass, "clone", VALUEFUNC(_wrap_OBRingData_clone), -1);
  rb_define_method(cOBRingData.klass, "set_data", VALUEFUNC(_wrap_OBRingData_set_data), -1);
  rb_define_method(cOBRingData.klass, "push_back", VALUEFUNC(_wrap_OBRingData_push_back), -1);
  rb_define_method(cOBRingData.klass, "get_data", VALUEFUNC(_wrap_OBRingData_get_data), -1);
  rb_define_method(cOBRingData.klass, "begin_rings", VALUEFUNC(_wrap_OBRingData_begin_rings), -1);
  rb_define_method(cOBRingData.klass, "end_rings", VALUEFUNC(_wrap_OBRingData_end_rings), -1);
  rb_define_method(cOBRingData.klass, "begin_ring", VALUEFUNC(_wrap_OBRingData_begin_ring), -1);
  rb_define_method(cOBRingData.klass, "next_ring", VALUEFUNC(_wrap_OBRingData_next_ring), -1);
  cOBRingData.mark = 0;
  cOBRingData.destroy = (void (*)(void *)) free_OpenBabel_OBRingData;
  cOBRingData.trackObjects = 0;
  
  cOBUnitCell.klass = rb_define_class_under(mOpenbabel, "OBUnitCell", ((swig_class *) SWIGTYPE_p_OpenBabel__OBGenericData->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBUnitCell, (void *) &cOBUnitCell);
  rb_define_alloc_func(cOBUnitCell.klass, _wrap_OBUnitCell_allocate);
  rb_define_method(cOBUnitCell.klass, "initialize", VALUEFUNC(_wrap_new_OBUnitCell), -1);
  rb_define_const(cOBUnitCell.klass, "Undefined", SWIG_From_int(static_cast< int >(OpenBabel::OBUnitCell::Undefined)));
  rb_define_const(cOBUnitCell.klass, "Triclinic", SWIG_From_int(static_cast< int >(OpenBabel::OBUnitCell::Triclinic)));
  rb_define_const(cOBUnitCell.klass, "Monoclinic", SWIG_From_int(static_cast< int >(OpenBabel::OBUnitCell::Monoclinic)));
  rb_define_const(cOBUnitCell.klass, "Orthorhombic", SWIG_From_int(static_cast< int >(OpenBabel::OBUnitCell::Orthorhombic)));
  rb_define_const(cOBUnitCell.klass, "Tetragonal", SWIG_From_int(static_cast< int >(OpenBabel::OBUnitCell::Tetragonal)));
  rb_define_const(cOBUnitCell.klass, "Rhombohedral", SWIG_From_int(static_cast< int >(OpenBabel::OBUnitCell::Rhombohedral)));
  rb_define_const(cOBUnitCell.klass, "Hexagonal", SWIG_From_int(static_cast< int >(OpenBabel::OBUnitCell::Hexagonal)));
  rb_define_const(cOBUnitCell.klass, "Cubic", SWIG_From_int(static_cast< int >(OpenBabel::OBUnitCell::Cubic)));
  rb_define_method(cOBUnitCell.klass, "clone", VALUEFUNC(_wrap_OBUnitCell_clone), -1);
  rb_define_method(cOBUnitCell.klass, "set_data", VALUEFUNC(_wrap_OBUnitCell_set_data), -1);
  rb_define_method(cOBUnitCell.klass, "set_offset", VALUEFUNC(_wrap_OBUnitCell_set_offset), -1);
  rb_define_method(cOBUnitCell.klass, "set_space_group", VALUEFUNC(_wrap_OBUnitCell_set_space_group), -1);
  rb_define_method(cOBUnitCell.klass, "set_lattice_type", VALUEFUNC(_wrap_OBUnitCell_set_lattice_type), -1);
  rb_define_method(cOBUnitCell.klass, "get_a", VALUEFUNC(_wrap_OBUnitCell_get_a), -1);
  rb_define_method(cOBUnitCell.klass, "get_b", VALUEFUNC(_wrap_OBUnitCell_get_b), -1);
  rb_define_method(cOBUnitCell.klass, "get_c", VALUEFUNC(_wrap_OBUnitCell_get_c), -1);
  rb_define_method(cOBUnitCell.klass, "get_alpha", VALUEFUNC(_wrap_OBUnitCell_get_alpha), -1);
  rb_define_method(cOBUnitCell.klass, "get_beta", VALUEFUNC(_wrap_OBUnitCell_get_beta), -1);
  rb_define_method(cOBUnitCell.klass, "get_gamma", VALUEFUNC(_wrap_OBUnitCell_get_gamma), -1);
  rb_define_method(cOBUnitCell.klass, "get_offset", VALUEFUNC(_wrap_OBUnitCell_get_offset), -1);
  rb_define_method(cOBUnitCell.klass, "get_space_group", VALUEFUNC(_wrap_OBUnitCell_get_space_group), -1);
  rb_define_method(cOBUnitCell.klass, "get_lattice_type", VALUEFUNC(_wrap_OBUnitCell_get_lattice_type), -1);
  rb_define_method(cOBUnitCell.klass, "get_cell_vectors", VALUEFUNC(_wrap_OBUnitCell_get_cell_vectors), -1);
  rb_define_method(cOBUnitCell.klass, "get_cell_matrix", VALUEFUNC(_wrap_OBUnitCell_get_cell_matrix), -1);
  rb_define_method(cOBUnitCell.klass, "get_ortho_matrix", VALUEFUNC(_wrap_OBUnitCell_get_ortho_matrix), -1);
  rb_define_method(cOBUnitCell.klass, "get_fractional_matrix", VALUEFUNC(_wrap_OBUnitCell_get_fractional_matrix), -1);
  rb_define_method(cOBUnitCell.klass, "get_space_group_number", VALUEFUNC(_wrap_OBUnitCell_get_space_group_number), -1);
  rb_define_method(cOBUnitCell.klass, "get_cell_volume", VALUEFUNC(_wrap_OBUnitCell_get_cell_volume), -1);
  cOBUnitCell.mark = 0;
  cOBUnitCell.destroy = (void (*)(void *)) free_OpenBabel_OBUnitCell;
  cOBUnitCell.trackObjects = 0;
  
  cOBConformerData.klass = rb_define_class_under(mOpenbabel, "OBConformerData", ((swig_class *) SWIGTYPE_p_OpenBabel__OBGenericData->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBConformerData, (void *) &cOBConformerData);
  rb_define_alloc_func(cOBConformerData.klass, _wrap_OBConformerData_allocate);
  rb_define_method(cOBConformerData.klass, "initialize", VALUEFUNC(_wrap_new_OBConformerData), -1);
  rb_define_method(cOBConformerData.klass, "clone", VALUEFUNC(_wrap_OBConformerData_clone), -1);
  rb_define_method(cOBConformerData.klass, "set_dimension", VALUEFUNC(_wrap_OBConformerData_set_dimension), -1);
  rb_define_method(cOBConformerData.klass, "set_energies", VALUEFUNC(_wrap_OBConformerData_set_energies), -1);
  rb_define_method(cOBConformerData.klass, "set_forces", VALUEFUNC(_wrap_OBConformerData_set_forces), -1);
  rb_define_method(cOBConformerData.klass, "set_velocities", VALUEFUNC(_wrap_OBConformerData_set_velocities), -1);
  rb_define_method(cOBConformerData.klass, "set_displacements", VALUEFUNC(_wrap_OBConformerData_set_displacements), -1);
  rb_define_method(cOBConformerData.klass, "set_data", VALUEFUNC(_wrap_OBConformerData_set_data), -1);
  rb_define_method(cOBConformerData.klass, "get_dimension", VALUEFUNC(_wrap_OBConformerData_get_dimension), -1);
  rb_define_method(cOBConformerData.klass, "get_energies", VALUEFUNC(_wrap_OBConformerData_get_energies), -1);
  rb_define_method(cOBConformerData.klass, "get_forces", VALUEFUNC(_wrap_OBConformerData_get_forces), -1);
  rb_define_method(cOBConformerData.klass, "get_velocities", VALUEFUNC(_wrap_OBConformerData_get_velocities), -1);
  rb_define_method(cOBConformerData.klass, "get_displacements", VALUEFUNC(_wrap_OBConformerData_get_displacements), -1);
  rb_define_method(cOBConformerData.klass, "get_data", VALUEFUNC(_wrap_OBConformerData_get_data), -1);
  cOBConformerData.mark = 0;
  cOBConformerData.destroy = (void (*)(void *)) free_OpenBabel_OBConformerData;
  cOBConformerData.trackObjects = 0;
  
  cOBSymmetryData.klass = rb_define_class_under(mOpenbabel, "OBSymmetryData", ((swig_class *) SWIGTYPE_p_OpenBabel__OBGenericData->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBSymmetryData, (void *) &cOBSymmetryData);
  rb_define_alloc_func(cOBSymmetryData.klass, _wrap_OBSymmetryData_allocate);
  rb_define_method(cOBSymmetryData.klass, "initialize", VALUEFUNC(_wrap_new_OBSymmetryData), -1);
  rb_define_method(cOBSymmetryData.klass, "clone", VALUEFUNC(_wrap_OBSymmetryData_clone), -1);
  rb_define_method(cOBSymmetryData.klass, "set_data", VALUEFUNC(_wrap_OBSymmetryData_set_data), -1);
  rb_define_method(cOBSymmetryData.klass, "set_point_group", VALUEFUNC(_wrap_OBSymmetryData_set_point_group), -1);
  rb_define_method(cOBSymmetryData.klass, "set_space_group", VALUEFUNC(_wrap_OBSymmetryData_set_space_group), -1);
  rb_define_method(cOBSymmetryData.klass, "get_point_group", VALUEFUNC(_wrap_OBSymmetryData_get_point_group), -1);
  rb_define_method(cOBSymmetryData.klass, "get_space_group", VALUEFUNC(_wrap_OBSymmetryData_get_space_group), -1);
  cOBSymmetryData.mark = 0;
  cOBSymmetryData.destroy = (void (*)(void *)) free_OpenBabel_OBSymmetryData;
  cOBSymmetryData.trackObjects = 0;
  
  cOBTorsion.klass = rb_define_class_under(mOpenbabel, "OBTorsion", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBTorsion, (void *) &cOBTorsion);
  rb_define_alloc_func(cOBTorsion.klass, _wrap_OBTorsion_allocate);
  rb_define_method(cOBTorsion.klass, "initialize", VALUEFUNC(_wrap_new_OBTorsion), -1);
  rb_define_method(cOBTorsion.klass, "clear", VALUEFUNC(_wrap_OBTorsion_clear), -1);
  rb_define_method(cOBTorsion.klass, "empty", VALUEFUNC(_wrap_OBTorsion_empty), -1);
  rb_define_method(cOBTorsion.klass, "add_torsion", VALUEFUNC(_wrap_OBTorsion_add_torsion), -1);
  rb_define_method(cOBTorsion.klass, "set_angle", VALUEFUNC(_wrap_OBTorsion_set_angle), -1);
  rb_define_method(cOBTorsion.klass, "set_data", VALUEFUNC(_wrap_OBTorsion_set_data), -1);
  rb_define_method(cOBTorsion.klass, "get_angle", VALUEFUNC(_wrap_OBTorsion_get_angle), -1);
  rb_define_method(cOBTorsion.klass, "get_bond_idx", VALUEFUNC(_wrap_OBTorsion_get_bond_idx), -1);
  rb_define_method(cOBTorsion.klass, "get_size", VALUEFUNC(_wrap_OBTorsion_get_size), -1);
  rb_define_method(cOBTorsion.klass, "get_bc", VALUEFUNC(_wrap_OBTorsion_get_bc), -1);
  rb_define_method(cOBTorsion.klass, "get_ads", VALUEFUNC(_wrap_OBTorsion_get_ads), -1);
  rb_define_method(cOBTorsion.klass, "is_proton_rotor", VALUEFUNC(_wrap_OBTorsion_is_proton_rotor), -1);
  cOBTorsion.mark = 0;
  cOBTorsion.destroy = (void (*)(void *)) free_OpenBabel_OBTorsion;
  cOBTorsion.trackObjects = 0;
  
  cOBTorsionData.klass = rb_define_class_under(mOpenbabel, "OBTorsionData", ((swig_class *) SWIGTYPE_p_OpenBabel__OBGenericData->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBTorsionData, (void *) &cOBTorsionData);
  rb_undef_alloc_func(cOBTorsionData.klass);
  rb_define_method(cOBTorsionData.klass, "clone", VALUEFUNC(_wrap_OBTorsionData_clone), -1);
  rb_define_method(cOBTorsionData.klass, "clear", VALUEFUNC(_wrap_OBTorsionData_clear), -1);
  rb_define_method(cOBTorsionData.klass, "get_data", VALUEFUNC(_wrap_OBTorsionData_get_data), -1);
  rb_define_method(cOBTorsionData.klass, "get_size", VALUEFUNC(_wrap_OBTorsionData_get_size), -1);
  rb_define_method(cOBTorsionData.klass, "set_data", VALUEFUNC(_wrap_OBTorsionData_set_data), -1);
  rb_define_method(cOBTorsionData.klass, "fill_torsion_array", VALUEFUNC(_wrap_OBTorsionData_fill_torsion_array), -1);
  cOBTorsionData.mark = 0;
  cOBTorsionData.destroy = (void (*)(void *)) free_OpenBabel_OBTorsionData;
  cOBTorsionData.trackObjects = 0;
  
  cOBAngle.klass = rb_define_class_under(mOpenbabel, "OBAngle", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBAngle, (void *) &cOBAngle);
  rb_define_alloc_func(cOBAngle.klass, _wrap_OBAngle_allocate);
  rb_define_method(cOBAngle.klass, "initialize", VALUEFUNC(_wrap_new_OBAngle), -1);
  rb_define_method(cOBAngle.klass, "==", VALUEFUNC(_wrap_OBAngle___eq__), -1);
  rb_define_method(cOBAngle.klass, "clear", VALUEFUNC(_wrap_OBAngle_clear), -1);
  rb_define_method(cOBAngle.klass, "get_angle", VALUEFUNC(_wrap_OBAngle_get_angle), -1);
  rb_define_method(cOBAngle.klass, "set_angle", VALUEFUNC(_wrap_OBAngle_set_angle), -1);
  rb_define_method(cOBAngle.klass, "set_atoms", VALUEFUNC(_wrap_OBAngle_set_atoms), -1);
  cOBAngle.mark = 0;
  cOBAngle.destroy = (void (*)(void *)) free_OpenBabel_OBAngle;
  cOBAngle.trackObjects = 0;
  
  cOBAngleData.klass = rb_define_class_under(mOpenbabel, "OBAngleData", ((swig_class *) SWIGTYPE_p_OpenBabel__OBGenericData->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBAngleData, (void *) &cOBAngleData);
  rb_undef_alloc_func(cOBAngleData.klass);
  rb_define_method(cOBAngleData.klass, "clone", VALUEFUNC(_wrap_OBAngleData_clone), -1);
  rb_define_method(cOBAngleData.klass, "clear", VALUEFUNC(_wrap_OBAngleData_clear), -1);
  rb_define_method(cOBAngleData.klass, "fill_angle_array", VALUEFUNC(_wrap_OBAngleData_fill_angle_array), -1);
  rb_define_method(cOBAngleData.klass, "set_data", VALUEFUNC(_wrap_OBAngleData_set_data), -1);
  rb_define_method(cOBAngleData.klass, "get_size", VALUEFUNC(_wrap_OBAngleData_get_size), -1);
  cOBAngleData.mark = 0;
  cOBAngleData.destroy = (void (*)(void *)) free_OpenBabel_OBAngleData;
  cOBAngleData.trackObjects = 0;
  rb_define_const(mOpenbabel, "Output", SWIG_From_int(static_cast< int >(OpenBabel::output)));
  rb_define_const(mOpenbabel, "Input", SWIG_From_int(static_cast< int >(OpenBabel::input)));
  rb_define_const(mOpenbabel, "Calcvolume", SWIG_From_int(static_cast< int >(OpenBabel::calcvolume)));
  
  cOBChiralData.klass = rb_define_class_under(mOpenbabel, "OBChiralData", ((swig_class *) SWIGTYPE_p_OpenBabel__OBGenericData->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBChiralData, (void *) &cOBChiralData);
  rb_define_alloc_func(cOBChiralData.klass, _wrap_OBChiralData_allocate);
  rb_define_method(cOBChiralData.klass, "initialize", VALUEFUNC(_wrap_new_OBChiralData), -1);
  rb_define_method(cOBChiralData.klass, "clone", VALUEFUNC(_wrap_OBChiralData_clone), -1);
  rb_define_method(cOBChiralData.klass, "clear", VALUEFUNC(_wrap_OBChiralData_clear), -1);
  rb_define_method(cOBChiralData.klass, "get_atom_4refs", VALUEFUNC(_wrap_OBChiralData_get_atom_4refs), -1);
  rb_define_method(cOBChiralData.klass, "get_atom_ref", VALUEFUNC(_wrap_OBChiralData_get_atom_ref), -1);
  rb_define_method(cOBChiralData.klass, "set_atom_4refs", VALUEFUNC(_wrap_OBChiralData_set_atom_4refs), -1);
  rb_define_method(cOBChiralData.klass, "add_atom_ref", VALUEFUNC(_wrap_OBChiralData_add_atom_ref), -1);
  rb_define_method(cOBChiralData.klass, "get_size", VALUEFUNC(_wrap_OBChiralData_get_size), -1);
  cOBChiralData.mark = 0;
  cOBChiralData.destroy = (void (*)(void *)) free_OpenBabel_OBChiralData;
  cOBChiralData.trackObjects = 0;
  
  cOBSerialNums.klass = rb_define_class_under(mOpenbabel, "OBSerialNums", ((swig_class *) SWIGTYPE_p_OpenBabel__OBGenericData->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBSerialNums, (void *) &cOBSerialNums);
  rb_define_alloc_func(cOBSerialNums.klass, _wrap_OBSerialNums_allocate);
  rb_define_method(cOBSerialNums.klass, "initialize", VALUEFUNC(_wrap_new_OBSerialNums), -1);
  rb_define_method(cOBSerialNums.klass, "clone", VALUEFUNC(_wrap_OBSerialNums_clone), -1);
  rb_define_method(cOBSerialNums.klass, "get_data", VALUEFUNC(_wrap_OBSerialNums_get_data), -1);
  rb_define_method(cOBSerialNums.klass, "set_data", VALUEFUNC(_wrap_OBSerialNums_set_data), -1);
  cOBSerialNums.mark = 0;
  cOBSerialNums.destroy = (void (*)(void *)) free_OpenBabel_OBSerialNums;
  cOBSerialNums.trackObjects = 0;
  
  cOBVibrationData.klass = rb_define_class_under(mOpenbabel, "OBVibrationData", ((swig_class *) SWIGTYPE_p_OpenBabel__OBGenericData->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBVibrationData, (void *) &cOBVibrationData);
  rb_define_alloc_func(cOBVibrationData.klass, _wrap_OBVibrationData_allocate);
  rb_define_method(cOBVibrationData.klass, "initialize", VALUEFUNC(_wrap_new_OBVibrationData), -1);
  rb_define_method(cOBVibrationData.klass, "set_data", VALUEFUNC(_wrap_OBVibrationData_set_data), -1);
  rb_define_method(cOBVibrationData.klass, "get_lx", VALUEFUNC(_wrap_OBVibrationData_get_lx), -1);
  rb_define_method(cOBVibrationData.klass, "get_frequencies", VALUEFUNC(_wrap_OBVibrationData_get_frequencies), -1);
  rb_define_method(cOBVibrationData.klass, "get_intensities", VALUEFUNC(_wrap_OBVibrationData_get_intensities), -1);
  rb_define_method(cOBVibrationData.klass, "get_number_of_frequencies", VALUEFUNC(_wrap_OBVibrationData_get_number_of_frequencies), -1);
  cOBVibrationData.mark = 0;
  cOBVibrationData.destroy = (void (*)(void *)) free_OpenBabel_OBVibrationData;
  cOBVibrationData.trackObjects = 0;
  
  cOBBase.klass = rb_define_class_under(mOpenbabel, "OBBase", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBBase, (void *) &cOBBase);
  rb_define_alloc_func(cOBBase.klass, _wrap_OBBase_allocate);
  rb_define_method(cOBBase.klass, "initialize", VALUEFUNC(_wrap_new_OBBase), -1);
  rb_define_method(cOBBase.klass, "clear", VALUEFUNC(_wrap_OBBase_clear), -1);
  rb_define_method(cOBBase.klass, "do_transformations", VALUEFUNC(_wrap_OBBase_do_transformations), -1);
  rb_define_singleton_method(cOBBase.klass, "class_description", VALUEFUNC(_wrap_OBBase_class_description), -1);
  rb_define_method(cOBBase.klass, "has_data", VALUEFUNC(_wrap_OBBase_has_data), -1);
  rb_define_method(cOBBase.klass, "delete_data", VALUEFUNC(_wrap_OBBase_delete_data), -1);
  rb_define_method(cOBBase.klass, "set_data", VALUEFUNC(_wrap_OBBase_set_data), -1);
  rb_define_method(cOBBase.klass, "data_size", VALUEFUNC(_wrap_OBBase_data_size), -1);
  rb_define_method(cOBBase.klass, "get_data", VALUEFUNC(_wrap_OBBase_get_data), -1);
  rb_define_method(cOBBase.klass, "begin_data", VALUEFUNC(_wrap_OBBase_begin_data), -1);
  rb_define_method(cOBBase.klass, "end_data", VALUEFUNC(_wrap_OBBase_end_data), -1);
  cOBBase.mark = 0;
  cOBBase.destroy = (void (*)(void *)) free_OpenBabel_OBBase;
  cOBBase.trackObjects = 0;
  
  cPluginiterFingerprint.klass = rb_define_class_under(mOpenbabel, "PluginiterFingerprint", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBFingerprint_t, (void *) &cPluginiterFingerprint);
  rb_define_alloc_func(cPluginiterFingerprint.klass, _wrap_pluginiterFingerprint_allocate);
  rb_define_method(cPluginiterFingerprint.klass, "initialize", VALUEFUNC(_wrap_new_pluginiterFingerprint), -1);
  rb_define_method(cPluginiterFingerprint.klass, "register", VALUEFUNC(_wrap_pluginiterFingerprint_register), -1);
  rb_define_method(cPluginiterFingerprint.klass, "find_type", VALUEFUNC(_wrap_pluginiterFingerprint_find_type), -1);
  rb_define_method(cPluginiterFingerprint.klass, "find_default_type", VALUEFUNC(_wrap_pluginiterFingerprint_find_default_type), -1);
  rb_define_method(cPluginiterFingerprint.klass, "id", VALUEFUNC(_wrap_pluginiterFingerprint_id), -1);
  rb_define_method(cPluginiterFingerprint.klass, "to_start", VALUEFUNC(_wrap_pluginiterFingerprint_to_start), -1);
  rb_define_method(cPluginiterFingerprint.klass, "inc", VALUEFUNC(_wrap_pluginiterFingerprint_inc), -1);
  rb_define_method(cPluginiterFingerprint.klass, "good", VALUEFUNC(_wrap_pluginiterFingerprint_good), -1);
  rb_define_method(cPluginiterFingerprint.klass, "deref", VALUEFUNC(_wrap_pluginiterFingerprint_deref), -1);
  rb_define_method(cPluginiterFingerprint.klass, "iter", VALUEFUNC(_wrap_pluginiterFingerprint_iter), -1);
  rb_define_method(cPluginiterFingerprint.klass, "set_bit", VALUEFUNC(_wrap_pluginiterFingerprint_set_bit), -1);
  rb_define_method(cPluginiterFingerprint.klass, "fold", VALUEFUNC(_wrap_pluginiterFingerprint_fold), -1);
  rb_define_method(cPluginiterFingerprint.klass, "get_fingerprint", VALUEFUNC(_wrap_pluginiterFingerprint_get_fingerprint), -1);
  rb_define_method(cPluginiterFingerprint.klass, "description", VALUEFUNC(_wrap_pluginiterFingerprint_description), -1);
  rb_define_method(cPluginiterFingerprint.klass, "flags", VALUEFUNC(_wrap_pluginiterFingerprint_flags), -1);
  rb_define_method(cPluginiterFingerprint.klass, "tanimoto", VALUEFUNC(_wrap_pluginiterFingerprint_tanimoto), -1);
  rb_define_method(cPluginiterFingerprint.klass, "getbitsperint", VALUEFUNC(_wrap_pluginiterFingerprint_getbitsperint), -1);
  rb_define_method(cPluginiterFingerprint.klass, "find_fingerprint", VALUEFUNC(_wrap_pluginiterFingerprint_find_fingerprint), -1);
  cPluginiterFingerprint.mark = 0;
  cPluginiterFingerprint.destroy = (void (*)(void *)) free_OpenBabel_PluginIter_Sl_OpenBabel_OBFingerprint_Sg_;
  cPluginiterFingerprint.trackObjects = 0;
  
  cPluginiterForceField.klass = rb_define_class_under(mOpenbabel, "PluginiterForceField", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__PluginIterTOpenBabel__OBForceField_t, (void *) &cPluginiterForceField);
  rb_define_alloc_func(cPluginiterForceField.klass, _wrap_pluginiterForceField_allocate);
  rb_define_method(cPluginiterForceField.klass, "initialize", VALUEFUNC(_wrap_new_pluginiterForceField), -1);
  rb_define_method(cPluginiterForceField.klass, "register", VALUEFUNC(_wrap_pluginiterForceField_register), -1);
  rb_define_method(cPluginiterForceField.klass, "find_type", VALUEFUNC(_wrap_pluginiterForceField_find_type), -1);
  rb_define_method(cPluginiterForceField.klass, "find_default_type", VALUEFUNC(_wrap_pluginiterForceField_find_default_type), -1);
  rb_define_method(cPluginiterForceField.klass, "id", VALUEFUNC(_wrap_pluginiterForceField_id), -1);
  rb_define_method(cPluginiterForceField.klass, "to_start", VALUEFUNC(_wrap_pluginiterForceField_to_start), -1);
  rb_define_method(cPluginiterForceField.klass, "inc", VALUEFUNC(_wrap_pluginiterForceField_inc), -1);
  rb_define_method(cPluginiterForceField.klass, "good", VALUEFUNC(_wrap_pluginiterForceField_good), -1);
  rb_define_method(cPluginiterForceField.klass, "deref", VALUEFUNC(_wrap_pluginiterForceField_deref), -1);
  rb_define_method(cPluginiterForceField.klass, "iter", VALUEFUNC(_wrap_pluginiterForceField_iter), -1);
  rb_define_method(cPluginiterForceField.klass, "find_force_field", VALUEFUNC(_wrap_pluginiterForceField_find_force_field), -1);
  rb_define_method(cPluginiterForceField.klass, "get_unit", VALUEFUNC(_wrap_pluginiterForceField_get_unit), -1);
  rb_define_method(cPluginiterForceField.klass, "setup", VALUEFUNC(_wrap_pluginiterForceField_setup), -1);
  rb_define_method(cPluginiterForceField.klass, "update_coordinates", VALUEFUNC(_wrap_pluginiterForceField_update_coordinates), -1);
  rb_define_method(cPluginiterForceField.klass, "update_conformers", VALUEFUNC(_wrap_pluginiterForceField_update_conformers), -1);
  rb_define_method(cPluginiterForceField.klass, "obfflog", VALUEFUNC(_wrap_pluginiterForceField_obfflog), -1);
  rb_define_method(cPluginiterForceField.klass, "energy", VALUEFUNC(_wrap_pluginiterForceField_energy), -1);
  rb_define_method(cPluginiterForceField.klass, "e_bond", VALUEFUNC(_wrap_pluginiterForceField_e_bond), -1);
  rb_define_method(cPluginiterForceField.klass, "e_angle", VALUEFUNC(_wrap_pluginiterForceField_e_angle), -1);
  rb_define_method(cPluginiterForceField.klass, "e_str_bnd", VALUEFUNC(_wrap_pluginiterForceField_e_str_bnd), -1);
  rb_define_method(cPluginiterForceField.klass, "e_torsion", VALUEFUNC(_wrap_pluginiterForceField_e_torsion), -1);
  rb_define_method(cPluginiterForceField.klass, "e_oop", VALUEFUNC(_wrap_pluginiterForceField_e_oop), -1);
  rb_define_method(cPluginiterForceField.klass, "e_vdw", VALUEFUNC(_wrap_pluginiterForceField_e_vdw), -1);
  rb_define_method(cPluginiterForceField.klass, "e_electrostatic", VALUEFUNC(_wrap_pluginiterForceField_e_electrostatic), -1);
  rb_define_method(cPluginiterForceField.klass, "set_log_file", VALUEFUNC(_wrap_pluginiterForceField_set_log_file), -1);
  rb_define_method(cPluginiterForceField.klass, "set_log_level", VALUEFUNC(_wrap_pluginiterForceField_set_log_level), -1);
  rb_define_method(cPluginiterForceField.klass, "get_log_level", VALUEFUNC(_wrap_pluginiterForceField_get_log_level), -1);
  rb_define_method(cPluginiterForceField.klass, "systematic_rotor_search", VALUEFUNC(_wrap_pluginiterForceField_systematic_rotor_search), -1);
  rb_define_method(cPluginiterForceField.klass, "line_search", VALUEFUNC(_wrap_pluginiterForceField_line_search), -1);
  rb_define_method(cPluginiterForceField.klass, "steepest_descent", VALUEFUNC(_wrap_pluginiterForceField_steepest_descent), -1);
  rb_define_method(cPluginiterForceField.klass, "steepest_descent_initialize", VALUEFUNC(_wrap_pluginiterForceField_steepest_descent_initialize), -1);
  rb_define_method(cPluginiterForceField.klass, "steepest_descent_take_nsteps", VALUEFUNC(_wrap_pluginiterForceField_steepest_descent_take_nsteps), -1);
  rb_define_method(cPluginiterForceField.klass, "conjugate_gradients", VALUEFUNC(_wrap_pluginiterForceField_conjugate_gradients), -1);
  rb_define_method(cPluginiterForceField.klass, "conjugate_gradients_initialize", VALUEFUNC(_wrap_pluginiterForceField_conjugate_gradients_initialize), -1);
  rb_define_method(cPluginiterForceField.klass, "conjugate_gradients_take_nsteps", VALUEFUNC(_wrap_pluginiterForceField_conjugate_gradients_take_nsteps), -1);
  rb_define_method(cPluginiterForceField.klass, "validate", VALUEFUNC(_wrap_pluginiterForceField_validate), -1);
  rb_define_method(cPluginiterForceField.klass, "validate_gradients", VALUEFUNC(_wrap_pluginiterForceField_validate_gradients), -1);
  rb_define_method(cPluginiterForceField.klass, "validate_gradient_error", VALUEFUNC(_wrap_pluginiterForceField_validate_gradient_error), -1);
  rb_define_method(cPluginiterForceField.klass, "vector_length_derivative", VALUEFUNC(_wrap_pluginiterForceField_vector_length_derivative), -1);
  rb_define_method(cPluginiterForceField.klass, "vector_angle_derivative", VALUEFUNC(_wrap_pluginiterForceField_vector_angle_derivative), -1);
  rb_define_method(cPluginiterForceField.klass, "vector_torsion_derivative", VALUEFUNC(_wrap_pluginiterForceField_vector_torsion_derivative), -1);
  rb_define_method(cPluginiterForceField.klass, "kludge", VALUEFUNC(_wrap_pluginiterForceField_kludge), -1);
  cPluginiterForceField.mark = 0;
  cPluginiterForceField.destroy = (void (*)(void *)) free_OpenBabel_PluginIter_Sl_OpenBabel_OBForceField_Sg_;
  cPluginiterForceField.trackObjects = 0;
  rb_define_const(mOpenbabel, "ObError", SWIG_From_int(static_cast< int >(OpenBabel::obError)));
  rb_define_const(mOpenbabel, "ObWarning", SWIG_From_int(static_cast< int >(OpenBabel::obWarning)));
  rb_define_const(mOpenbabel, "ObInfo", SWIG_From_int(static_cast< int >(OpenBabel::obInfo)));
  rb_define_const(mOpenbabel, "ObAuditMsg", SWIG_From_int(static_cast< int >(OpenBabel::obAuditMsg)));
  rb_define_const(mOpenbabel, "ObDebug", SWIG_From_int(static_cast< int >(OpenBabel::obDebug)));
  
  cOBError.klass = rb_define_class_under(mOpenbabel, "OBError", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBError, (void *) &cOBError);
  rb_define_alloc_func(cOBError.klass, _wrap_OBError_allocate);
  rb_define_method(cOBError.klass, "initialize", VALUEFUNC(_wrap_new_OBError), -1);
  rb_define_method(cOBError.klass, "message", VALUEFUNC(_wrap_OBError_message), -1);
  rb_define_method(cOBError.klass, "get_method", VALUEFUNC(_wrap_OBError_get_method), -1);
  rb_define_method(cOBError.klass, "get_error", VALUEFUNC(_wrap_OBError_get_error), -1);
  rb_define_method(cOBError.klass, "get_explanation", VALUEFUNC(_wrap_OBError_get_explanation), -1);
  rb_define_method(cOBError.klass, "get_possible_cause", VALUEFUNC(_wrap_OBError_get_possible_cause), -1);
  rb_define_method(cOBError.klass, "get_suggested_remedy", VALUEFUNC(_wrap_OBError_get_suggested_remedy), -1);
  rb_define_method(cOBError.klass, "get_level", VALUEFUNC(_wrap_OBError_get_level), -1);
  cOBError.mark = 0;
  cOBError.destroy = (void (*)(void *)) free_OpenBabel_OBError;
  cOBError.trackObjects = 0;
  
  cOBMessageHandler.klass = rb_define_class_under(mOpenbabel, "OBMessageHandler", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBMessageHandler, (void *) &cOBMessageHandler);
  rb_define_alloc_func(cOBMessageHandler.klass, _wrap_OBMessageHandler_allocate);
  rb_define_method(cOBMessageHandler.klass, "initialize", VALUEFUNC(_wrap_new_OBMessageHandler), -1);
  rb_define_method(cOBMessageHandler.klass, "throw_error", VALUEFUNC(_wrap_OBMessageHandler_throw_error), -1);
  rb_define_method(cOBMessageHandler.klass, "get_messages_of_level", VALUEFUNC(_wrap_OBMessageHandler_get_messages_of_level), -1);
  rb_define_method(cOBMessageHandler.klass, "start_logging", VALUEFUNC(_wrap_OBMessageHandler_start_logging), -1);
  rb_define_method(cOBMessageHandler.klass, "stop_logging", VALUEFUNC(_wrap_OBMessageHandler_stop_logging), -1);
  rb_define_method(cOBMessageHandler.klass, "set_max_log_entries", VALUEFUNC(_wrap_OBMessageHandler_set_max_log_entries), -1);
  rb_define_method(cOBMessageHandler.klass, "get_max_log_entries", VALUEFUNC(_wrap_OBMessageHandler_get_max_log_entries), -1);
  rb_define_method(cOBMessageHandler.klass, "clear_log", VALUEFUNC(_wrap_OBMessageHandler_clear_log), -1);
  rb_define_method(cOBMessageHandler.klass, "set_output_level", VALUEFUNC(_wrap_OBMessageHandler_set_output_level), -1);
  rb_define_method(cOBMessageHandler.klass, "get_output_level", VALUEFUNC(_wrap_OBMessageHandler_get_output_level), -1);
  rb_define_method(cOBMessageHandler.klass, "set_output_stream", VALUEFUNC(_wrap_OBMessageHandler_set_output_stream), -1);
  rb_define_method(cOBMessageHandler.klass, "get_output_stream", VALUEFUNC(_wrap_OBMessageHandler_get_output_stream), -1);
  rb_define_method(cOBMessageHandler.klass, "start_error_wrap", VALUEFUNC(_wrap_OBMessageHandler_start_error_wrap), -1);
  rb_define_method(cOBMessageHandler.klass, "stop_error_wrap", VALUEFUNC(_wrap_OBMessageHandler_stop_error_wrap), -1);
  rb_define_method(cOBMessageHandler.klass, "get_error_message_count", VALUEFUNC(_wrap_OBMessageHandler_get_error_message_count), -1);
  rb_define_method(cOBMessageHandler.klass, "get_warning_message_count", VALUEFUNC(_wrap_OBMessageHandler_get_warning_message_count), -1);
  rb_define_method(cOBMessageHandler.klass, "get_info_message_count", VALUEFUNC(_wrap_OBMessageHandler_get_info_message_count), -1);
  rb_define_method(cOBMessageHandler.klass, "get_audit_message_count", VALUEFUNC(_wrap_OBMessageHandler_get_audit_message_count), -1);
  rb_define_method(cOBMessageHandler.klass, "get_debug_message_count", VALUEFUNC(_wrap_OBMessageHandler_get_debug_message_count), -1);
  rb_define_method(cOBMessageHandler.klass, "get_message_summary", VALUEFUNC(_wrap_OBMessageHandler_get_message_summary), -1);
  cOBMessageHandler.mark = 0;
  cOBMessageHandler.destroy = (void (*)(void *)) free_OpenBabel_OBMessageHandler;
  cOBMessageHandler.trackObjects = 0;
  rb_define_singleton_method(mOpenbabel, "obErrorLog", VALUEFUNC(obErrorLog_get), 0);
  rb_define_singleton_method(mOpenbabel, "obErrorLog=", VALUEFUNC(obErrorLog_set), 1);
  
  cObLogBuf.klass = rb_define_class_under(mOpenbabel, "ObLogBuf", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__obLogBuf, (void *) &cObLogBuf);
  rb_define_alloc_func(cObLogBuf.klass, _wrap_ObLogBuf_allocate);
  rb_define_method(cObLogBuf.klass, "initialize", VALUEFUNC(_wrap_new_ObLogBuf), -1);
  cObLogBuf.mark = 0;
  cObLogBuf.destroy = (void (*)(void *)) free_OpenBabel_obLogBuf;
  cObLogBuf.trackObjects = 0;
  
  cOBFormat.klass = rb_define_class_under(mOpenbabel, "OBFormat", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBFormat, (void *) &cOBFormat);
  rb_undef_alloc_func(cOBFormat.klass);
  rb_define_method(cOBFormat.klass, "read_molecule", VALUEFUNC(_wrap_OBFormat_read_molecule), -1);
  rb_define_method(cOBFormat.klass, "read_chem_object", VALUEFUNC(_wrap_OBFormat_read_chem_object), -1);
  rb_define_method(cOBFormat.klass, "write_molecule", VALUEFUNC(_wrap_OBFormat_write_molecule), -1);
  rb_define_method(cOBFormat.klass, "write_chem_object", VALUEFUNC(_wrap_OBFormat_write_chem_object), -1);
  rb_define_method(cOBFormat.klass, "description", VALUEFUNC(_wrap_OBFormat_description), -1);
  rb_define_method(cOBFormat.klass, "target_class_description", VALUEFUNC(_wrap_OBFormat_target_class_description), -1);
  rb_define_method(cOBFormat.klass, "get_type", VALUEFUNC(_wrap_OBFormat_get_type), -1);
  rb_define_method(cOBFormat.klass, "specification_url", VALUEFUNC(_wrap_OBFormat_specification_url), -1);
  rb_define_method(cOBFormat.klass, "get_mimetype", VALUEFUNC(_wrap_OBFormat_get_mimetype), -1);
  rb_define_method(cOBFormat.klass, "flags", VALUEFUNC(_wrap_OBFormat_flags), -1);
  rb_define_method(cOBFormat.klass, "skip_objects", VALUEFUNC(_wrap_OBFormat_skip_objects), -1);
  rb_define_method(cOBFormat.klass, "make_new_instance", VALUEFUNC(_wrap_OBFormat_make_new_instance), -1);
  cOBFormat.mark = 0;
  cOBFormat.destroy = (void (*)(void *)) free_OpenBabel_OBFormat;
  cOBFormat.trackObjects = 0;
  
  cCharPtrLess.klass = rb_define_class_under(mOpenbabel, "CharPtrLess", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__CharPtrLess, (void *) &cCharPtrLess);
  rb_define_alloc_func(cCharPtrLess.klass, _wrap_CharPtrLess_allocate);
  rb_define_method(cCharPtrLess.klass, "initialize", VALUEFUNC(_wrap_new_CharPtrLess), -1);
  rb_define_method(cCharPtrLess.klass, "call", VALUEFUNC(_wrap_CharPtrLess___call__), -1);
  cCharPtrLess.mark = 0;
  cCharPtrLess.destroy = (void (*)(void *)) free_OpenBabel_CharPtrLess;
  cCharPtrLess.trackObjects = 0;
  
  cOBConversion.klass = rb_define_class_under(mOpenbabel, "OBConversion", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBConversion, (void *) &cOBConversion);
  rb_define_alloc_func(cOBConversion.klass, _wrap_OBConversion_allocate);
  rb_define_method(cOBConversion.klass, "initialize", VALUEFUNC(_wrap_new_OBConversion), -1);
  rb_define_singleton_method(cOBConversion.klass, "register_format", VALUEFUNC(_wrap_OBConversion_register_format), -1);
  rb_define_singleton_method(cOBConversion.klass, "find_format", VALUEFUNC(_wrap_OBConversion_find_format), -1);
  rb_define_singleton_method(cOBConversion.klass, "format_from_ext", VALUEFUNC(_wrap_OBConversion_format_from_ext), -1);
  rb_define_singleton_method(cOBConversion.klass, "format_from_mime", VALUEFUNC(_wrap_OBConversion_format_from_mime), -1);
  rb_define_singleton_method(cOBConversion.klass, "get_next_format", VALUEFUNC(_wrap_OBConversion_get_next_format), -1);
  rb_define_singleton_method(cOBConversion.klass, "description", VALUEFUNC(_wrap_OBConversion_description), -1);
  rb_define_method(cOBConversion.klass, "get_in_stream", VALUEFUNC(_wrap_OBConversion_get_in_stream), -1);
  rb_define_method(cOBConversion.klass, "get_out_stream", VALUEFUNC(_wrap_OBConversion_get_out_stream), -1);
  rb_define_method(cOBConversion.klass, "set_in_stream", VALUEFUNC(_wrap_OBConversion_set_in_stream), -1);
  rb_define_method(cOBConversion.klass, "set_out_stream", VALUEFUNC(_wrap_OBConversion_set_out_stream), -1);
  rb_define_method(cOBConversion.klass, "set_in_and_out_formats", VALUEFUNC(_wrap_OBConversion_set_in_and_out_formats), -1);
  rb_define_method(cOBConversion.klass, "set_in_format", VALUEFUNC(_wrap_OBConversion_set_in_format), -1);
  rb_define_method(cOBConversion.klass, "set_out_format", VALUEFUNC(_wrap_OBConversion_set_out_format), -1);
  rb_define_method(cOBConversion.klass, "get_in_format", VALUEFUNC(_wrap_OBConversion_get_in_format), -1);
  rb_define_method(cOBConversion.klass, "get_out_format", VALUEFUNC(_wrap_OBConversion_get_out_format), -1);
  rb_define_method(cOBConversion.klass, "get_in_filename", VALUEFUNC(_wrap_OBConversion_get_in_filename), -1);
  rb_define_method(cOBConversion.klass, "get_in_pos", VALUEFUNC(_wrap_OBConversion_get_in_pos), -1);
  rb_define_method(cOBConversion.klass, "get_in_len", VALUEFUNC(_wrap_OBConversion_get_in_len), -1);
  rb_define_method(cOBConversion.klass, "get_title", VALUEFUNC(_wrap_OBConversion_get_title), -1);
  rb_define_method(cOBConversion.klass, "get_aux_conv", VALUEFUNC(_wrap_OBConversion_get_aux_conv), -1);
  rb_define_method(cOBConversion.klass, "set_aux_conv", VALUEFUNC(_wrap_OBConversion_set_aux_conv), -1);
  rb_define_const(cOBConversion.klass, "INOPTIONS", SWIG_From_int(static_cast< int >(OpenBabel::OBConversion::INOPTIONS)));
  rb_define_const(cOBConversion.klass, "OUTOPTIONS", SWIG_From_int(static_cast< int >(OpenBabel::OBConversion::OUTOPTIONS)));
  rb_define_const(cOBConversion.klass, "GENOPTIONS", SWIG_From_int(static_cast< int >(OpenBabel::OBConversion::GENOPTIONS)));
  rb_define_method(cOBConversion.klass, "is_option", VALUEFUNC(_wrap_OBConversion_is_option), -1);
  rb_define_method(cOBConversion.klass, "get_options", VALUEFUNC(_wrap_OBConversion_get_options), -1);
  rb_define_method(cOBConversion.klass, "add_option", VALUEFUNC(_wrap_OBConversion_add_option), -1);
  rb_define_method(cOBConversion.klass, "remove_option", VALUEFUNC(_wrap_OBConversion_remove_option), -1);
  rb_define_method(cOBConversion.klass, "set_options", VALUEFUNC(_wrap_OBConversion_set_options), -1);
  rb_define_singleton_method(cOBConversion.klass, "register_option_param", VALUEFUNC(_wrap_OBConversion_register_option_param), -1);
  rb_define_singleton_method(cOBConversion.klass, "get_option_params", VALUEFUNC(_wrap_OBConversion_get_option_params), -1);
  rb_define_method(cOBConversion.klass, "get_supported_input_format", VALUEFUNC(_wrap_OBConversion_get_supported_input_format), -1);
  rb_define_method(cOBConversion.klass, "get_supported_output_format", VALUEFUNC(_wrap_OBConversion_get_supported_output_format), -1);
  rb_define_method(cOBConversion.klass, "convert", VALUEFUNC(_wrap_OBConversion_convert), -1);
  rb_define_method(cOBConversion.klass, "full_convert", VALUEFUNC(_wrap_OBConversion_full_convert), -1);
  rb_define_method(cOBConversion.klass, "add_chem_object", VALUEFUNC(_wrap_OBConversion_add_chem_object), -1);
  rb_define_method(cOBConversion.klass, "get_chem_object", VALUEFUNC(_wrap_OBConversion_get_chem_object), -1);
  rb_define_method(cOBConversion.klass, "is_last", VALUEFUNC(_wrap_OBConversion_is_last), -1);
  rb_define_method(cOBConversion.klass, "is_first_input", VALUEFUNC(_wrap_OBConversion_is_first_input), -1);
  rb_define_method(cOBConversion.klass, "get_output_index", VALUEFUNC(_wrap_OBConversion_get_output_index), -1);
  rb_define_method(cOBConversion.klass, "set_output_index", VALUEFUNC(_wrap_OBConversion_set_output_index), -1);
  rb_define_method(cOBConversion.klass, "set_more_files_to_come", VALUEFUNC(_wrap_OBConversion_set_more_files_to_come), -1);
  rb_define_method(cOBConversion.klass, "set_one_object_only", VALUEFUNC(_wrap_OBConversion_set_one_object_only), -1);
  rb_define_method(cOBConversion.klass, "set_last", VALUEFUNC(_wrap_OBConversion_set_last), -1);
  rb_define_singleton_method(cOBConversion.klass, "get_default_format", VALUEFUNC(_wrap_OBConversion_get_default_format), -1);
  rb_define_method(cOBConversion.klass, "write", VALUEFUNC(_wrap_OBConversion_write), -1);
  rb_define_method(cOBConversion.klass, "write_string", VALUEFUNC(_wrap_OBConversion_write_string), -1);
  rb_define_method(cOBConversion.klass, "write_file", VALUEFUNC(_wrap_OBConversion_write_file), -1);
  rb_define_method(cOBConversion.klass, "close_out_file", VALUEFUNC(_wrap_OBConversion_close_out_file), -1);
  rb_define_method(cOBConversion.klass, "read", VALUEFUNC(_wrap_OBConversion_read), -1);
  rb_define_method(cOBConversion.klass, "read_string", VALUEFUNC(_wrap_OBConversion_read_string), -1);
  rb_define_method(cOBConversion.klass, "read_file", VALUEFUNC(_wrap_OBConversion_read_file), -1);
  cOBConversion.mark = 0;
  cOBConversion.destroy = (void (*)(void *)) free_OpenBabel_OBConversion;
  cOBConversion.trackObjects = 0;
  rb_define_const(mOpenbabel, "NOTREADABLE", SWIG_From_int(static_cast< int >(0x01)));
  rb_define_const(mOpenbabel, "READONEONLY", SWIG_From_int(static_cast< int >(0x02)));
  rb_define_const(mOpenbabel, "READBINARY", SWIG_From_int(static_cast< int >(0x04)));
  rb_define_const(mOpenbabel, "ZEROATOMSOK", SWIG_From_int(static_cast< int >(0x08)));
  rb_define_const(mOpenbabel, "NOTWRITABLE", SWIG_From_int(static_cast< int >(0x10)));
  rb_define_const(mOpenbabel, "WRITEONEONLY", SWIG_From_int(static_cast< int >(0x20)));
  rb_define_const(mOpenbabel, "WRITEBINARY", SWIG_From_int(static_cast< int >(0x40)));
  rb_define_const(mOpenbabel, "READXML", SWIG_From_int(static_cast< int >(0x80)));
  rb_define_const(mOpenbabel, "DEFAULTFORMAT", SWIG_From_int(static_cast< int >(0x4000)));
  
  cOBResidue.klass = rb_define_class_under(mOpenbabel, "OBResidue", ((swig_class *) SWIGTYPE_p_OpenBabel__OBBase->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBResidue, (void *) &cOBResidue);
  rb_define_alloc_func(cOBResidue.klass, _wrap_OBResidue_allocate);
  rb_define_method(cOBResidue.klass, "initialize", VALUEFUNC(_wrap_new_OBResidue), -1);
  rb_define_method(cOBResidue.klass, "add_atom", VALUEFUNC(_wrap_OBResidue_add_atom), -1);
  rb_define_method(cOBResidue.klass, "insert_atom", VALUEFUNC(_wrap_OBResidue_insert_atom), -1);
  rb_define_method(cOBResidue.klass, "remove_atom", VALUEFUNC(_wrap_OBResidue_remove_atom), -1);
  rb_define_method(cOBResidue.klass, "clear", VALUEFUNC(_wrap_OBResidue_clear), -1);
  rb_define_method(cOBResidue.klass, "set_name", VALUEFUNC(_wrap_OBResidue_set_name), -1);
  rb_define_method(cOBResidue.klass, "set_num", VALUEFUNC(_wrap_OBResidue_set_num), -1);
  rb_define_method(cOBResidue.klass, "set_chain", VALUEFUNC(_wrap_OBResidue_set_chain), -1);
  rb_define_method(cOBResidue.klass, "set_chain_num", VALUEFUNC(_wrap_OBResidue_set_chain_num), -1);
  rb_define_method(cOBResidue.klass, "set_idx", VALUEFUNC(_wrap_OBResidue_set_idx), -1);
  rb_define_method(cOBResidue.klass, "set_atom_id", VALUEFUNC(_wrap_OBResidue_set_atom_id), -1);
  rb_define_method(cOBResidue.klass, "set_het_atom", VALUEFUNC(_wrap_OBResidue_set_het_atom), -1);
  rb_define_method(cOBResidue.klass, "set_serial_num", VALUEFUNC(_wrap_OBResidue_set_serial_num), -1);
  rb_define_method(cOBResidue.klass, "get_name", VALUEFUNC(_wrap_OBResidue_get_name), -1);
  rb_define_method(cOBResidue.klass, "get_num", VALUEFUNC(_wrap_OBResidue_get_num), -1);
  rb_define_method(cOBResidue.klass, "get_num_atoms", VALUEFUNC(_wrap_OBResidue_get_num_atoms), -1);
  rb_define_method(cOBResidue.klass, "get_chain", VALUEFUNC(_wrap_OBResidue_get_chain), -1);
  rb_define_method(cOBResidue.klass, "get_chain_num", VALUEFUNC(_wrap_OBResidue_get_chain_num), -1);
  rb_define_method(cOBResidue.klass, "get_idx", VALUEFUNC(_wrap_OBResidue_get_idx), -1);
  rb_define_method(cOBResidue.klass, "get_res_key", VALUEFUNC(_wrap_OBResidue_get_res_key), -1);
  rb_define_method(cOBResidue.klass, "get_atoms", VALUEFUNC(_wrap_OBResidue_get_atoms), -1);
  rb_define_method(cOBResidue.klass, "get_bonds", VALUEFUNC(_wrap_OBResidue_get_bonds), -1);
  rb_define_method(cOBResidue.klass, "get_atom_id", VALUEFUNC(_wrap_OBResidue_get_atom_id), -1);
  rb_define_method(cOBResidue.klass, "get_serial_num", VALUEFUNC(_wrap_OBResidue_get_serial_num), -1);
  rb_define_method(cOBResidue.klass, "get_amino_acid_property", VALUEFUNC(_wrap_OBResidue_get_amino_acid_property), -1);
  rb_define_method(cOBResidue.klass, "get_atom_property", VALUEFUNC(_wrap_OBResidue_get_atom_property), -1);
  rb_define_method(cOBResidue.klass, "get_residue_property", VALUEFUNC(_wrap_OBResidue_get_residue_property), -1);
  rb_define_method(cOBResidue.klass, "is_het_atom", VALUEFUNC(_wrap_OBResidue_is_het_atom), -1);
  rb_define_method(cOBResidue.klass, "is_residue_type", VALUEFUNC(_wrap_OBResidue_is_residue_type), -1);
  rb_define_method(cOBResidue.klass, "begin_atoms", VALUEFUNC(_wrap_OBResidue_begin_atoms), -1);
  rb_define_method(cOBResidue.klass, "end_atoms", VALUEFUNC(_wrap_OBResidue_end_atoms), -1);
  rb_define_method(cOBResidue.klass, "begin_atom", VALUEFUNC(_wrap_OBResidue_begin_atom), -1);
  rb_define_method(cOBResidue.klass, "next_atom", VALUEFUNC(_wrap_OBResidue_next_atom), -1);
  cOBResidue.mark = 0;
  cOBResidue.destroy = (void (*)(void *)) free_OpenBabel_OBResidue;
  cOBResidue.trackObjects = 0;
  rb_define_const(mOpenbabel, "MAXSETNO", SWIG_From_int(static_cast< int >(40)));
  rb_define_const(mOpenbabel, "MAXELEM", SWIG_From_int(static_cast< int >(1024)));
  rb_define_const(mOpenbabel, "MINELEM", SWIG_From_int(static_cast< int >(29)));
  rb_define_const(mOpenbabel, "MAXRES", SWIG_From_int(static_cast< int >(100)));
  rb_define_const(mOpenbabel, "MINRES", SWIG_From_int(static_cast< int >(54)));
  rb_define_const(mOpenbabel, "AA_ALA", SWIG_From_int(static_cast< int >((1 << 1))));
  rb_define_const(mOpenbabel, "AA_GLY", SWIG_From_int(static_cast< int >((1 << 2))));
  rb_define_const(mOpenbabel, "AA_LEU", SWIG_From_int(static_cast< int >((1 << 3))));
  rb_define_const(mOpenbabel, "AA_SER", SWIG_From_int(static_cast< int >((1 << 4))));
  rb_define_const(mOpenbabel, "AA_VAL", SWIG_From_int(static_cast< int >((1 << 5))));
  rb_define_const(mOpenbabel, "AA_THR", SWIG_From_int(static_cast< int >((1 << 6))));
  rb_define_const(mOpenbabel, "AA_LYS", SWIG_From_int(static_cast< int >((1 << 7))));
  rb_define_const(mOpenbabel, "AA_ASP", SWIG_From_int(static_cast< int >((1 << 8))));
  rb_define_const(mOpenbabel, "AA_ILE", SWIG_From_int(static_cast< int >((1 << 9))));
  rb_define_const(mOpenbabel, "AA_ASN", SWIG_From_int(static_cast< int >((1 << 10))));
  rb_define_const(mOpenbabel, "AA_GLU", SWIG_From_int(static_cast< int >((1 << 11))));
  rb_define_const(mOpenbabel, "AA_PRO", SWIG_From_int(static_cast< int >((1 << 12))));
  rb_define_const(mOpenbabel, "AA_ARG", SWIG_From_int(static_cast< int >((1 << 13))));
  rb_define_const(mOpenbabel, "AA_PHE", SWIG_From_int(static_cast< int >((1 << 14))));
  rb_define_const(mOpenbabel, "AA_GLN", SWIG_From_int(static_cast< int >((1 << 15))));
  rb_define_const(mOpenbabel, "AA_TYR", SWIG_From_int(static_cast< int >((1 << 16))));
  rb_define_const(mOpenbabel, "AA_HIS", SWIG_From_int(static_cast< int >((1 << 17))));
  rb_define_const(mOpenbabel, "AA_CYS", SWIG_From_int(static_cast< int >((1 << 18))));
  rb_define_const(mOpenbabel, "AA_MET", SWIG_From_int(static_cast< int >((1 << 19))));
  rb_define_const(mOpenbabel, "AA_TRP", SWIG_From_int(static_cast< int >((1 << 20))));
  rb_define_const(mOpenbabel, "ACIDIC", SWIG_From_int(static_cast< int >(OpenBabel::OBAminoAcidProperty::ACIDIC)));
  rb_define_const(mOpenbabel, "ACYCLIC", SWIG_From_int(static_cast< int >(OpenBabel::OBAminoAcidProperty::ACYCLIC)));
  rb_define_const(mOpenbabel, "ALIPHATIC", SWIG_From_int(static_cast< int >(OpenBabel::OBAminoAcidProperty::ALIPHATIC)));
  rb_define_const(mOpenbabel, "AROMATIC", SWIG_From_int(static_cast< int >(OpenBabel::OBAminoAcidProperty::AROMATIC)));
  rb_define_const(mOpenbabel, "BASIC", SWIG_From_int(static_cast< int >(OpenBabel::OBAminoAcidProperty::BASIC)));
  rb_define_const(mOpenbabel, "BURIED", SWIG_From_int(static_cast< int >(OpenBabel::OBAminoAcidProperty::BURIED)));
  rb_define_const(mOpenbabel, "CHARGED", SWIG_From_int(static_cast< int >(OpenBabel::OBAminoAcidProperty::CHARGED)));
  rb_define_const(mOpenbabel, "CYCLIC", SWIG_From_int(static_cast< int >(OpenBabel::OBAminoAcidProperty::CYCLIC)));
  rb_define_const(mOpenbabel, "HYDROPHOBIC", SWIG_From_int(static_cast< int >(OpenBabel::OBAminoAcidProperty::HYDROPHOBIC)));
  rb_define_const(mOpenbabel, "LARGE", SWIG_From_int(static_cast< int >(OpenBabel::OBAminoAcidProperty::LARGE)));
  rb_define_const(mOpenbabel, "MEDIUM", SWIG_From_int(static_cast< int >(OpenBabel::OBAminoAcidProperty::MEDIUM)));
  rb_define_const(mOpenbabel, "NEGATIVE", SWIG_From_int(static_cast< int >(OpenBabel::OBAminoAcidProperty::NEGATIVE)));
  rb_define_const(mOpenbabel, "NEUTRAL", SWIG_From_int(static_cast< int >(OpenBabel::OBAminoAcidProperty::NEUTRAL)));
  rb_define_const(mOpenbabel, "POLAR", SWIG_From_int(static_cast< int >(OpenBabel::OBAminoAcidProperty::POLAR)));
  rb_define_const(mOpenbabel, "POSITIVE", SWIG_From_int(static_cast< int >(OpenBabel::OBAminoAcidProperty::POSITIVE)));
  rb_define_const(mOpenbabel, "SMALL", SWIG_From_int(static_cast< int >(OpenBabel::OBAminoAcidProperty::SMALL)));
  rb_define_const(mOpenbabel, "SURFACE", SWIG_From_int(static_cast< int >(OpenBabel::OBAminoAcidProperty::SURFACE)));
  rb_define_const(mOpenbabel, "ALPHA_CARBON", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueAtomProperty::ALPHA_CARBON)));
  rb_define_const(mOpenbabel, "AMINO_BACKBONE", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueAtomProperty::AMINO_BACKBONE)));
  rb_define_const(mOpenbabel, "BACKBONE", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueAtomProperty::BACKBONE)));
  rb_define_const(mOpenbabel, "CYSTEINE_SULPHUR", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueAtomProperty::CYSTEINE_SULPHUR)));
  rb_define_const(mOpenbabel, "LIGAND", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueAtomProperty::LIGAND)));
  rb_define_const(mOpenbabel, "NUCLEIC_BACKBONE", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueAtomProperty::NUCLEIC_BACKBONE)));
  rb_define_const(mOpenbabel, "SHAPELY_BACKBONE", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueAtomProperty::SHAPELY_BACKBONE)));
  rb_define_const(mOpenbabel, "SHAPELY_SPECIAL", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueAtomProperty::SHAPELY_SPECIAL)));
  rb_define_const(mOpenbabel, "SIDECHAIN", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueAtomProperty::SIDECHAIN)));
  rb_define_const(mOpenbabel, "SUGAR_PHOSPHATE", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueAtomProperty::SUGAR_PHOSPHATE)));
  rb_define_const(mOpenbabel, "ALA", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::ALA)));
  rb_define_const(mOpenbabel, "GLY", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::GLY)));
  rb_define_const(mOpenbabel, "LEU", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::LEU)));
  rb_define_const(mOpenbabel, "SER", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::SER)));
  rb_define_const(mOpenbabel, "VAL", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::VAL)));
  rb_define_const(mOpenbabel, "THR", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::THR)));
  rb_define_const(mOpenbabel, "LYS", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::LYS)));
  rb_define_const(mOpenbabel, "ASP", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::ASP)));
  rb_define_const(mOpenbabel, "ILE", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::ILE)));
  rb_define_const(mOpenbabel, "ASN", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::ASN)));
  rb_define_const(mOpenbabel, "GLU", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::GLU)));
  rb_define_const(mOpenbabel, "PRO", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::PRO)));
  rb_define_const(mOpenbabel, "ARG", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::ARG)));
  rb_define_const(mOpenbabel, "PHE", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::PHE)));
  rb_define_const(mOpenbabel, "GLN", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::GLN)));
  rb_define_const(mOpenbabel, "TYR", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::TYR)));
  rb_define_const(mOpenbabel, "HIS", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::HIS)));
  rb_define_const(mOpenbabel, "CYS", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::CYS)));
  rb_define_const(mOpenbabel, "MET", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::MET)));
  rb_define_const(mOpenbabel, "TRP", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::TRP)));
  rb_define_const(mOpenbabel, "ASX", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::ASX)));
  rb_define_const(mOpenbabel, "GLX", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::GLX)));
  rb_define_const(mOpenbabel, "PCA", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::PCA)));
  rb_define_const(mOpenbabel, "HYP", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::HYP)));
  rb_define_const(mOpenbabel, "A", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::A)));
  rb_define_const(mOpenbabel, "C", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::C)));
  rb_define_const(mOpenbabel, "G", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::G)));
  rb_define_const(mOpenbabel, "T", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::T)));
  rb_define_const(mOpenbabel, "U", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::U)));
  rb_define_const(mOpenbabel, "UPLUS", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::UPLUS)));
  rb_define_const(mOpenbabel, "I", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::I)));
  rb_define_const(mOpenbabel, "U1MA", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::_1MA)));
  rb_define_const(mOpenbabel, "U5MC", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::_5MC)));
  rb_define_const(mOpenbabel, "OMC", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::OMC)));
  rb_define_const(mOpenbabel, "U1MG", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::_1MG)));
  rb_define_const(mOpenbabel, "U2MG", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::_2MG)));
  rb_define_const(mOpenbabel, "M2G", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::M2G)));
  rb_define_const(mOpenbabel, "U7MG", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::_7MG)));
  rb_define_const(mOpenbabel, "OMG", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::OMG)));
  rb_define_const(mOpenbabel, "YG", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::YG)));
  rb_define_const(mOpenbabel, "H2U", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::H2U)));
  rb_define_const(mOpenbabel, "U5MU", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::_5MU)));
  rb_define_const(mOpenbabel, "PSU", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::PSU)));
  rb_define_const(mOpenbabel, "UNK", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::UNK)));
  rb_define_const(mOpenbabel, "ACE", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::ACE)));
  rb_define_const(mOpenbabel, "FOR", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::FOR)));
  rb_define_const(mOpenbabel, "HOH", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::HOH)));
  rb_define_const(mOpenbabel, "DOD", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::DOD)));
  rb_define_const(mOpenbabel, "SO4", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::SO4)));
  rb_define_const(mOpenbabel, "PO4", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::PO4)));
  rb_define_const(mOpenbabel, "NAD", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::NAD)));
  rb_define_const(mOpenbabel, "COA", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::COA)));
  rb_define_const(mOpenbabel, "NAP", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::NAP)));
  rb_define_const(mOpenbabel, "NDP", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::NDP)));
  rb_define_const(mOpenbabel, "AMINO", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueProperty::AMINO)));
  rb_define_const(mOpenbabel, "AMINO_NUCLEO", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueProperty::AMINO_NUCLEO)));
  rb_define_const(mOpenbabel, "COENZYME", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueProperty::COENZYME)));
  rb_define_const(mOpenbabel, "ION", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueProperty::ION)));
  rb_define_const(mOpenbabel, "NUCLEO", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueProperty::NUCLEO)));
  rb_define_const(mOpenbabel, "PROTEIN", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueProperty::PROTEIN)));
  rb_define_const(mOpenbabel, "PURINE", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueProperty::PURINE)));
  rb_define_const(mOpenbabel, "PYRIMIDINE", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueProperty::PYRIMIDINE)));
  rb_define_const(mOpenbabel, "SOLVENT", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueProperty::SOLVENT)));
  rb_define_const(mOpenbabel, "WATER", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueProperty::WATER)));
  rb_define_singleton_method(mOpenbabel, "Residue", VALUEFUNC(Residue_get), 0);
  rb_define_singleton_method(mOpenbabel, "Residue=", VALUEFUNC(Residue_set), 1);
  rb_define_singleton_method(mOpenbabel, "ElemDesc", VALUEFUNC(ElemDesc_get), 0);
  rb_define_singleton_method(mOpenbabel, "ElemDesc=", VALUEFUNC(ElemDesc_set), 1);
  rb_define_singleton_method(mOpenbabel, "ResNo", VALUEFUNC(ResNo_get), 0);
  rb_define_singleton_method(mOpenbabel, "ResNo=", VALUEFUNC(ResNo_set), 1);
  rb_define_singleton_method(mOpenbabel, "ElemNo", VALUEFUNC(ElemNo_get), 0);
  rb_define_singleton_method(mOpenbabel, "ElemNo=", VALUEFUNC(ElemNo_set), 1);
  
  cOBInternalCoord.klass = rb_define_class_under(mOpenbabel, "OBInternalCoord", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBInternalCoord, (void *) &cOBInternalCoord);
  rb_define_alloc_func(cOBInternalCoord.klass, _wrap_OBInternalCoord_allocate);
  rb_define_method(cOBInternalCoord.klass, "initialize", VALUEFUNC(_wrap_new_OBInternalCoord), -1);
  rb_define_method(cOBInternalCoord.klass, "_a=", VALUEFUNC(_wrap_OBInternalCoord__a_set), -1);
  rb_define_method(cOBInternalCoord.klass, "_a", VALUEFUNC(_wrap_OBInternalCoord__a_get), -1);
  rb_define_method(cOBInternalCoord.klass, "_b=", VALUEFUNC(_wrap_OBInternalCoord__b_set), -1);
  rb_define_method(cOBInternalCoord.klass, "_b", VALUEFUNC(_wrap_OBInternalCoord__b_get), -1);
  rb_define_method(cOBInternalCoord.klass, "_c=", VALUEFUNC(_wrap_OBInternalCoord__c_set), -1);
  rb_define_method(cOBInternalCoord.klass, "_c", VALUEFUNC(_wrap_OBInternalCoord__c_get), -1);
  rb_define_method(cOBInternalCoord.klass, "_dst=", VALUEFUNC(_wrap_OBInternalCoord__dst_set), -1);
  rb_define_method(cOBInternalCoord.klass, "_dst", VALUEFUNC(_wrap_OBInternalCoord__dst_get), -1);
  rb_define_method(cOBInternalCoord.klass, "_ang=", VALUEFUNC(_wrap_OBInternalCoord__ang_set), -1);
  rb_define_method(cOBInternalCoord.klass, "_ang", VALUEFUNC(_wrap_OBInternalCoord__ang_get), -1);
  rb_define_method(cOBInternalCoord.klass, "_tor=", VALUEFUNC(_wrap_OBInternalCoord__tor_set), -1);
  rb_define_method(cOBInternalCoord.klass, "_tor", VALUEFUNC(_wrap_OBInternalCoord__tor_get), -1);
  cOBInternalCoord.mark = 0;
  cOBInternalCoord.destroy = (void (*)(void *)) free_OpenBabel_OBInternalCoord;
  cOBInternalCoord.trackObjects = 0;
  rb_define_const(mOpenbabel, "OB_4RING_ATOM", SWIG_From_int(static_cast< int >((1 << 1))));
  rb_define_const(mOpenbabel, "OB_3RING_ATOM", SWIG_From_int(static_cast< int >((1 << 2))));
  rb_define_const(mOpenbabel, "OB_AROMATIC_ATOM", SWIG_From_int(static_cast< int >((1 << 3))));
  rb_define_const(mOpenbabel, "OB_RING_ATOM", SWIG_From_int(static_cast< int >((1 << 4))));
  rb_define_const(mOpenbabel, "OB_CSTEREO_ATOM", SWIG_From_int(static_cast< int >((1 << 5))));
  rb_define_const(mOpenbabel, "OB_ACSTEREO_ATOM", SWIG_From_int(static_cast< int >((1 << 6))));
  rb_define_const(mOpenbabel, "OB_DONOR_ATOM", SWIG_From_int(static_cast< int >((1 << 7))));
  rb_define_const(mOpenbabel, "OB_ACCEPTOR_ATOM", SWIG_From_int(static_cast< int >((1 << 8))));
  rb_define_const(mOpenbabel, "OB_CHIRAL_ATOM", SWIG_From_int(static_cast< int >((1 << 9))));
  rb_define_const(mOpenbabel, "OB_POS_CHIRAL_ATOM", SWIG_From_int(static_cast< int >((1 << 10))));
  rb_define_const(mOpenbabel, "OB_NEG_CHIRAL_ATOM", SWIG_From_int(static_cast< int >((1 << 11))));
  rb_define_const(mOpenbabel, "OB_ATOM_HAS_NO_H", SWIG_From_int(static_cast< int >((1 << 12))));
  
  cOBAtom.klass = rb_define_class_under(mOpenbabel, "OBAtom", ((swig_class *) SWIGTYPE_p_OpenBabel__OBBase->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBAtom, (void *) &cOBAtom);
  rb_define_alloc_func(cOBAtom.klass, _wrap_OBAtom_allocate);
  rb_define_method(cOBAtom.klass, "initialize", VALUEFUNC(_wrap_new_OBAtom), -1);
  rb_define_method(cOBAtom.klass, "Visit=", VALUEFUNC(_wrap_OBAtom_Visit_set), -1);
  rb_define_method(cOBAtom.klass, "Visit", VALUEFUNC(_wrap_OBAtom_Visit_get), -1);
  rb_define_method(cOBAtom.klass, "clear", VALUEFUNC(_wrap_OBAtom_clear), -1);
  rb_define_method(cOBAtom.klass, "set_idx", VALUEFUNC(_wrap_OBAtom_set_idx), -1);
  rb_define_method(cOBAtom.klass, "set_hyb", VALUEFUNC(_wrap_OBAtom_set_hyb), -1);
  rb_define_method(cOBAtom.klass, "set_atomic_num", VALUEFUNC(_wrap_OBAtom_set_atomic_num), -1);
  rb_define_method(cOBAtom.klass, "set_isotope", VALUEFUNC(_wrap_OBAtom_set_isotope), -1);
  rb_define_method(cOBAtom.klass, "set_implicit_valence", VALUEFUNC(_wrap_OBAtom_set_implicit_valence), -1);
  rb_define_method(cOBAtom.klass, "increment_implicit_valence", VALUEFUNC(_wrap_OBAtom_increment_implicit_valence), -1);
  rb_define_method(cOBAtom.klass, "decrement_implicit_valence", VALUEFUNC(_wrap_OBAtom_decrement_implicit_valence), -1);
  rb_define_method(cOBAtom.klass, "set_formal_charge", VALUEFUNC(_wrap_OBAtom_set_formal_charge), -1);
  rb_define_method(cOBAtom.klass, "set_spin_multiplicity", VALUEFUNC(_wrap_OBAtom_set_spin_multiplicity), -1);
  rb_define_method(cOBAtom.klass, "set_type", VALUEFUNC(_wrap_OBAtom_set_type), -1);
  rb_define_method(cOBAtom.klass, "set_partial_charge", VALUEFUNC(_wrap_OBAtom_set_partial_charge), -1);
  rb_define_method(cOBAtom.klass, "set_coord_ptr", VALUEFUNC(_wrap_OBAtom_set_coord_ptr), -1);
  rb_define_method(cOBAtom.klass, "set_vector", VALUEFUNC(_wrap_OBAtom_set_vector), -1);
  rb_define_method(cOBAtom.klass, "set_residue", VALUEFUNC(_wrap_OBAtom_set_residue), -1);
  rb_define_method(cOBAtom.klass, "set_parent", VALUEFUNC(_wrap_OBAtom_set_parent), -1);
  rb_define_method(cOBAtom.klass, "set_aromatic", VALUEFUNC(_wrap_OBAtom_set_aromatic), -1);
  rb_define_method(cOBAtom.klass, "unset_aromatic", VALUEFUNC(_wrap_OBAtom_unset_aromatic), -1);
  rb_define_method(cOBAtom.klass, "set_clockwise_stereo", VALUEFUNC(_wrap_OBAtom_set_clockwise_stereo), -1);
  rb_define_method(cOBAtom.klass, "set_anti_clockwise_stereo", VALUEFUNC(_wrap_OBAtom_set_anti_clockwise_stereo), -1);
  rb_define_method(cOBAtom.klass, "set_positive_stereo", VALUEFUNC(_wrap_OBAtom_set_positive_stereo), -1);
  rb_define_method(cOBAtom.klass, "set_negative_stereo", VALUEFUNC(_wrap_OBAtom_set_negative_stereo), -1);
  rb_define_method(cOBAtom.klass, "unset_stereo", VALUEFUNC(_wrap_OBAtom_unset_stereo), -1);
  rb_define_method(cOBAtom.klass, "set_in_ring", VALUEFUNC(_wrap_OBAtom_set_in_ring), -1);
  rb_define_method(cOBAtom.klass, "set_chiral", VALUEFUNC(_wrap_OBAtom_set_chiral), -1);
  rb_define_method(cOBAtom.klass, "clear_coord_ptr", VALUEFUNC(_wrap_OBAtom_clear_coord_ptr), -1);
  rb_define_method(cOBAtom.klass, "get_formal_charge", VALUEFUNC(_wrap_OBAtom_get_formal_charge), -1);
  rb_define_method(cOBAtom.klass, "get_atomic_num", VALUEFUNC(_wrap_OBAtom_get_atomic_num), -1);
  rb_define_method(cOBAtom.klass, "get_isotope", VALUEFUNC(_wrap_OBAtom_get_isotope), -1);
  rb_define_method(cOBAtom.klass, "get_spin_multiplicity", VALUEFUNC(_wrap_OBAtom_get_spin_multiplicity), -1);
  rb_define_method(cOBAtom.klass, "get_atomic_mass", VALUEFUNC(_wrap_OBAtom_get_atomic_mass), -1);
  rb_define_method(cOBAtom.klass, "get_exact_mass", VALUEFUNC(_wrap_OBAtom_get_exact_mass), -1);
  rb_define_method(cOBAtom.klass, "get_idx", VALUEFUNC(_wrap_OBAtom_get_idx), -1);
  rb_define_method(cOBAtom.klass, "get_coordinate_idx", VALUEFUNC(_wrap_OBAtom_get_coordinate_idx), -1);
  rb_define_method(cOBAtom.klass, "get_cidx", VALUEFUNC(_wrap_OBAtom_get_cidx), -1);
  rb_define_method(cOBAtom.klass, "get_valence", VALUEFUNC(_wrap_OBAtom_get_valence), -1);
  rb_define_method(cOBAtom.klass, "get_hyb", VALUEFUNC(_wrap_OBAtom_get_hyb), -1);
  rb_define_method(cOBAtom.klass, "get_implicit_valence", VALUEFUNC(_wrap_OBAtom_get_implicit_valence), -1);
  rb_define_method(cOBAtom.klass, "get_hvy_valence", VALUEFUNC(_wrap_OBAtom_get_hvy_valence), -1);
  rb_define_method(cOBAtom.klass, "get_hetero_valence", VALUEFUNC(_wrap_OBAtom_get_hetero_valence), -1);
  rb_define_method(cOBAtom.klass, "get_type", VALUEFUNC(_wrap_OBAtom_get_type), -1);
  rb_define_method(cOBAtom.klass, "get_x", VALUEFUNC(_wrap_OBAtom_get_x), -1);
  rb_define_method(cOBAtom.klass, "get_y", VALUEFUNC(_wrap_OBAtom_get_y), -1);
  rb_define_method(cOBAtom.klass, "get_z", VALUEFUNC(_wrap_OBAtom_get_z), -1);
  rb_define_method(cOBAtom.klass, "x", VALUEFUNC(_wrap_OBAtom_x), -1);
  rb_define_method(cOBAtom.klass, "y", VALUEFUNC(_wrap_OBAtom_y), -1);
  rb_define_method(cOBAtom.klass, "z", VALUEFUNC(_wrap_OBAtom_z), -1);
  rb_define_method(cOBAtom.klass, "get_coordinate", VALUEFUNC(_wrap_OBAtom_get_coordinate), -1);
  rb_define_method(cOBAtom.klass, "get_vector", VALUEFUNC(_wrap_OBAtom_get_vector), -1);
  rb_define_method(cOBAtom.klass, "get_partial_charge", VALUEFUNC(_wrap_OBAtom_get_partial_charge), -1);
  rb_define_method(cOBAtom.klass, "get_residue", VALUEFUNC(_wrap_OBAtom_get_residue), -1);
  rb_define_method(cOBAtom.klass, "get_parent", VALUEFUNC(_wrap_OBAtom_get_parent), -1);
  rb_define_method(cOBAtom.klass, "get_new_bond_vector", VALUEFUNC(_wrap_OBAtom_get_new_bond_vector), -1);
  rb_define_method(cOBAtom.klass, "get_bond", VALUEFUNC(_wrap_OBAtom_get_bond), -1);
  rb_define_method(cOBAtom.klass, "get_next_atom", VALUEFUNC(_wrap_OBAtom_get_next_atom), -1);
  rb_define_method(cOBAtom.klass, "begin_bonds", VALUEFUNC(_wrap_OBAtom_begin_bonds), -1);
  rb_define_method(cOBAtom.klass, "end_bonds", VALUEFUNC(_wrap_OBAtom_end_bonds), -1);
  rb_define_method(cOBAtom.klass, "begin_bond", VALUEFUNC(_wrap_OBAtom_begin_bond), -1);
  rb_define_method(cOBAtom.klass, "next_bond", VALUEFUNC(_wrap_OBAtom_next_bond), -1);
  rb_define_method(cOBAtom.klass, "begin_nbr_atom", VALUEFUNC(_wrap_OBAtom_begin_nbr_atom), -1);
  rb_define_method(cOBAtom.klass, "next_nbr_atom", VALUEFUNC(_wrap_OBAtom_next_nbr_atom), -1);
  rb_define_method(cOBAtom.klass, "get_distance", VALUEFUNC(_wrap_OBAtom_get_distance), -1);
  rb_define_method(cOBAtom.klass, "get_angle", VALUEFUNC(_wrap_OBAtom_get_angle), -1);
  rb_define_method(cOBAtom.klass, "new_residue", VALUEFUNC(_wrap_OBAtom_new_residue), -1);
  rb_define_method(cOBAtom.klass, "add_residue", VALUEFUNC(_wrap_OBAtom_add_residue), -1);
  rb_define_method(cOBAtom.klass, "delete_residue", VALUEFUNC(_wrap_OBAtom_delete_residue), -1);
  rb_define_method(cOBAtom.klass, "add_bond", VALUEFUNC(_wrap_OBAtom_add_bond), -1);
  rb_define_method(cOBAtom.klass, "insert_bond", VALUEFUNC(_wrap_OBAtom_insert_bond), -1);
  rb_define_method(cOBAtom.klass, "delete_bond", VALUEFUNC(_wrap_OBAtom_delete_bond), -1);
  rb_define_method(cOBAtom.klass, "clear_bond", VALUEFUNC(_wrap_OBAtom_clear_bond), -1);
  rb_define_method(cOBAtom.klass, "hto_methyl", VALUEFUNC(_wrap_OBAtom_hto_methyl), -1);
  rb_define_method(cOBAtom.klass, "set_hyb_and_geom", VALUEFUNC(_wrap_OBAtom_set_hyb_and_geom), -1);
  rb_define_method(cOBAtom.klass, "force_no_h", VALUEFUNC(_wrap_OBAtom_force_no_h), -1);
  rb_define_method(cOBAtom.klass, "has_no_hforced", VALUEFUNC(_wrap_OBAtom_has_no_hforced), -1);
  rb_define_method(cOBAtom.klass, "count_free_oxygens", VALUEFUNC(_wrap_OBAtom_count_free_oxygens), -1);
  rb_define_method(cOBAtom.klass, "implicit_hydrogen_count", VALUEFUNC(_wrap_OBAtom_implicit_hydrogen_count), -1);
  rb_define_method(cOBAtom.klass, "explicit_hydrogen_count", VALUEFUNC(_wrap_OBAtom_explicit_hydrogen_count), -1);
  rb_define_method(cOBAtom.klass, "member_of_ring_count", VALUEFUNC(_wrap_OBAtom_member_of_ring_count), -1);
  rb_define_method(cOBAtom.klass, "member_of_ring_size", VALUEFUNC(_wrap_OBAtom_member_of_ring_size), -1);
  rb_define_method(cOBAtom.klass, "count_ring_bonds", VALUEFUNC(_wrap_OBAtom_count_ring_bonds), -1);
  rb_define_method(cOBAtom.klass, "smallest_bond_angle", VALUEFUNC(_wrap_OBAtom_smallest_bond_angle), -1);
  rb_define_method(cOBAtom.klass, "average_bond_angle", VALUEFUNC(_wrap_OBAtom_average_bond_angle), -1);
  rb_define_method(cOBAtom.klass, "bosum", VALUEFUNC(_wrap_OBAtom_bosum), -1);
  rb_define_method(cOBAtom.klass, "kbosum", VALUEFUNC(_wrap_OBAtom_kbosum), -1);
  rb_define_method(cOBAtom.klass, "has_residue", VALUEFUNC(_wrap_OBAtom_has_residue), -1);
  rb_define_method(cOBAtom.klass, "is_hydrogen", VALUEFUNC(_wrap_OBAtom_is_hydrogen), -1);
  rb_define_method(cOBAtom.klass, "is_carbon", VALUEFUNC(_wrap_OBAtom_is_carbon), -1);
  rb_define_method(cOBAtom.klass, "is_nitrogen", VALUEFUNC(_wrap_OBAtom_is_nitrogen), -1);
  rb_define_method(cOBAtom.klass, "is_oxygen", VALUEFUNC(_wrap_OBAtom_is_oxygen), -1);
  rb_define_method(cOBAtom.klass, "is_sulfur", VALUEFUNC(_wrap_OBAtom_is_sulfur), -1);
  rb_define_method(cOBAtom.klass, "is_phosphorus", VALUEFUNC(_wrap_OBAtom_is_phosphorus), -1);
  rb_define_method(cOBAtom.klass, "is_aromatic", VALUEFUNC(_wrap_OBAtom_is_aromatic), -1);
  rb_define_method(cOBAtom.klass, "is_in_ring", VALUEFUNC(_wrap_OBAtom_is_in_ring), -1);
  rb_define_method(cOBAtom.klass, "is_in_ring_size", VALUEFUNC(_wrap_OBAtom_is_in_ring_size), -1);
  rb_define_method(cOBAtom.klass, "is_heteroatom", VALUEFUNC(_wrap_OBAtom_is_heteroatom), -1);
  rb_define_method(cOBAtom.klass, "is_not_cor_h", VALUEFUNC(_wrap_OBAtom_is_not_cor_h), -1);
  rb_define_method(cOBAtom.klass, "is_connected", VALUEFUNC(_wrap_OBAtom_is_connected), -1);
  rb_define_method(cOBAtom.klass, "is_one_three", VALUEFUNC(_wrap_OBAtom_is_one_three), -1);
  rb_define_method(cOBAtom.klass, "is_one_four", VALUEFUNC(_wrap_OBAtom_is_one_four), -1);
  rb_define_method(cOBAtom.klass, "is_carboxyl_oxygen", VALUEFUNC(_wrap_OBAtom_is_carboxyl_oxygen), -1);
  rb_define_method(cOBAtom.klass, "is_phosphate_oxygen", VALUEFUNC(_wrap_OBAtom_is_phosphate_oxygen), -1);
  rb_define_method(cOBAtom.klass, "is_sulfate_oxygen", VALUEFUNC(_wrap_OBAtom_is_sulfate_oxygen), -1);
  rb_define_method(cOBAtom.klass, "is_nitro_oxygen", VALUEFUNC(_wrap_OBAtom_is_nitro_oxygen), -1);
  rb_define_method(cOBAtom.klass, "is_amide_nitrogen", VALUEFUNC(_wrap_OBAtom_is_amide_nitrogen), -1);
  rb_define_method(cOBAtom.klass, "is_polar_hydrogen", VALUEFUNC(_wrap_OBAtom_is_polar_hydrogen), -1);
  rb_define_method(cOBAtom.klass, "is_non_polar_hydrogen", VALUEFUNC(_wrap_OBAtom_is_non_polar_hydrogen), -1);
  rb_define_method(cOBAtom.klass, "is_aromatic_noxide", VALUEFUNC(_wrap_OBAtom_is_aromatic_noxide), -1);
  rb_define_method(cOBAtom.klass, "is_chiral", VALUEFUNC(_wrap_OBAtom_is_chiral), -1);
  rb_define_method(cOBAtom.klass, "is_axial", VALUEFUNC(_wrap_OBAtom_is_axial), -1);
  rb_define_method(cOBAtom.klass, "is_clockwise", VALUEFUNC(_wrap_OBAtom_is_clockwise), -1);
  rb_define_method(cOBAtom.klass, "is_anti_clockwise", VALUEFUNC(_wrap_OBAtom_is_anti_clockwise), -1);
  rb_define_method(cOBAtom.klass, "is_positive_stereo", VALUEFUNC(_wrap_OBAtom_is_positive_stereo), -1);
  rb_define_method(cOBAtom.klass, "is_negative_stereo", VALUEFUNC(_wrap_OBAtom_is_negative_stereo), -1);
  rb_define_method(cOBAtom.klass, "has_chirality_specified", VALUEFUNC(_wrap_OBAtom_has_chirality_specified), -1);
  rb_define_method(cOBAtom.klass, "has_chiral_volume", VALUEFUNC(_wrap_OBAtom_has_chiral_volume), -1);
  rb_define_method(cOBAtom.klass, "is_hbond_acceptor", VALUEFUNC(_wrap_OBAtom_is_hbond_acceptor), -1);
  rb_define_method(cOBAtom.klass, "is_hbond_donor", VALUEFUNC(_wrap_OBAtom_is_hbond_donor), -1);
  rb_define_method(cOBAtom.klass, "is_hbond_donor_h", VALUEFUNC(_wrap_OBAtom_is_hbond_donor_h), -1);
  rb_define_method(cOBAtom.klass, "has_alpha_beta_unsat", VALUEFUNC(_wrap_OBAtom_has_alpha_beta_unsat), -1);
  rb_define_method(cOBAtom.klass, "has_bond_of_order", VALUEFUNC(_wrap_OBAtom_has_bond_of_order), -1);
  rb_define_method(cOBAtom.klass, "count_bonds_of_order", VALUEFUNC(_wrap_OBAtom_count_bonds_of_order), -1);
  rb_define_method(cOBAtom.klass, "has_non_single_bond", VALUEFUNC(_wrap_OBAtom_has_non_single_bond), -1);
  rb_define_method(cOBAtom.klass, "has_single_bond", VALUEFUNC(_wrap_OBAtom_has_single_bond), -1);
  rb_define_method(cOBAtom.klass, "has_double_bond", VALUEFUNC(_wrap_OBAtom_has_double_bond), -1);
  rb_define_method(cOBAtom.klass, "has_aromatic_bond", VALUEFUNC(_wrap_OBAtom_has_aromatic_bond), -1);
  rb_define_method(cOBAtom.klass, "matches_smarts", VALUEFUNC(_wrap_OBAtom_matches_smarts), -1);
  cOBAtom.mark = 0;
  cOBAtom.destroy = (void (*)(void *)) free_OpenBabel_OBAtom;
  cOBAtom.trackObjects = 0;
  rb_define_const(mOpenbabel, "OB_AROMATIC_BOND", SWIG_From_int(static_cast< int >((1 << 1))));
  rb_define_const(mOpenbabel, "OB_WEDGE_BOND", SWIG_From_int(static_cast< int >((1 << 2))));
  rb_define_const(mOpenbabel, "OB_HASH_BOND", SWIG_From_int(static_cast< int >((1 << 3))));
  rb_define_const(mOpenbabel, "OB_RING_BOND", SWIG_From_int(static_cast< int >((1 << 4))));
  rb_define_const(mOpenbabel, "OB_TORUP_BOND", SWIG_From_int(static_cast< int >((1 << 5))));
  rb_define_const(mOpenbabel, "OB_TORDOWN_BOND", SWIG_From_int(static_cast< int >((1 << 6))));
  rb_define_const(mOpenbabel, "OB_KSINGLE_BOND", SWIG_From_int(static_cast< int >((1 << 7))));
  rb_define_const(mOpenbabel, "OB_KDOUBLE_BOND", SWIG_From_int(static_cast< int >((1 << 8))));
  rb_define_const(mOpenbabel, "OB_KTRIPLE_BOND", SWIG_From_int(static_cast< int >((1 << 9))));
  rb_define_const(mOpenbabel, "OB_CLOSURE_BOND", SWIG_From_int(static_cast< int >((1 << 10))));
  
  cOBBond.klass = rb_define_class_under(mOpenbabel, "OBBond", ((swig_class *) SWIGTYPE_p_OpenBabel__OBBase->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBBond, (void *) &cOBBond);
  rb_define_alloc_func(cOBBond.klass, _wrap_OBBond_allocate);
  rb_define_method(cOBBond.klass, "initialize", VALUEFUNC(_wrap_new_OBBond), -1);
  rb_define_method(cOBBond.klass, "Visit=", VALUEFUNC(_wrap_OBBond_Visit_set), -1);
  rb_define_method(cOBBond.klass, "Visit", VALUEFUNC(_wrap_OBBond_Visit_get), -1);
  rb_define_method(cOBBond.klass, "set_idx", VALUEFUNC(_wrap_OBBond_set_idx), -1);
  rb_define_method(cOBBond.klass, "set_bo", VALUEFUNC(_wrap_OBBond_set_bo), -1);
  rb_define_method(cOBBond.klass, "set_bond_order", VALUEFUNC(_wrap_OBBond_set_bond_order), -1);
  rb_define_method(cOBBond.klass, "set_begin", VALUEFUNC(_wrap_OBBond_set_begin), -1);
  rb_define_method(cOBBond.klass, "set_end", VALUEFUNC(_wrap_OBBond_set_end), -1);
  rb_define_method(cOBBond.klass, "set_parent", VALUEFUNC(_wrap_OBBond_set_parent), -1);
  rb_define_method(cOBBond.klass, "set_length", VALUEFUNC(_wrap_OBBond_set_length), -1);
  rb_define_method(cOBBond.klass, "set", VALUEFUNC(_wrap_OBBond_set), -1);
  rb_define_method(cOBBond.klass, "set_ksingle", VALUEFUNC(_wrap_OBBond_set_ksingle), -1);
  rb_define_method(cOBBond.klass, "set_kdouble", VALUEFUNC(_wrap_OBBond_set_kdouble), -1);
  rb_define_method(cOBBond.klass, "set_ktriple", VALUEFUNC(_wrap_OBBond_set_ktriple), -1);
  rb_define_method(cOBBond.klass, "set_aromatic", VALUEFUNC(_wrap_OBBond_set_aromatic), -1);
  rb_define_method(cOBBond.klass, "set_hash", VALUEFUNC(_wrap_OBBond_set_hash), -1);
  rb_define_method(cOBBond.klass, "set_wedge", VALUEFUNC(_wrap_OBBond_set_wedge), -1);
  rb_define_method(cOBBond.klass, "set_up", VALUEFUNC(_wrap_OBBond_set_up), -1);
  rb_define_method(cOBBond.klass, "set_down", VALUEFUNC(_wrap_OBBond_set_down), -1);
  rb_define_method(cOBBond.klass, "set_in_ring", VALUEFUNC(_wrap_OBBond_set_in_ring), -1);
  rb_define_method(cOBBond.klass, "set_closure", VALUEFUNC(_wrap_OBBond_set_closure), -1);
  rb_define_method(cOBBond.klass, "unset_hash", VALUEFUNC(_wrap_OBBond_unset_hash), -1);
  rb_define_method(cOBBond.klass, "unset_wedge", VALUEFUNC(_wrap_OBBond_unset_wedge), -1);
  rb_define_method(cOBBond.klass, "unset_up", VALUEFUNC(_wrap_OBBond_unset_up), -1);
  rb_define_method(cOBBond.klass, "unset_down", VALUEFUNC(_wrap_OBBond_unset_down), -1);
  rb_define_method(cOBBond.klass, "unset_aromatic", VALUEFUNC(_wrap_OBBond_unset_aromatic), -1);
  rb_define_method(cOBBond.klass, "unset_kekule", VALUEFUNC(_wrap_OBBond_unset_kekule), -1);
  rb_define_method(cOBBond.klass, "get_idx", VALUEFUNC(_wrap_OBBond_get_idx), -1);
  rb_define_method(cOBBond.klass, "get_bo", VALUEFUNC(_wrap_OBBond_get_bo), -1);
  rb_define_method(cOBBond.klass, "get_bond_order", VALUEFUNC(_wrap_OBBond_get_bond_order), -1);
  rb_define_method(cOBBond.klass, "get_flags", VALUEFUNC(_wrap_OBBond_get_flags), -1);
  rb_define_method(cOBBond.klass, "get_begin_atom_idx", VALUEFUNC(_wrap_OBBond_get_begin_atom_idx), -1);
  rb_define_method(cOBBond.klass, "get_end_atom_idx", VALUEFUNC(_wrap_OBBond_get_end_atom_idx), -1);
  rb_define_method(cOBBond.klass, "get_begin_atom", VALUEFUNC(_wrap_OBBond_get_begin_atom), -1);
  rb_define_method(cOBBond.klass, "get_end_atom", VALUEFUNC(_wrap_OBBond_get_end_atom), -1);
  rb_define_method(cOBBond.klass, "get_nbr_atom", VALUEFUNC(_wrap_OBBond_get_nbr_atom), -1);
  rb_define_method(cOBBond.klass, "get_parent", VALUEFUNC(_wrap_OBBond_get_parent), -1);
  rb_define_method(cOBBond.klass, "get_equib_length", VALUEFUNC(_wrap_OBBond_get_equib_length), -1);
  rb_define_method(cOBBond.klass, "get_length", VALUEFUNC(_wrap_OBBond_get_length), -1);
  rb_define_method(cOBBond.klass, "get_nbr_atom_idx", VALUEFUNC(_wrap_OBBond_get_nbr_atom_idx), -1);
  rb_define_method(cOBBond.klass, "is_aromatic", VALUEFUNC(_wrap_OBBond_is_aromatic), -1);
  rb_define_method(cOBBond.klass, "is_in_ring", VALUEFUNC(_wrap_OBBond_is_in_ring), -1);
  rb_define_method(cOBBond.klass, "is_rotor", VALUEFUNC(_wrap_OBBond_is_rotor), -1);
  rb_define_method(cOBBond.klass, "is_amide", VALUEFUNC(_wrap_OBBond_is_amide), -1);
  rb_define_method(cOBBond.klass, "is_primary_amide", VALUEFUNC(_wrap_OBBond_is_primary_amide), -1);
  rb_define_method(cOBBond.klass, "is_secondary_amide", VALUEFUNC(_wrap_OBBond_is_secondary_amide), -1);
  rb_define_method(cOBBond.klass, "is_ester", VALUEFUNC(_wrap_OBBond_is_ester), -1);
  rb_define_method(cOBBond.klass, "is_carbonyl", VALUEFUNC(_wrap_OBBond_is_carbonyl), -1);
  rb_define_method(cOBBond.klass, "is_single", VALUEFUNC(_wrap_OBBond_is_single), -1);
  rb_define_method(cOBBond.klass, "is_double", VALUEFUNC(_wrap_OBBond_is_double), -1);
  rb_define_method(cOBBond.klass, "is_triple", VALUEFUNC(_wrap_OBBond_is_triple), -1);
  rb_define_method(cOBBond.klass, "is_ksingle", VALUEFUNC(_wrap_OBBond_is_ksingle), -1);
  rb_define_method(cOBBond.klass, "is_kdouble", VALUEFUNC(_wrap_OBBond_is_kdouble), -1);
  rb_define_method(cOBBond.klass, "is_ktriple", VALUEFUNC(_wrap_OBBond_is_ktriple), -1);
  rb_define_method(cOBBond.klass, "is_closure", VALUEFUNC(_wrap_OBBond_is_closure), -1);
  rb_define_method(cOBBond.klass, "is_up", VALUEFUNC(_wrap_OBBond_is_up), -1);
  rb_define_method(cOBBond.klass, "is_down", VALUEFUNC(_wrap_OBBond_is_down), -1);
  rb_define_method(cOBBond.klass, "is_wedge", VALUEFUNC(_wrap_OBBond_is_wedge), -1);
  rb_define_method(cOBBond.klass, "is_hash", VALUEFUNC(_wrap_OBBond_is_hash), -1);
  rb_define_method(cOBBond.klass, "is_double_bond_geometry", VALUEFUNC(_wrap_OBBond_is_double_bond_geometry), -1);
  cOBBond.mark = 0;
  cOBBond.destroy = (void (*)(void *)) free_OpenBabel_OBBond;
  cOBBond.trackObjects = 0;
  rb_define_const(mOpenbabel, "OB_SSSR_MOL", SWIG_From_int(static_cast< int >((1 << 1))));
  rb_define_const(mOpenbabel, "OB_RINGFLAGS_MOL", SWIG_From_int(static_cast< int >((1 << 2))));
  rb_define_const(mOpenbabel, "OB_AROMATIC_MOL", SWIG_From_int(static_cast< int >((1 << 3))));
  rb_define_const(mOpenbabel, "OB_ATOMTYPES_MOL", SWIG_From_int(static_cast< int >((1 << 4))));
  rb_define_const(mOpenbabel, "OB_CHIRALITY_MOL", SWIG_From_int(static_cast< int >((1 << 5))));
  rb_define_const(mOpenbabel, "OB_PCHARGE_MOL", SWIG_From_int(static_cast< int >((1 << 6))));
  rb_define_const(mOpenbabel, "OB_HYBRID_MOL", SWIG_From_int(static_cast< int >((1 << 8))));
  rb_define_const(mOpenbabel, "OB_IMPVAL_MOL", SWIG_From_int(static_cast< int >((1 << 9))));
  rb_define_const(mOpenbabel, "OB_KEKULE_MOL", SWIG_From_int(static_cast< int >((1 << 10))));
  rb_define_const(mOpenbabel, "OB_CLOSURE_MOL", SWIG_From_int(static_cast< int >((1 << 11))));
  rb_define_const(mOpenbabel, "OB_H_ADDED_MOL", SWIG_From_int(static_cast< int >((1 << 12))));
  rb_define_const(mOpenbabel, "OB_PH_CORRECTED_MOL", SWIG_From_int(static_cast< int >((1 << 13))));
  rb_define_const(mOpenbabel, "OB_AROM_CORRECTED_MOL", SWIG_From_int(static_cast< int >((1 << 14))));
  rb_define_const(mOpenbabel, "OB_CHAINS_MOL", SWIG_From_int(static_cast< int >((1 << 15))));
  rb_define_const(mOpenbabel, "OB_TCHARGE_MOL", SWIG_From_int(static_cast< int >((1 << 16))));
  rb_define_const(mOpenbabel, "OB_TSPIN_MOL", SWIG_From_int(static_cast< int >((1 << 17))));
  rb_define_const(mOpenbabel, "OB_CURRENT_CONFORMER", SWIG_From_int(static_cast< int >(-1)));
  
  cOBMol.klass = rb_define_class_under(mOpenbabel, "OBMol", ((swig_class *) SWIGTYPE_p_OpenBabel__OBBase->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBMol, (void *) &cOBMol);
  rb_define_alloc_func(cOBMol.klass, _wrap_OBMol_allocate);
  rb_define_method(cOBMol.klass, "initialize", VALUEFUNC(_wrap_new_OBMol), -1);
  rb_define_method(cOBMol.klass, "reserve_atoms", VALUEFUNC(_wrap_OBMol_reserve_atoms), -1);
  rb_define_method(cOBMol.klass, "create_atom", VALUEFUNC(_wrap_OBMol_create_atom), -1);
  rb_define_method(cOBMol.klass, "create_bond", VALUEFUNC(_wrap_OBMol_create_bond), -1);
  rb_define_method(cOBMol.klass, "create_residue", VALUEFUNC(_wrap_OBMol_create_residue), -1);
  rb_define_method(cOBMol.klass, "destroy_atom", VALUEFUNC(_wrap_OBMol_destroy_atom), -1);
  rb_define_method(cOBMol.klass, "destroy_bond", VALUEFUNC(_wrap_OBMol_destroy_bond), -1);
  rb_define_method(cOBMol.klass, "destroy_residue", VALUEFUNC(_wrap_OBMol_destroy_residue), -1);
  rb_define_method(cOBMol.klass, "add_atom", VALUEFUNC(_wrap_OBMol_add_atom), -1);
  rb_define_method(cOBMol.klass, "insert_atom", VALUEFUNC(_wrap_OBMol_insert_atom), -1);
  rb_define_method(cOBMol.klass, "add_bond", VALUEFUNC(_wrap_OBMol_add_bond), -1);
  rb_define_method(cOBMol.klass, "add_residue", VALUEFUNC(_wrap_OBMol_add_residue), -1);
  rb_define_method(cOBMol.klass, "new_atom", VALUEFUNC(_wrap_OBMol_new_atom), -1);
  rb_define_method(cOBMol.klass, "new_bond", VALUEFUNC(_wrap_OBMol_new_bond), -1);
  rb_define_method(cOBMol.klass, "new_residue", VALUEFUNC(_wrap_OBMol_new_residue), -1);
  rb_define_method(cOBMol.klass, "delete_atom", VALUEFUNC(_wrap_OBMol_delete_atom), -1);
  rb_define_method(cOBMol.klass, "delete_bond", VALUEFUNC(_wrap_OBMol_delete_bond), -1);
  rb_define_method(cOBMol.klass, "delete_residue", VALUEFUNC(_wrap_OBMol_delete_residue), -1);
  rb_define_method(cOBMol.klass, "begin_modify", VALUEFUNC(_wrap_OBMol_begin_modify), -1);
  rb_define_method(cOBMol.klass, "end_modify", VALUEFUNC(_wrap_OBMol_end_modify), -1);
  rb_define_method(cOBMol.klass, "get_mod", VALUEFUNC(_wrap_OBMol_get_mod), -1);
  rb_define_method(cOBMol.klass, "increment_mod", VALUEFUNC(_wrap_OBMol_increment_mod), -1);
  rb_define_method(cOBMol.klass, "decrement_mod", VALUEFUNC(_wrap_OBMol_decrement_mod), -1);
  rb_define_method(cOBMol.klass, "get_flags", VALUEFUNC(_wrap_OBMol_get_flags), -1);
  rb_define_method(cOBMol.klass, "get_title", VALUEFUNC(_wrap_OBMol_get_title), -1);
  rb_define_method(cOBMol.klass, "num_atoms", VALUEFUNC(_wrap_OBMol_num_atoms), -1);
  rb_define_method(cOBMol.klass, "num_bonds", VALUEFUNC(_wrap_OBMol_num_bonds), -1);
  rb_define_method(cOBMol.klass, "num_hvy_atoms", VALUEFUNC(_wrap_OBMol_num_hvy_atoms), -1);
  rb_define_method(cOBMol.klass, "num_residues", VALUEFUNC(_wrap_OBMol_num_residues), -1);
  rb_define_method(cOBMol.klass, "num_rotors", VALUEFUNC(_wrap_OBMol_num_rotors), -1);
  rb_define_method(cOBMol.klass, "get_atom", VALUEFUNC(_wrap_OBMol_get_atom), -1);
  rb_define_method(cOBMol.klass, "get_first_atom", VALUEFUNC(_wrap_OBMol_get_first_atom), -1);
  rb_define_method(cOBMol.klass, "get_bond", VALUEFUNC(_wrap_OBMol_get_bond), -1);
  rb_define_method(cOBMol.klass, "get_residue", VALUEFUNC(_wrap_OBMol_get_residue), -1);
  rb_define_method(cOBMol.klass, "get_internal_coord", VALUEFUNC(_wrap_OBMol_get_internal_coord), -1);
  rb_define_method(cOBMol.klass, "get_torsion", VALUEFUNC(_wrap_OBMol_get_torsion), -1);
  rb_define_method(cOBMol.klass, "get_angle", VALUEFUNC(_wrap_OBMol_get_angle), -1);
  rb_define_method(cOBMol.klass, "get_formula", VALUEFUNC(_wrap_OBMol_get_formula), -1);
  rb_define_method(cOBMol.klass, "get_spaced_formula", VALUEFUNC(_wrap_OBMol_get_spaced_formula), -1);
  rb_define_method(cOBMol.klass, "get_energy", VALUEFUNC(_wrap_OBMol_get_energy), -1);
  rb_define_method(cOBMol.klass, "get_mol_wt", VALUEFUNC(_wrap_OBMol_get_mol_wt), -1);
  rb_define_method(cOBMol.klass, "get_exact_mass", VALUEFUNC(_wrap_OBMol_get_exact_mass), -1);
  rb_define_method(cOBMol.klass, "get_total_charge", VALUEFUNC(_wrap_OBMol_get_total_charge), -1);
  rb_define_method(cOBMol.klass, "get_total_spin_multiplicity", VALUEFUNC(_wrap_OBMol_get_total_spin_multiplicity), -1);
  rb_define_method(cOBMol.klass, "get_dimension", VALUEFUNC(_wrap_OBMol_get_dimension), -1);
  rb_define_method(cOBMol.klass, "get_coordinates", VALUEFUNC(_wrap_OBMol_get_coordinates), -1);
  rb_define_method(cOBMol.klass, "get_sssr", VALUEFUNC(_wrap_OBMol_get_sssr), -1);
  rb_define_method(cOBMol.klass, "automatic_formal_charge", VALUEFUNC(_wrap_OBMol_automatic_formal_charge), -1);
  rb_define_method(cOBMol.klass, "automatic_partial_charge", VALUEFUNC(_wrap_OBMol_automatic_partial_charge), -1);
  rb_define_method(cOBMol.klass, "set_title", VALUEFUNC(_wrap_OBMol_set_title), -1);
  rb_define_method(cOBMol.klass, "set_formula", VALUEFUNC(_wrap_OBMol_set_formula), -1);
  rb_define_method(cOBMol.klass, "set_energy", VALUEFUNC(_wrap_OBMol_set_energy), -1);
  rb_define_method(cOBMol.klass, "set_dimension", VALUEFUNC(_wrap_OBMol_set_dimension), -1);
  rb_define_method(cOBMol.klass, "set_total_charge", VALUEFUNC(_wrap_OBMol_set_total_charge), -1);
  rb_define_method(cOBMol.klass, "set_total_spin_multiplicity", VALUEFUNC(_wrap_OBMol_set_total_spin_multiplicity), -1);
  rb_define_method(cOBMol.klass, "set_internal_coord", VALUEFUNC(_wrap_OBMol_set_internal_coord), -1);
  rb_define_method(cOBMol.klass, "set_automatic_formal_charge", VALUEFUNC(_wrap_OBMol_set_automatic_formal_charge), -1);
  rb_define_method(cOBMol.klass, "set_automatic_partial_charge", VALUEFUNC(_wrap_OBMol_set_automatic_partial_charge), -1);
  rb_define_method(cOBMol.klass, "set_aromatic_perceived", VALUEFUNC(_wrap_OBMol_set_aromatic_perceived), -1);
  rb_define_method(cOBMol.klass, "set_sssrperceived", VALUEFUNC(_wrap_OBMol_set_sssrperceived), -1);
  rb_define_method(cOBMol.klass, "set_ring_atoms_and_bonds_perceived", VALUEFUNC(_wrap_OBMol_set_ring_atoms_and_bonds_perceived), -1);
  rb_define_method(cOBMol.klass, "set_atom_types_perceived", VALUEFUNC(_wrap_OBMol_set_atom_types_perceived), -1);
  rb_define_method(cOBMol.klass, "set_chains_perceived", VALUEFUNC(_wrap_OBMol_set_chains_perceived), -1);
  rb_define_method(cOBMol.klass, "set_chirality_perceived", VALUEFUNC(_wrap_OBMol_set_chirality_perceived), -1);
  rb_define_method(cOBMol.klass, "set_partial_charges_perceived", VALUEFUNC(_wrap_OBMol_set_partial_charges_perceived), -1);
  rb_define_method(cOBMol.klass, "set_hybridization_perceived", VALUEFUNC(_wrap_OBMol_set_hybridization_perceived), -1);
  rb_define_method(cOBMol.klass, "set_implicit_valence_perceived", VALUEFUNC(_wrap_OBMol_set_implicit_valence_perceived), -1);
  rb_define_method(cOBMol.klass, "set_kekule_perceived", VALUEFUNC(_wrap_OBMol_set_kekule_perceived), -1);
  rb_define_method(cOBMol.klass, "set_closure_bonds_perceived", VALUEFUNC(_wrap_OBMol_set_closure_bonds_perceived), -1);
  rb_define_method(cOBMol.klass, "set_hydrogens_added", VALUEFUNC(_wrap_OBMol_set_hydrogens_added), -1);
  rb_define_method(cOBMol.klass, "set_corrected_for_ph", VALUEFUNC(_wrap_OBMol_set_corrected_for_ph), -1);
  rb_define_method(cOBMol.klass, "set_aromatic_corrected", VALUEFUNC(_wrap_OBMol_set_aromatic_corrected), -1);
  rb_define_method(cOBMol.klass, "set_spin_multiplicity_assigned", VALUEFUNC(_wrap_OBMol_set_spin_multiplicity_assigned), -1);
  rb_define_method(cOBMol.klass, "set_flags", VALUEFUNC(_wrap_OBMol_set_flags), -1);
  rb_define_method(cOBMol.klass, "unset_aromatic_perceived", VALUEFUNC(_wrap_OBMol_unset_aromatic_perceived), -1);
  rb_define_method(cOBMol.klass, "unset_partial_charges_perceived", VALUEFUNC(_wrap_OBMol_unset_partial_charges_perceived), -1);
  rb_define_method(cOBMol.klass, "unset_implicit_valence_perceived", VALUEFUNC(_wrap_OBMol_unset_implicit_valence_perceived), -1);
  rb_define_method(cOBMol.klass, "unset_hydrogens_added", VALUEFUNC(_wrap_OBMol_unset_hydrogens_added), -1);
  rb_define_method(cOBMol.klass, "unset_flag", VALUEFUNC(_wrap_OBMol_unset_flag), -1);
  rb_define_method(cOBMol.klass, "do_transformations", VALUEFUNC(_wrap_OBMol_do_transformations), -1);
  rb_define_singleton_method(cOBMol.klass, "class_description", VALUEFUNC(_wrap_OBMol_class_description), -1);
  rb_define_method(cOBMol.klass, "clear", VALUEFUNC(_wrap_OBMol_clear), -1);
  rb_define_method(cOBMol.klass, "renumber_atoms", VALUEFUNC(_wrap_OBMol_renumber_atoms), -1);
  rb_define_method(cOBMol.klass, "to_inertial_frame", VALUEFUNC(_wrap_OBMol_to_inertial_frame), -1);
  rb_define_method(cOBMol.klass, "translate", VALUEFUNC(_wrap_OBMol_translate), -1);
  rb_define_method(cOBMol.klass, "rotate", VALUEFUNC(_wrap_OBMol_rotate), -1);
  rb_define_method(cOBMol.klass, "kekulize", VALUEFUNC(_wrap_OBMol_kekulize), -1);
  rb_define_method(cOBMol.klass, "perceive_kekule_bonds", VALUEFUNC(_wrap_OBMol_perceive_kekule_bonds), -1);
  rb_define_method(cOBMol.klass, "new_perceive_kekule_bonds", VALUEFUNC(_wrap_OBMol_new_perceive_kekule_bonds), -1);
  rb_define_method(cOBMol.klass, "delete_hydrogens", VALUEFUNC(_wrap_OBMol_delete_hydrogens), -1);
  rb_define_method(cOBMol.klass, "delete_non_polar_hydrogens", VALUEFUNC(_wrap_OBMol_delete_non_polar_hydrogens), -1);
  rb_define_method(cOBMol.klass, "delete_hydrogen", VALUEFUNC(_wrap_OBMol_delete_hydrogen), -1);
  rb_define_method(cOBMol.klass, "add_hydrogens", VALUEFUNC(_wrap_OBMol_add_hydrogens), -1);
  rb_define_method(cOBMol.klass, "add_polar_hydrogens", VALUEFUNC(_wrap_OBMol_add_polar_hydrogens), -1);
  rb_define_method(cOBMol.klass, "strip_salts", VALUEFUNC(_wrap_OBMol_strip_salts), -1);
  rb_define_method(cOBMol.klass, "separate", VALUEFUNC(_wrap_OBMol_separate), -1);
  rb_define_method(cOBMol.klass, "convert_dative_bonds", VALUEFUNC(_wrap_OBMol_convert_dative_bonds), -1);
  rb_define_method(cOBMol.klass, "correct_for_ph", VALUEFUNC(_wrap_OBMol_correct_for_ph), -1);
  rb_define_method(cOBMol.klass, "assign_spin_multiplicity", VALUEFUNC(_wrap_OBMol_assign_spin_multiplicity), -1);
  rb_define_method(cOBMol.klass, "center", VALUEFUNC(_wrap_OBMol_center), -1);
  rb_define_method(cOBMol.klass, "set_torsion", VALUEFUNC(_wrap_OBMol_set_torsion), -1);
  rb_define_method(cOBMol.klass, "find_sssr", VALUEFUNC(_wrap_OBMol_find_sssr), -1);
  rb_define_method(cOBMol.klass, "find_ring_atoms_and_bonds", VALUEFUNC(_wrap_OBMol_find_ring_atoms_and_bonds), -1);
  rb_define_method(cOBMol.klass, "find_chiral_centers", VALUEFUNC(_wrap_OBMol_find_chiral_centers), -1);
  rb_define_method(cOBMol.klass, "find_children", VALUEFUNC(_wrap_OBMol_find_children), -1);
  rb_define_method(cOBMol.klass, "find_largest_fragment", VALUEFUNC(_wrap_OBMol_find_largest_fragment), -1);
  rb_define_method(cOBMol.klass, "contig_frag_list", VALUEFUNC(_wrap_OBMol_contig_frag_list), -1);
  rb_define_method(cOBMol.klass, "align", VALUEFUNC(_wrap_OBMol_align), -1);
  rb_define_method(cOBMol.klass, "connect_the_dots", VALUEFUNC(_wrap_OBMol_connect_the_dots), -1);
  rb_define_method(cOBMol.klass, "perceive_bond_orders", VALUEFUNC(_wrap_OBMol_perceive_bond_orders), -1);
  rb_define_method(cOBMol.klass, "find_angles", VALUEFUNC(_wrap_OBMol_find_angles), -1);
  rb_define_method(cOBMol.klass, "find_torsions", VALUEFUNC(_wrap_OBMol_find_torsions), -1);
  rb_define_method(cOBMol.klass, "get_gtdvector", VALUEFUNC(_wrap_OBMol_get_gtdvector), -1);
  rb_define_method(cOBMol.klass, "get_givector", VALUEFUNC(_wrap_OBMol_get_givector), -1);
  rb_define_method(cOBMol.klass, "get_gidvector", VALUEFUNC(_wrap_OBMol_get_gidvector), -1);
  rb_define_method(cOBMol.klass, "has_2d", VALUEFUNC(_wrap_OBMol_has_2d), -1);
  rb_define_method(cOBMol.klass, "has_3d", VALUEFUNC(_wrap_OBMol_has_3d), -1);
  rb_define_method(cOBMol.klass, "has_non_zero_coords", VALUEFUNC(_wrap_OBMol_has_non_zero_coords), -1);
  rb_define_method(cOBMol.klass, "has_aromatic_perceived", VALUEFUNC(_wrap_OBMol_has_aromatic_perceived), -1);
  rb_define_method(cOBMol.klass, "has_sssrperceived", VALUEFUNC(_wrap_OBMol_has_sssrperceived), -1);
  rb_define_method(cOBMol.klass, "has_ring_atoms_and_bonds_perceived", VALUEFUNC(_wrap_OBMol_has_ring_atoms_and_bonds_perceived), -1);
  rb_define_method(cOBMol.klass, "has_atom_types_perceived", VALUEFUNC(_wrap_OBMol_has_atom_types_perceived), -1);
  rb_define_method(cOBMol.klass, "has_chirality_perceived", VALUEFUNC(_wrap_OBMol_has_chirality_perceived), -1);
  rb_define_method(cOBMol.klass, "has_partial_charges_perceived", VALUEFUNC(_wrap_OBMol_has_partial_charges_perceived), -1);
  rb_define_method(cOBMol.klass, "has_hybridization_perceived", VALUEFUNC(_wrap_OBMol_has_hybridization_perceived), -1);
  rb_define_method(cOBMol.klass, "has_implicit_valence_perceived", VALUEFUNC(_wrap_OBMol_has_implicit_valence_perceived), -1);
  rb_define_method(cOBMol.klass, "has_kekule_perceived", VALUEFUNC(_wrap_OBMol_has_kekule_perceived), -1);
  rb_define_method(cOBMol.klass, "has_closure_bonds_perceived", VALUEFUNC(_wrap_OBMol_has_closure_bonds_perceived), -1);
  rb_define_method(cOBMol.klass, "has_chains_perceived", VALUEFUNC(_wrap_OBMol_has_chains_perceived), -1);
  rb_define_method(cOBMol.klass, "has_hydrogens_added", VALUEFUNC(_wrap_OBMol_has_hydrogens_added), -1);
  rb_define_method(cOBMol.klass, "has_aromatic_corrected", VALUEFUNC(_wrap_OBMol_has_aromatic_corrected), -1);
  rb_define_method(cOBMol.klass, "is_corrected_for_ph", VALUEFUNC(_wrap_OBMol_is_corrected_for_ph), -1);
  rb_define_method(cOBMol.klass, "has_spin_multiplicity_assigned", VALUEFUNC(_wrap_OBMol_has_spin_multiplicity_assigned), -1);
  rb_define_method(cOBMol.klass, "is_chiral", VALUEFUNC(_wrap_OBMol_is_chiral), -1);
  rb_define_method(cOBMol.klass, "empty", VALUEFUNC(_wrap_OBMol_empty), -1);
  rb_define_method(cOBMol.klass, "num_conformers", VALUEFUNC(_wrap_OBMol_num_conformers), -1);
  rb_define_method(cOBMol.klass, "set_conformers", VALUEFUNC(_wrap_OBMol_set_conformers), -1);
  rb_define_method(cOBMol.klass, "add_conformer", VALUEFUNC(_wrap_OBMol_add_conformer), -1);
  rb_define_method(cOBMol.klass, "set_conformer", VALUEFUNC(_wrap_OBMol_set_conformer), -1);
  rb_define_method(cOBMol.klass, "copy_conformer", VALUEFUNC(_wrap_OBMol_copy_conformer), -1);
  rb_define_method(cOBMol.klass, "delete_conformer", VALUEFUNC(_wrap_OBMol_delete_conformer), -1);
  rb_define_method(cOBMol.klass, "get_conformer", VALUEFUNC(_wrap_OBMol_get_conformer), -1);
  rb_define_method(cOBMol.klass, "begin_conformer", VALUEFUNC(_wrap_OBMol_begin_conformer), -1);
  rb_define_method(cOBMol.klass, "next_conformer", VALUEFUNC(_wrap_OBMol_next_conformer), -1);
  rb_define_method(cOBMol.klass, "get_conformers", VALUEFUNC(_wrap_OBMol_get_conformers), -1);
  rb_define_method(cOBMol.klass, "begin_atoms", VALUEFUNC(_wrap_OBMol_begin_atoms), -1);
  rb_define_method(cOBMol.klass, "end_atoms", VALUEFUNC(_wrap_OBMol_end_atoms), -1);
  rb_define_method(cOBMol.klass, "begin_bonds", VALUEFUNC(_wrap_OBMol_begin_bonds), -1);
  rb_define_method(cOBMol.klass, "end_bonds", VALUEFUNC(_wrap_OBMol_end_bonds), -1);
  rb_define_method(cOBMol.klass, "begin_residues", VALUEFUNC(_wrap_OBMol_begin_residues), -1);
  rb_define_method(cOBMol.klass, "end_residues", VALUEFUNC(_wrap_OBMol_end_residues), -1);
  rb_define_method(cOBMol.klass, "begin_atom", VALUEFUNC(_wrap_OBMol_begin_atom), -1);
  rb_define_method(cOBMol.klass, "next_atom", VALUEFUNC(_wrap_OBMol_next_atom), -1);
  rb_define_method(cOBMol.klass, "begin_bond", VALUEFUNC(_wrap_OBMol_begin_bond), -1);
  rb_define_method(cOBMol.klass, "next_bond", VALUEFUNC(_wrap_OBMol_next_bond), -1);
  rb_define_method(cOBMol.klass, "begin_residue", VALUEFUNC(_wrap_OBMol_begin_residue), -1);
  rb_define_method(cOBMol.klass, "next_residue", VALUEFUNC(_wrap_OBMol_next_residue), -1);
  rb_define_method(cOBMol.klass, "begin_internal_coord", VALUEFUNC(_wrap_OBMol_begin_internal_coord), -1);
  rb_define_method(cOBMol.klass, "next_internal_coord", VALUEFUNC(_wrap_OBMol_next_internal_coord), -1);
  cOBMol.mark = 0;
  cOBMol.destroy = (void (*)(void *)) free_OpenBabel_OBMol;
  cOBMol.trackObjects = 0;
  rb_define_module_function(mOpenbabel, "tokenize", VALUEFUNC(_wrap_tokenize), -1);
  rb_define_module_function(mOpenbabel, "throw_error", VALUEFUNC(_wrap_throw_error), -1);
  rb_define_module_function(mOpenbabel, "cartesian_to_internal", VALUEFUNC(_wrap_cartesian_to_internal), -1);
  rb_define_module_function(mOpenbabel, "internal_to_cartesian", VALUEFUNC(_wrap_internal_to_cartesian), -1);
  rb_define_module_function(mOpenbabel, "new_extension", VALUEFUNC(_wrap_new_extension), -1);
  rb_define_singleton_method(mOpenbabel, "etab", VALUEFUNC(etab_get), 0);
  rb_define_singleton_method(mOpenbabel, "etab=", VALUEFUNC(etab_set), 1);
  rb_define_singleton_method(mOpenbabel, "ttab", VALUEFUNC(ttab_get), 0);
  rb_define_singleton_method(mOpenbabel, "ttab=", VALUEFUNC(ttab_set), 1);
  rb_define_singleton_method(mOpenbabel, "isotab", VALUEFUNC(isotab_get), 0);
  rb_define_singleton_method(mOpenbabel, "isotab=", VALUEFUNC(isotab_set), 1);
  rb_define_singleton_method(mOpenbabel, "aromtyper", VALUEFUNC(aromtyper_get), 0);
  rb_define_singleton_method(mOpenbabel, "aromtyper=", VALUEFUNC(aromtyper_set), 1);
  rb_define_singleton_method(mOpenbabel, "atomtyper", VALUEFUNC(atomtyper_get), 0);
  rb_define_singleton_method(mOpenbabel, "atomtyper=", VALUEFUNC(atomtyper_set), 1);
  rb_define_singleton_method(mOpenbabel, "chainsparser", VALUEFUNC(chainsparser_get), 0);
  rb_define_singleton_method(mOpenbabel, "chainsparser=", VALUEFUNC(chainsparser_set), 1);
  rb_define_singleton_method(mOpenbabel, "resdat", VALUEFUNC(resdat_get), 0);
  rb_define_singleton_method(mOpenbabel, "resdat=", VALUEFUNC(resdat_set), 1);
  rb_define_const(mOpenbabel, "BUFF_SIZE", SWIG_From_int(static_cast< int >(32768)));
  rb_define_module_function(mOpenbabel, "get_rmat", VALUEFUNC(_wrap_get_rmat), -1);
  rb_define_module_function(mOpenbabel, "ob_make_rmat", VALUEFUNC(_wrap_ob_make_rmat), -1);
  rb_define_module_function(mOpenbabel, "qtrfit", VALUEFUNC(_wrap_qtrfit), -1);
  rb_define_module_function(mOpenbabel, "superimpose", VALUEFUNC(_wrap_superimpose), -1);
  
  cOBRing.klass = rb_define_class_under(mOpenbabel, "OBRing", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBRing, (void *) &cOBRing);
  rb_define_alloc_func(cOBRing.klass, _wrap_OBRing_allocate);
  rb_define_method(cOBRing.klass, "initialize", VALUEFUNC(_wrap_new_OBRing), -1);
  rb_define_method(cOBRing.klass, "_path=", VALUEFUNC(_wrap_OBRing__path_set), -1);
  rb_define_method(cOBRing.klass, "_path", VALUEFUNC(_wrap_OBRing__path_get), -1);
  rb_define_method(cOBRing.klass, "_pathset=", VALUEFUNC(_wrap_OBRing__pathset_set), -1);
  rb_define_method(cOBRing.klass, "_pathset", VALUEFUNC(_wrap_OBRing__pathset_get), -1);
  rb_define_method(cOBRing.klass, "size", VALUEFUNC(_wrap_OBRing_size), -1);
  rb_define_method(cOBRing.klass, "path_size", VALUEFUNC(_wrap_OBRing_path_size), -1);
  rb_define_method(cOBRing.klass, "is_aromatic", VALUEFUNC(_wrap_OBRing_is_aromatic), -1);
  rb_define_method(cOBRing.klass, "is_member", VALUEFUNC(_wrap_OBRing_is_member), -1);
  rb_define_method(cOBRing.klass, "is_in_ring", VALUEFUNC(_wrap_OBRing_is_in_ring), -1);
  rb_define_method(cOBRing.klass, "set_parent", VALUEFUNC(_wrap_OBRing_set_parent), -1);
  rb_define_method(cOBRing.klass, "get_parent", VALUEFUNC(_wrap_OBRing_get_parent), -1);
  rb_define_method(cOBRing.klass, "find_center_and_normal", VALUEFUNC(_wrap_OBRing_find_center_and_normal), -1);
  cOBRing.mark = 0;
  cOBRing.destroy = (void (*)(void *)) free_OpenBabel_OBRing;
  cOBRing.trackObjects = 0;
  rb_define_module_function(mOpenbabel, "compare_ring_size", VALUEFUNC(_wrap_compare_ring_size), -1);
  
  cOBRingSearch.klass = rb_define_class_under(mOpenbabel, "OBRingSearch", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBRingSearch, (void *) &cOBRingSearch);
  rb_define_alloc_func(cOBRingSearch.klass, _wrap_OBRingSearch_allocate);
  rb_define_method(cOBRingSearch.klass, "initialize", VALUEFUNC(_wrap_new_OBRingSearch), -1);
  rb_define_method(cOBRingSearch.klass, "sort_rings", VALUEFUNC(_wrap_OBRingSearch_sort_rings), -1);
  rb_define_method(cOBRingSearch.klass, "remove_redundant", VALUEFUNC(_wrap_OBRingSearch_remove_redundant), -1);
  rb_define_method(cOBRingSearch.klass, "add_ring_from_closure", VALUEFUNC(_wrap_OBRingSearch_add_ring_from_closure), -1);
  rb_define_method(cOBRingSearch.klass, "save_unique_ring", VALUEFUNC(_wrap_OBRingSearch_save_unique_ring), -1);
  rb_define_method(cOBRingSearch.klass, "write_rings", VALUEFUNC(_wrap_OBRingSearch_write_rings), -1);
  rb_define_method(cOBRingSearch.klass, "begin_rings", VALUEFUNC(_wrap_OBRingSearch_begin_rings), -1);
  rb_define_method(cOBRingSearch.klass, "end_rings", VALUEFUNC(_wrap_OBRingSearch_end_rings), -1);
  cOBRingSearch.mark = 0;
  cOBRingSearch.destroy = (void (*)(void *)) free_OpenBabel_OBRingSearch;
  cOBRingSearch.trackObjects = 0;
  
  cOBRTree.klass = rb_define_class_under(mOpenbabel, "OBRTree", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBRTree, (void *) &cOBRTree);
  rb_define_alloc_func(cOBRTree.klass, _wrap_OBRTree_allocate);
  rb_define_method(cOBRTree.klass, "initialize", VALUEFUNC(_wrap_new_OBRTree), -1);
  rb_define_method(cOBRTree.klass, "get_atom_idx", VALUEFUNC(_wrap_OBRTree_get_atom_idx), -1);
  rb_define_method(cOBRTree.klass, "path_to_root", VALUEFUNC(_wrap_OBRTree_path_to_root), -1);
  cOBRTree.mark = 0;
  cOBRTree.destroy = (void (*)(void *)) free_OpenBabel_OBRTree;
  cOBRTree.trackObjects = 0;
  
  cOBSmartsPattern.klass = rb_define_class_under(mOpenbabel, "OBSmartsPattern", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBSmartsPattern, (void *) &cOBSmartsPattern);
  rb_define_alloc_func(cOBSmartsPattern.klass, _wrap_OBSmartsPattern_allocate);
  rb_define_method(cOBSmartsPattern.klass, "initialize", VALUEFUNC(_wrap_new_OBSmartsPattern), -1);
  rb_define_method(cOBSmartsPattern.klass, "init", VALUEFUNC(_wrap_OBSmartsPattern_init), -1);
  rb_define_method(cOBSmartsPattern.klass, "get_smarts", VALUEFUNC(_wrap_OBSmartsPattern_get_smarts), -1);
  rb_define_method(cOBSmartsPattern.klass, "empty", VALUEFUNC(_wrap_OBSmartsPattern_empty), -1);
  rb_define_method(cOBSmartsPattern.klass, "is_valid", VALUEFUNC(_wrap_OBSmartsPattern_is_valid), -1);
  rb_define_method(cOBSmartsPattern.klass, "num_atoms", VALUEFUNC(_wrap_OBSmartsPattern_num_atoms), -1);
  rb_define_method(cOBSmartsPattern.klass, "num_bonds", VALUEFUNC(_wrap_OBSmartsPattern_num_bonds), -1);
  rb_define_method(cOBSmartsPattern.klass, "get_bond", VALUEFUNC(_wrap_OBSmartsPattern_get_bond), -1);
  rb_define_method(cOBSmartsPattern.klass, "get_atomic_num", VALUEFUNC(_wrap_OBSmartsPattern_get_atomic_num), -1);
  rb_define_method(cOBSmartsPattern.klass, "get_charge", VALUEFUNC(_wrap_OBSmartsPattern_get_charge), -1);
  rb_define_method(cOBSmartsPattern.klass, "get_vector_binding", VALUEFUNC(_wrap_OBSmartsPattern_get_vector_binding), -1);
  rb_define_method(cOBSmartsPattern.klass, "match", VALUEFUNC(_wrap_OBSmartsPattern_match), -1);
  rb_define_method(cOBSmartsPattern.klass, "restricted_match", VALUEFUNC(_wrap_OBSmartsPattern_restricted_match), -1);
  rb_define_method(cOBSmartsPattern.klass, "num_matches", VALUEFUNC(_wrap_OBSmartsPattern_num_matches), -1);
  rb_define_method(cOBSmartsPattern.klass, "get_map_list", VALUEFUNC(_wrap_OBSmartsPattern_get_map_list), -1);
  rb_define_method(cOBSmartsPattern.klass, "begin_mlist", VALUEFUNC(_wrap_OBSmartsPattern_begin_mlist), -1);
  rb_define_method(cOBSmartsPattern.klass, "end_mlist", VALUEFUNC(_wrap_OBSmartsPattern_end_mlist), -1);
  rb_define_method(cOBSmartsPattern.klass, "get_umap_list", VALUEFUNC(_wrap_OBSmartsPattern_get_umap_list), -1);
  rb_define_method(cOBSmartsPattern.klass, "write_map_list", VALUEFUNC(_wrap_OBSmartsPattern_write_map_list), -1);
  cOBSmartsPattern.mark = 0;
  cOBSmartsPattern.destroy = (void (*)(void *)) free_OpenBabel_OBSmartsPattern;
  cOBSmartsPattern.trackObjects = 0;
  
  cOBSSMatch.klass = rb_define_class_under(mOpenbabel, "OBSSMatch", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBSSMatch, (void *) &cOBSSMatch);
  rb_define_alloc_func(cOBSSMatch.klass, _wrap_OBSSMatch_allocate);
  rb_define_method(cOBSSMatch.klass, "initialize", VALUEFUNC(_wrap_new_OBSSMatch), -1);
  rb_define_method(cOBSSMatch.klass, "match", VALUEFUNC(_wrap_OBSSMatch_match), -1);
  cOBSSMatch.mark = 0;
  cOBSSMatch.destroy = (void (*)(void *)) free_OpenBabel_OBSSMatch;
  cOBSSMatch.trackObjects = 0;
  rb_define_module_function(mOpenbabel, "smarts_lex_replace", VALUEFUNC(_wrap_smarts_lex_replace), -1);
  
  cOBFingerprint.klass = rb_define_class_under(mOpenbabel, "OBFingerprint", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBFingerprint, (void *) &cOBFingerprint);
  rb_undef_alloc_func(cOBFingerprint.klass);
  rb_define_singleton_method(cOBFingerprint.klass, "iter", VALUEFUNC(_wrap_OBFingerprint_iter), -1);
  rb_define_singleton_method(cOBFingerprint.klass, "find_default_type", VALUEFUNC(_wrap_OBFingerprint_find_default_type), -1);
  rb_define_singleton_method(cOBFingerprint.klass, "find_type", VALUEFUNC(_wrap_OBFingerprint_find_type), -1);
  rb_define_method(cOBFingerprint.klass, "set_bit", VALUEFUNC(_wrap_OBFingerprint_set_bit), -1);
  rb_define_method(cOBFingerprint.klass, "fold", VALUEFUNC(_wrap_OBFingerprint_fold), -1);
  rb_define_method(cOBFingerprint.klass, "get_fingerprint", VALUEFUNC(_wrap_OBFingerprint_get_fingerprint), -1);
  rb_define_method(cOBFingerprint.klass, "description", VALUEFUNC(_wrap_OBFingerprint_description), -1);
  rb_define_const(cOBFingerprint.klass, "FPT_UNIQUEBITS", SWIG_From_int(static_cast< int >(OpenBabel::OBFingerprint::FPT_UNIQUEBITS)));
  rb_define_method(cOBFingerprint.klass, "flags", VALUEFUNC(_wrap_OBFingerprint_flags), -1);
  rb_define_singleton_method(cOBFingerprint.klass, "tanimoto", VALUEFUNC(_wrap_OBFingerprint_tanimoto), -1);
  rb_define_singleton_method(cOBFingerprint.klass, "getbitsperint", VALUEFUNC(_wrap_OBFingerprint_getbitsperint), -1);
  rb_define_singleton_method(cOBFingerprint.klass, "find_fingerprint", VALUEFUNC(_wrap_OBFingerprint_find_fingerprint), -1);
  cOBFingerprint.mark = 0;
  cOBFingerprint.destroy = (void (*)(void *)) free_OpenBabel_OBFingerprint;
  cOBFingerprint.trackObjects = 0;
  
  cFptIndexHeader.klass = rb_define_class_under(mOpenbabel, "FptIndexHeader", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__FptIndexHeader, (void *) &cFptIndexHeader);
  rb_define_alloc_func(cFptIndexHeader.klass, _wrap_FptIndexHeader_allocate);
  rb_define_method(cFptIndexHeader.klass, "initialize", VALUEFUNC(_wrap_new_FptIndexHeader), -1);
  rb_define_method(cFptIndexHeader.klass, "headerlength=", VALUEFUNC(_wrap_FptIndexHeader_headerlength_set), -1);
  rb_define_method(cFptIndexHeader.klass, "headerlength", VALUEFUNC(_wrap_FptIndexHeader_headerlength_get), -1);
  rb_define_method(cFptIndexHeader.klass, "nEntries=", VALUEFUNC(_wrap_FptIndexHeader_nEntries_set), -1);
  rb_define_method(cFptIndexHeader.klass, "nEntries", VALUEFUNC(_wrap_FptIndexHeader_nEntries_get), -1);
  rb_define_method(cFptIndexHeader.klass, "words=", VALUEFUNC(_wrap_FptIndexHeader_words_set), -1);
  rb_define_method(cFptIndexHeader.klass, "words", VALUEFUNC(_wrap_FptIndexHeader_words_get), -1);
  rb_define_method(cFptIndexHeader.klass, "fpid=", VALUEFUNC(_wrap_FptIndexHeader_fpid_set), -1);
  rb_define_method(cFptIndexHeader.klass, "fpid", VALUEFUNC(_wrap_FptIndexHeader_fpid_get), -1);
  rb_define_method(cFptIndexHeader.klass, "datafilename=", VALUEFUNC(_wrap_FptIndexHeader_datafilename_set), -1);
  rb_define_method(cFptIndexHeader.klass, "datafilename", VALUEFUNC(_wrap_FptIndexHeader_datafilename_get), -1);
  cFptIndexHeader.mark = 0;
  cFptIndexHeader.destroy = (void (*)(void *)) free_OpenBabel_FptIndexHeader;
  cFptIndexHeader.trackObjects = 0;
  
  cFptIndex.klass = rb_define_class_under(mOpenbabel, "FptIndex", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__FptIndex, (void *) &cFptIndex);
  rb_define_alloc_func(cFptIndex.klass, _wrap_FptIndex_allocate);
  rb_define_method(cFptIndex.klass, "initialize", VALUEFUNC(_wrap_new_FptIndex), -1);
  rb_define_method(cFptIndex.klass, "header=", VALUEFUNC(_wrap_FptIndex_header_set), -1);
  rb_define_method(cFptIndex.klass, "header", VALUEFUNC(_wrap_FptIndex_header_get), -1);
  rb_define_method(cFptIndex.klass, "fptdata=", VALUEFUNC(_wrap_FptIndex_fptdata_set), -1);
  rb_define_method(cFptIndex.klass, "fptdata", VALUEFUNC(_wrap_FptIndex_fptdata_get), -1);
  rb_define_method(cFptIndex.klass, "seekdata=", VALUEFUNC(_wrap_FptIndex_seekdata_set), -1);
  rb_define_method(cFptIndex.klass, "seekdata", VALUEFUNC(_wrap_FptIndex_seekdata_get), -1);
  rb_define_method(cFptIndex.klass, "read", VALUEFUNC(_wrap_FptIndex_read), -1);
  rb_define_method(cFptIndex.klass, "check_fp", VALUEFUNC(_wrap_FptIndex_check_fp), -1);
  cFptIndex.mark = 0;
  cFptIndex.destroy = (void (*)(void *)) free_OpenBabel_FptIndex;
  cFptIndex.trackObjects = 0;
  
  cFastSearch.klass = rb_define_class_under(mOpenbabel, "FastSearch", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__FastSearch, (void *) &cFastSearch);
  rb_define_alloc_func(cFastSearch.klass, _wrap_FastSearch_allocate);
  rb_define_method(cFastSearch.klass, "initialize", VALUEFUNC(_wrap_new_FastSearch), -1);
  rb_define_method(cFastSearch.klass, "read_index_file", VALUEFUNC(_wrap_FastSearch_read_index_file), -1);
  rb_define_method(cFastSearch.klass, "read_index", VALUEFUNC(_wrap_FastSearch_read_index), -1);
  rb_define_method(cFastSearch.klass, "find", VALUEFUNC(_wrap_FastSearch_find), -1);
  rb_define_method(cFastSearch.klass, "find_match", VALUEFUNC(_wrap_FastSearch_find_match), -1);
  rb_define_method(cFastSearch.klass, "find_similar", VALUEFUNC(_wrap_FastSearch_find_similar), -1);
  rb_define_method(cFastSearch.klass, "get_fingerprint", VALUEFUNC(_wrap_FastSearch_get_fingerprint), -1);
  rb_define_method(cFastSearch.klass, "get_index_header", VALUEFUNC(_wrap_FastSearch_get_index_header), -1);
  cFastSearch.mark = 0;
  cFastSearch.destroy = (void (*)(void *)) free_OpenBabel_FastSearch;
  cFastSearch.trackObjects = 0;
  
  cFastSearchIndexer.klass = rb_define_class_under(mOpenbabel, "FastSearchIndexer", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__FastSearchIndexer, (void *) &cFastSearchIndexer);
  rb_define_alloc_func(cFastSearchIndexer.klass, _wrap_FastSearchIndexer_allocate);
  rb_define_method(cFastSearchIndexer.klass, "initialize", VALUEFUNC(_wrap_new_FastSearchIndexer), -1);
  rb_define_method(cFastSearchIndexer.klass, "add", VALUEFUNC(_wrap_FastSearchIndexer_add), -1);
  cFastSearchIndexer.mark = 0;
  cFastSearchIndexer.destroy = (void (*)(void *)) free_OpenBabel_FastSearchIndexer;
  cFastSearchIndexer.trackObjects = 0;
  rb_define_const(mOpenbabel, "OBFF_LOGLVL_NONE", SWIG_From_int(static_cast< int >(0)));
  rb_define_const(mOpenbabel, "OBFF_LOGLVL_LOW", SWIG_From_int(static_cast< int >(1)));
  rb_define_const(mOpenbabel, "OBFF_LOGLVL_MEDIUM", SWIG_From_int(static_cast< int >(2)));
  rb_define_const(mOpenbabel, "OBFF_LOGLVL_HIGH", SWIG_From_int(static_cast< int >(3)));
  rb_define_const(mOpenbabel, "OBFF_ENERGY", SWIG_From_int(static_cast< int >((1 << 0))));
  rb_define_const(mOpenbabel, "OBFF_EBOND", SWIG_From_int(static_cast< int >((1 << 1))));
  rb_define_const(mOpenbabel, "OBFF_EANGLE", SWIG_From_int(static_cast< int >((1 << 2))));
  rb_define_const(mOpenbabel, "OBFF_ESTRBND", SWIG_From_int(static_cast< int >((1 << 3))));
  rb_define_const(mOpenbabel, "OBFF_ETORSION", SWIG_From_int(static_cast< int >((1 << 4))));
  rb_define_const(mOpenbabel, "OBFF_EOOP", SWIG_From_int(static_cast< int >((1 << 5))));
  rb_define_const(mOpenbabel, "OBFF_EVDW", SWIG_From_int(static_cast< int >((1 << 6))));
  rb_define_const(mOpenbabel, "OBFF_EELECTROSTATIC", SWIG_From_int(static_cast< int >((1 << 7))));
  rb_define_const(mOpenbabel, "OBFF_NUMERICAL_GRADIENT", SWIG_From_int(static_cast< int >((1 << 0))));
  rb_define_const(mOpenbabel, "OBFF_ANALYTICAL_GRADIENT", SWIG_From_int(static_cast< int >((1 << 1))));
  rb_define_const(mOpenbabel, "KCAL_TO_KJ", SWIG_From_double(static_cast< double >(4.1868)));
  
  cOBFFParameter.klass = rb_define_class_under(mOpenbabel, "OBFFParameter", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBFFParameter, (void *) &cOBFFParameter);
  rb_define_alloc_func(cOBFFParameter.klass, _wrap_OBFFParameter_allocate);
  rb_define_method(cOBFFParameter.klass, "initialize", VALUEFUNC(_wrap_new_OBFFParameter), -1);
  rb_define_method(cOBFFParameter.klass, "a=", VALUEFUNC(_wrap_OBFFParameter_a_set), -1);
  rb_define_method(cOBFFParameter.klass, "a", VALUEFUNC(_wrap_OBFFParameter_a_get), -1);
  rb_define_method(cOBFFParameter.klass, "b=", VALUEFUNC(_wrap_OBFFParameter_b_set), -1);
  rb_define_method(cOBFFParameter.klass, "b", VALUEFUNC(_wrap_OBFFParameter_b_get), -1);
  rb_define_method(cOBFFParameter.klass, "c=", VALUEFUNC(_wrap_OBFFParameter_c_set), -1);
  rb_define_method(cOBFFParameter.klass, "c", VALUEFUNC(_wrap_OBFFParameter_c_get), -1);
  rb_define_method(cOBFFParameter.klass, "d=", VALUEFUNC(_wrap_OBFFParameter_d_set), -1);
  rb_define_method(cOBFFParameter.klass, "d", VALUEFUNC(_wrap_OBFFParameter_d_get), -1);
  rb_define_method(cOBFFParameter.klass, "_a=", VALUEFUNC(_wrap_OBFFParameter__a_set), -1);
  rb_define_method(cOBFFParameter.klass, "_a", VALUEFUNC(_wrap_OBFFParameter__a_get), -1);
  rb_define_method(cOBFFParameter.klass, "_b=", VALUEFUNC(_wrap_OBFFParameter__b_set), -1);
  rb_define_method(cOBFFParameter.klass, "_b", VALUEFUNC(_wrap_OBFFParameter__b_get), -1);
  rb_define_method(cOBFFParameter.klass, "_c=", VALUEFUNC(_wrap_OBFFParameter__c_set), -1);
  rb_define_method(cOBFFParameter.klass, "_c", VALUEFUNC(_wrap_OBFFParameter__c_get), -1);
  rb_define_method(cOBFFParameter.klass, "_d=", VALUEFUNC(_wrap_OBFFParameter__d_set), -1);
  rb_define_method(cOBFFParameter.klass, "_d", VALUEFUNC(_wrap_OBFFParameter__d_get), -1);
  rb_define_method(cOBFFParameter.klass, "ipar1=", VALUEFUNC(_wrap_OBFFParameter_ipar1_set), -1);
  rb_define_method(cOBFFParameter.klass, "ipar1", VALUEFUNC(_wrap_OBFFParameter_ipar1_get), -1);
  rb_define_method(cOBFFParameter.klass, "ipar2=", VALUEFUNC(_wrap_OBFFParameter_ipar2_set), -1);
  rb_define_method(cOBFFParameter.klass, "ipar2", VALUEFUNC(_wrap_OBFFParameter_ipar2_get), -1);
  rb_define_method(cOBFFParameter.klass, "ipar3=", VALUEFUNC(_wrap_OBFFParameter_ipar3_set), -1);
  rb_define_method(cOBFFParameter.klass, "ipar3", VALUEFUNC(_wrap_OBFFParameter_ipar3_get), -1);
  rb_define_method(cOBFFParameter.klass, "ipar4=", VALUEFUNC(_wrap_OBFFParameter_ipar4_set), -1);
  rb_define_method(cOBFFParameter.klass, "ipar4", VALUEFUNC(_wrap_OBFFParameter_ipar4_get), -1);
  rb_define_method(cOBFFParameter.klass, "ipar5=", VALUEFUNC(_wrap_OBFFParameter_ipar5_set), -1);
  rb_define_method(cOBFFParameter.klass, "ipar5", VALUEFUNC(_wrap_OBFFParameter_ipar5_get), -1);
  rb_define_method(cOBFFParameter.klass, "dpar1=", VALUEFUNC(_wrap_OBFFParameter_dpar1_set), -1);
  rb_define_method(cOBFFParameter.klass, "dpar1", VALUEFUNC(_wrap_OBFFParameter_dpar1_get), -1);
  rb_define_method(cOBFFParameter.klass, "dpar2=", VALUEFUNC(_wrap_OBFFParameter_dpar2_set), -1);
  rb_define_method(cOBFFParameter.klass, "dpar2", VALUEFUNC(_wrap_OBFFParameter_dpar2_get), -1);
  rb_define_method(cOBFFParameter.klass, "dpar3=", VALUEFUNC(_wrap_OBFFParameter_dpar3_set), -1);
  rb_define_method(cOBFFParameter.klass, "dpar3", VALUEFUNC(_wrap_OBFFParameter_dpar3_get), -1);
  rb_define_method(cOBFFParameter.klass, "dpar4=", VALUEFUNC(_wrap_OBFFParameter_dpar4_set), -1);
  rb_define_method(cOBFFParameter.klass, "dpar4", VALUEFUNC(_wrap_OBFFParameter_dpar4_get), -1);
  rb_define_method(cOBFFParameter.klass, "dpar5=", VALUEFUNC(_wrap_OBFFParameter_dpar5_set), -1);
  rb_define_method(cOBFFParameter.klass, "dpar5", VALUEFUNC(_wrap_OBFFParameter_dpar5_get), -1);
  rb_define_method(cOBFFParameter.klass, "clear", VALUEFUNC(_wrap_OBFFParameter_clear), -1);
  cOBFFParameter.mark = 0;
  cOBFFParameter.destroy = (void (*)(void *)) free_OpenBabel_OBFFParameter;
  cOBFFParameter.trackObjects = 0;
  
  cOBFFCalculation.klass = rb_define_class_under(mOpenbabel, "OBFFCalculation", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBFFCalculation, (void *) &cOBFFCalculation);
  rb_define_alloc_func(cOBFFCalculation.klass, _wrap_OBFFCalculation_allocate);
  rb_define_method(cOBFFCalculation.klass, "initialize", VALUEFUNC(_wrap_new_OBFFCalculation), -1);
  rb_define_method(cOBFFCalculation.klass, "energy=", VALUEFUNC(_wrap_OBFFCalculation_energy_set), -1);
  rb_define_method(cOBFFCalculation.klass, "energy", VALUEFUNC(_wrap_OBFFCalculation_energy_get), -1);
  rb_define_method(cOBFFCalculation.klass, "grada=", VALUEFUNC(_wrap_OBFFCalculation_grada_set), -1);
  rb_define_method(cOBFFCalculation.klass, "grada", VALUEFUNC(_wrap_OBFFCalculation_grada_get), -1);
  rb_define_method(cOBFFCalculation.klass, "gradb=", VALUEFUNC(_wrap_OBFFCalculation_gradb_set), -1);
  rb_define_method(cOBFFCalculation.klass, "gradb", VALUEFUNC(_wrap_OBFFCalculation_gradb_get), -1);
  rb_define_method(cOBFFCalculation.klass, "gradc=", VALUEFUNC(_wrap_OBFFCalculation_gradc_set), -1);
  rb_define_method(cOBFFCalculation.klass, "gradc", VALUEFUNC(_wrap_OBFFCalculation_gradc_get), -1);
  rb_define_method(cOBFFCalculation.klass, "gradd=", VALUEFUNC(_wrap_OBFFCalculation_gradd_set), -1);
  rb_define_method(cOBFFCalculation.klass, "gradd", VALUEFUNC(_wrap_OBFFCalculation_gradd_get), -1);
  rb_define_method(cOBFFCalculation.klass, "a=", VALUEFUNC(_wrap_OBFFCalculation_a_set), -1);
  rb_define_method(cOBFFCalculation.klass, "a", VALUEFUNC(_wrap_OBFFCalculation_a_get), -1);
  rb_define_method(cOBFFCalculation.klass, "b=", VALUEFUNC(_wrap_OBFFCalculation_b_set), -1);
  rb_define_method(cOBFFCalculation.klass, "b", VALUEFUNC(_wrap_OBFFCalculation_b_get), -1);
  rb_define_method(cOBFFCalculation.klass, "c=", VALUEFUNC(_wrap_OBFFCalculation_c_set), -1);
  rb_define_method(cOBFFCalculation.klass, "c", VALUEFUNC(_wrap_OBFFCalculation_c_get), -1);
  rb_define_method(cOBFFCalculation.klass, "d=", VALUEFUNC(_wrap_OBFFCalculation_d_set), -1);
  rb_define_method(cOBFFCalculation.klass, "d", VALUEFUNC(_wrap_OBFFCalculation_d_get), -1);
  rb_define_method(cOBFFCalculation.klass, "compute", VALUEFUNC(_wrap_OBFFCalculation_compute), -1);
  rb_define_method(cOBFFCalculation.klass, "get_energy", VALUEFUNC(_wrap_OBFFCalculation_get_energy), -1);
  rb_define_method(cOBFFCalculation.klass, "get_gradient", VALUEFUNC(_wrap_OBFFCalculation_get_gradient), -1);
  cOBFFCalculation.mark = 0;
  cOBFFCalculation.destroy = (void (*)(void *)) free_OpenBabel_OBFFCalculation;
  cOBFFCalculation.trackObjects = 0;
  
  cOBForceField.klass = rb_define_class_under(mOpenbabel, "OBForceField", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBForceField, (void *) &cOBForceField);
  rb_define_alloc_func(cOBForceField.klass, _wrap_OBForceField_allocate);
  rb_define_method(cOBForceField.klass, "initialize", VALUEFUNC(_wrap_new_OBForceField), -1);
  rb_define_singleton_method(cOBForceField.klass, "iter", VALUEFUNC(_wrap_OBForceField_iter), -1);
  rb_define_singleton_method(cOBForceField.klass, "find_default_type", VALUEFUNC(_wrap_OBForceField_find_default_type), -1);
  rb_define_singleton_method(cOBForceField.klass, "find_type", VALUEFUNC(_wrap_OBForceField_find_type), -1);
  rb_define_singleton_method(cOBForceField.klass, "find_force_field", VALUEFUNC(_wrap_OBForceField_find_force_field), -1);
  rb_define_method(cOBForceField.klass, "get_unit", VALUEFUNC(_wrap_OBForceField_get_unit), -1);
  rb_define_method(cOBForceField.klass, "setup", VALUEFUNC(_wrap_OBForceField_setup), -1);
  rb_define_method(cOBForceField.klass, "update_coordinates", VALUEFUNC(_wrap_OBForceField_update_coordinates), -1);
  rb_define_method(cOBForceField.klass, "update_conformers", VALUEFUNC(_wrap_OBForceField_update_conformers), -1);
  rb_define_method(cOBForceField.klass, "obfflog", VALUEFUNC(_wrap_OBForceField_obfflog), -1);
  rb_define_method(cOBForceField.klass, "energy", VALUEFUNC(_wrap_OBForceField_energy), -1);
  rb_define_method(cOBForceField.klass, "e_bond", VALUEFUNC(_wrap_OBForceField_e_bond), -1);
  rb_define_method(cOBForceField.klass, "e_angle", VALUEFUNC(_wrap_OBForceField_e_angle), -1);
  rb_define_method(cOBForceField.klass, "e_str_bnd", VALUEFUNC(_wrap_OBForceField_e_str_bnd), -1);
  rb_define_method(cOBForceField.klass, "e_torsion", VALUEFUNC(_wrap_OBForceField_e_torsion), -1);
  rb_define_method(cOBForceField.klass, "e_oop", VALUEFUNC(_wrap_OBForceField_e_oop), -1);
  rb_define_method(cOBForceField.klass, "e_vdw", VALUEFUNC(_wrap_OBForceField_e_vdw), -1);
  rb_define_method(cOBForceField.klass, "e_electrostatic", VALUEFUNC(_wrap_OBForceField_e_electrostatic), -1);
  rb_define_method(cOBForceField.klass, "set_log_file", VALUEFUNC(_wrap_OBForceField_set_log_file), -1);
  rb_define_method(cOBForceField.klass, "set_log_level", VALUEFUNC(_wrap_OBForceField_set_log_level), -1);
  rb_define_method(cOBForceField.klass, "get_log_level", VALUEFUNC(_wrap_OBForceField_get_log_level), -1);
  rb_define_method(cOBForceField.klass, "systematic_rotor_search", VALUEFUNC(_wrap_OBForceField_systematic_rotor_search), -1);
  rb_define_method(cOBForceField.klass, "line_search", VALUEFUNC(_wrap_OBForceField_line_search), -1);
  rb_define_method(cOBForceField.klass, "steepest_descent", VALUEFUNC(_wrap_OBForceField_steepest_descent), -1);
  rb_define_method(cOBForceField.klass, "steepest_descent_initialize", VALUEFUNC(_wrap_OBForceField_steepest_descent_initialize), -1);
  rb_define_method(cOBForceField.klass, "steepest_descent_take_nsteps", VALUEFUNC(_wrap_OBForceField_steepest_descent_take_nsteps), -1);
  rb_define_method(cOBForceField.klass, "conjugate_gradients", VALUEFUNC(_wrap_OBForceField_conjugate_gradients), -1);
  rb_define_method(cOBForceField.klass, "conjugate_gradients_initialize", VALUEFUNC(_wrap_OBForceField_conjugate_gradients_initialize), -1);
  rb_define_method(cOBForceField.klass, "conjugate_gradients_take_nsteps", VALUEFUNC(_wrap_OBForceField_conjugate_gradients_take_nsteps), -1);
  rb_define_method(cOBForceField.klass, "validate", VALUEFUNC(_wrap_OBForceField_validate), -1);
  rb_define_method(cOBForceField.klass, "validate_gradients", VALUEFUNC(_wrap_OBForceField_validate_gradients), -1);
  rb_define_method(cOBForceField.klass, "validate_gradient_error", VALUEFUNC(_wrap_OBForceField_validate_gradient_error), -1);
  rb_define_singleton_method(cOBForceField.klass, "vector_length_derivative", VALUEFUNC(_wrap_OBForceField_vector_length_derivative), -1);
  rb_define_singleton_method(cOBForceField.klass, "vector_angle_derivative", VALUEFUNC(_wrap_OBForceField_vector_angle_derivative), -1);
  rb_define_singleton_method(cOBForceField.klass, "vector_torsion_derivative", VALUEFUNC(_wrap_OBForceField_vector_torsion_derivative), -1);
  rb_define_method(cOBForceField.klass, "kludge", VALUEFUNC(_wrap_OBForceField_kludge), -1);
  cOBForceField.mark = 0;
  cOBForceField.destroy = (void (*)(void *)) free_OpenBabel_OBForceField;
  cOBForceField.trackObjects = 0;
  
  cOBMolAtomIter.klass = rb_define_class_under(mOpenbabel, "OBMolAtomIter", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBMolAtomIter, (void *) &cOBMolAtomIter);
  rb_define_alloc_func(cOBMolAtomIter.klass, _wrap_OBMolAtomIter_allocate);
  rb_define_method(cOBMolAtomIter.klass, "initialize", VALUEFUNC(_wrap_new_OBMolAtomIter), -1);
  rb_define_method(cOBMolAtomIter.klass, "good", VALUEFUNC(_wrap_OBMolAtomIter_good), -1);
  rb_define_method(cOBMolAtomIter.klass, "inc", VALUEFUNC(_wrap_OBMolAtomIter_inc), -1);
  rb_define_method(cOBMolAtomIter.klass, "deref", VALUEFUNC(_wrap_OBMolAtomIter_deref), -1);
  rb_define_method(cOBMolAtomIter.klass, "__ref__", VALUEFUNC(_wrap_OBMolAtomIter___ref__), -1);
  rb_define_method(cOBMolAtomIter.klass, "Visit=", VALUEFUNC(_wrap_OBMolAtomIter_Visit_set), -1);
  rb_define_method(cOBMolAtomIter.klass, "Visit", VALUEFUNC(_wrap_OBMolAtomIter_Visit_get), -1);
  rb_define_method(cOBMolAtomIter.klass, "clear", VALUEFUNC(_wrap_OBMolAtomIter_clear), -1);
  rb_define_method(cOBMolAtomIter.klass, "set_idx", VALUEFUNC(_wrap_OBMolAtomIter_set_idx), -1);
  rb_define_method(cOBMolAtomIter.klass, "set_hyb", VALUEFUNC(_wrap_OBMolAtomIter_set_hyb), -1);
  rb_define_method(cOBMolAtomIter.klass, "set_atomic_num", VALUEFUNC(_wrap_OBMolAtomIter_set_atomic_num), -1);
  rb_define_method(cOBMolAtomIter.klass, "set_isotope", VALUEFUNC(_wrap_OBMolAtomIter_set_isotope), -1);
  rb_define_method(cOBMolAtomIter.klass, "set_implicit_valence", VALUEFUNC(_wrap_OBMolAtomIter_set_implicit_valence), -1);
  rb_define_method(cOBMolAtomIter.klass, "increment_implicit_valence", VALUEFUNC(_wrap_OBMolAtomIter_increment_implicit_valence), -1);
  rb_define_method(cOBMolAtomIter.klass, "decrement_implicit_valence", VALUEFUNC(_wrap_OBMolAtomIter_decrement_implicit_valence), -1);
  rb_define_method(cOBMolAtomIter.klass, "set_formal_charge", VALUEFUNC(_wrap_OBMolAtomIter_set_formal_charge), -1);
  rb_define_method(cOBMolAtomIter.klass, "set_spin_multiplicity", VALUEFUNC(_wrap_OBMolAtomIter_set_spin_multiplicity), -1);
  rb_define_method(cOBMolAtomIter.klass, "set_type", VALUEFUNC(_wrap_OBMolAtomIter_set_type), -1);
  rb_define_method(cOBMolAtomIter.klass, "set_partial_charge", VALUEFUNC(_wrap_OBMolAtomIter_set_partial_charge), -1);
  rb_define_method(cOBMolAtomIter.klass, "set_vector", VALUEFUNC(_wrap_OBMolAtomIter_set_vector), -1);
  rb_define_method(cOBMolAtomIter.klass, "set_coord_ptr", VALUEFUNC(_wrap_OBMolAtomIter_set_coord_ptr), -1);
  rb_define_method(cOBMolAtomIter.klass, "set_residue", VALUEFUNC(_wrap_OBMolAtomIter_set_residue), -1);
  rb_define_method(cOBMolAtomIter.klass, "set_parent", VALUEFUNC(_wrap_OBMolAtomIter_set_parent), -1);
  rb_define_method(cOBMolAtomIter.klass, "set_aromatic", VALUEFUNC(_wrap_OBMolAtomIter_set_aromatic), -1);
  rb_define_method(cOBMolAtomIter.klass, "unset_aromatic", VALUEFUNC(_wrap_OBMolAtomIter_unset_aromatic), -1);
  rb_define_method(cOBMolAtomIter.klass, "set_clockwise_stereo", VALUEFUNC(_wrap_OBMolAtomIter_set_clockwise_stereo), -1);
  rb_define_method(cOBMolAtomIter.klass, "set_anti_clockwise_stereo", VALUEFUNC(_wrap_OBMolAtomIter_set_anti_clockwise_stereo), -1);
  rb_define_method(cOBMolAtomIter.klass, "set_positive_stereo", VALUEFUNC(_wrap_OBMolAtomIter_set_positive_stereo), -1);
  rb_define_method(cOBMolAtomIter.klass, "set_negative_stereo", VALUEFUNC(_wrap_OBMolAtomIter_set_negative_stereo), -1);
  rb_define_method(cOBMolAtomIter.klass, "unset_stereo", VALUEFUNC(_wrap_OBMolAtomIter_unset_stereo), -1);
  rb_define_method(cOBMolAtomIter.klass, "set_in_ring", VALUEFUNC(_wrap_OBMolAtomIter_set_in_ring), -1);
  rb_define_method(cOBMolAtomIter.klass, "set_chiral", VALUEFUNC(_wrap_OBMolAtomIter_set_chiral), -1);
  rb_define_method(cOBMolAtomIter.klass, "clear_coord_ptr", VALUEFUNC(_wrap_OBMolAtomIter_clear_coord_ptr), -1);
  rb_define_method(cOBMolAtomIter.klass, "get_formal_charge", VALUEFUNC(_wrap_OBMolAtomIter_get_formal_charge), -1);
  rb_define_method(cOBMolAtomIter.klass, "get_atomic_num", VALUEFUNC(_wrap_OBMolAtomIter_get_atomic_num), -1);
  rb_define_method(cOBMolAtomIter.klass, "get_isotope", VALUEFUNC(_wrap_OBMolAtomIter_get_isotope), -1);
  rb_define_method(cOBMolAtomIter.klass, "get_spin_multiplicity", VALUEFUNC(_wrap_OBMolAtomIter_get_spin_multiplicity), -1);
  rb_define_method(cOBMolAtomIter.klass, "get_atomic_mass", VALUEFUNC(_wrap_OBMolAtomIter_get_atomic_mass), -1);
  rb_define_method(cOBMolAtomIter.klass, "get_exact_mass", VALUEFUNC(_wrap_OBMolAtomIter_get_exact_mass), -1);
  rb_define_method(cOBMolAtomIter.klass, "get_idx", VALUEFUNC(_wrap_OBMolAtomIter_get_idx), -1);
  rb_define_method(cOBMolAtomIter.klass, "get_coordinate_idx", VALUEFUNC(_wrap_OBMolAtomIter_get_coordinate_idx), -1);
  rb_define_method(cOBMolAtomIter.klass, "get_cidx", VALUEFUNC(_wrap_OBMolAtomIter_get_cidx), -1);
  rb_define_method(cOBMolAtomIter.klass, "get_valence", VALUEFUNC(_wrap_OBMolAtomIter_get_valence), -1);
  rb_define_method(cOBMolAtomIter.klass, "get_hyb", VALUEFUNC(_wrap_OBMolAtomIter_get_hyb), -1);
  rb_define_method(cOBMolAtomIter.klass, "get_implicit_valence", VALUEFUNC(_wrap_OBMolAtomIter_get_implicit_valence), -1);
  rb_define_method(cOBMolAtomIter.klass, "get_hvy_valence", VALUEFUNC(_wrap_OBMolAtomIter_get_hvy_valence), -1);
  rb_define_method(cOBMolAtomIter.klass, "get_hetero_valence", VALUEFUNC(_wrap_OBMolAtomIter_get_hetero_valence), -1);
  rb_define_method(cOBMolAtomIter.klass, "get_type", VALUEFUNC(_wrap_OBMolAtomIter_get_type), -1);
  rb_define_method(cOBMolAtomIter.klass, "get_x", VALUEFUNC(_wrap_OBMolAtomIter_get_x), -1);
  rb_define_method(cOBMolAtomIter.klass, "get_y", VALUEFUNC(_wrap_OBMolAtomIter_get_y), -1);
  rb_define_method(cOBMolAtomIter.klass, "get_z", VALUEFUNC(_wrap_OBMolAtomIter_get_z), -1);
  rb_define_method(cOBMolAtomIter.klass, "x", VALUEFUNC(_wrap_OBMolAtomIter_x), -1);
  rb_define_method(cOBMolAtomIter.klass, "y", VALUEFUNC(_wrap_OBMolAtomIter_y), -1);
  rb_define_method(cOBMolAtomIter.klass, "z", VALUEFUNC(_wrap_OBMolAtomIter_z), -1);
  rb_define_method(cOBMolAtomIter.klass, "get_coordinate", VALUEFUNC(_wrap_OBMolAtomIter_get_coordinate), -1);
  rb_define_method(cOBMolAtomIter.klass, "get_vector", VALUEFUNC(_wrap_OBMolAtomIter_get_vector), -1);
  rb_define_method(cOBMolAtomIter.klass, "get_partial_charge", VALUEFUNC(_wrap_OBMolAtomIter_get_partial_charge), -1);
  rb_define_method(cOBMolAtomIter.klass, "get_residue", VALUEFUNC(_wrap_OBMolAtomIter_get_residue), -1);
  rb_define_method(cOBMolAtomIter.klass, "get_parent", VALUEFUNC(_wrap_OBMolAtomIter_get_parent), -1);
  rb_define_method(cOBMolAtomIter.klass, "get_new_bond_vector", VALUEFUNC(_wrap_OBMolAtomIter_get_new_bond_vector), -1);
  rb_define_method(cOBMolAtomIter.klass, "get_bond", VALUEFUNC(_wrap_OBMolAtomIter_get_bond), -1);
  rb_define_method(cOBMolAtomIter.klass, "get_next_atom", VALUEFUNC(_wrap_OBMolAtomIter_get_next_atom), -1);
  rb_define_method(cOBMolAtomIter.klass, "begin_bonds", VALUEFUNC(_wrap_OBMolAtomIter_begin_bonds), -1);
  rb_define_method(cOBMolAtomIter.klass, "end_bonds", VALUEFUNC(_wrap_OBMolAtomIter_end_bonds), -1);
  rb_define_method(cOBMolAtomIter.klass, "begin_bond", VALUEFUNC(_wrap_OBMolAtomIter_begin_bond), -1);
  rb_define_method(cOBMolAtomIter.klass, "next_bond", VALUEFUNC(_wrap_OBMolAtomIter_next_bond), -1);
  rb_define_method(cOBMolAtomIter.klass, "begin_nbr_atom", VALUEFUNC(_wrap_OBMolAtomIter_begin_nbr_atom), -1);
  rb_define_method(cOBMolAtomIter.klass, "next_nbr_atom", VALUEFUNC(_wrap_OBMolAtomIter_next_nbr_atom), -1);
  rb_define_method(cOBMolAtomIter.klass, "get_distance", VALUEFUNC(_wrap_OBMolAtomIter_get_distance), -1);
  rb_define_method(cOBMolAtomIter.klass, "get_angle", VALUEFUNC(_wrap_OBMolAtomIter_get_angle), -1);
  rb_define_method(cOBMolAtomIter.klass, "new_residue", VALUEFUNC(_wrap_OBMolAtomIter_new_residue), -1);
  rb_define_method(cOBMolAtomIter.klass, "add_residue", VALUEFUNC(_wrap_OBMolAtomIter_add_residue), -1);
  rb_define_method(cOBMolAtomIter.klass, "delete_residue", VALUEFUNC(_wrap_OBMolAtomIter_delete_residue), -1);
  rb_define_method(cOBMolAtomIter.klass, "add_bond", VALUEFUNC(_wrap_OBMolAtomIter_add_bond), -1);
  rb_define_method(cOBMolAtomIter.klass, "insert_bond", VALUEFUNC(_wrap_OBMolAtomIter_insert_bond), -1);
  rb_define_method(cOBMolAtomIter.klass, "delete_bond", VALUEFUNC(_wrap_OBMolAtomIter_delete_bond), -1);
  rb_define_method(cOBMolAtomIter.klass, "clear_bond", VALUEFUNC(_wrap_OBMolAtomIter_clear_bond), -1);
  rb_define_method(cOBMolAtomIter.klass, "hto_methyl", VALUEFUNC(_wrap_OBMolAtomIter_hto_methyl), -1);
  rb_define_method(cOBMolAtomIter.klass, "set_hyb_and_geom", VALUEFUNC(_wrap_OBMolAtomIter_set_hyb_and_geom), -1);
  rb_define_method(cOBMolAtomIter.klass, "force_no_h", VALUEFUNC(_wrap_OBMolAtomIter_force_no_h), -1);
  rb_define_method(cOBMolAtomIter.klass, "has_no_hforced", VALUEFUNC(_wrap_OBMolAtomIter_has_no_hforced), -1);
  rb_define_method(cOBMolAtomIter.klass, "count_free_oxygens", VALUEFUNC(_wrap_OBMolAtomIter_count_free_oxygens), -1);
  rb_define_method(cOBMolAtomIter.klass, "implicit_hydrogen_count", VALUEFUNC(_wrap_OBMolAtomIter_implicit_hydrogen_count), -1);
  rb_define_method(cOBMolAtomIter.klass, "explicit_hydrogen_count", VALUEFUNC(_wrap_OBMolAtomIter_explicit_hydrogen_count), -1);
  rb_define_method(cOBMolAtomIter.klass, "member_of_ring_count", VALUEFUNC(_wrap_OBMolAtomIter_member_of_ring_count), -1);
  rb_define_method(cOBMolAtomIter.klass, "member_of_ring_size", VALUEFUNC(_wrap_OBMolAtomIter_member_of_ring_size), -1);
  rb_define_method(cOBMolAtomIter.klass, "count_ring_bonds", VALUEFUNC(_wrap_OBMolAtomIter_count_ring_bonds), -1);
  rb_define_method(cOBMolAtomIter.klass, "smallest_bond_angle", VALUEFUNC(_wrap_OBMolAtomIter_smallest_bond_angle), -1);
  rb_define_method(cOBMolAtomIter.klass, "average_bond_angle", VALUEFUNC(_wrap_OBMolAtomIter_average_bond_angle), -1);
  rb_define_method(cOBMolAtomIter.klass, "bosum", VALUEFUNC(_wrap_OBMolAtomIter_bosum), -1);
  rb_define_method(cOBMolAtomIter.klass, "kbosum", VALUEFUNC(_wrap_OBMolAtomIter_kbosum), -1);
  rb_define_method(cOBMolAtomIter.klass, "has_residue", VALUEFUNC(_wrap_OBMolAtomIter_has_residue), -1);
  rb_define_method(cOBMolAtomIter.klass, "is_hydrogen", VALUEFUNC(_wrap_OBMolAtomIter_is_hydrogen), -1);
  rb_define_method(cOBMolAtomIter.klass, "is_carbon", VALUEFUNC(_wrap_OBMolAtomIter_is_carbon), -1);
  rb_define_method(cOBMolAtomIter.klass, "is_nitrogen", VALUEFUNC(_wrap_OBMolAtomIter_is_nitrogen), -1);
  rb_define_method(cOBMolAtomIter.klass, "is_oxygen", VALUEFUNC(_wrap_OBMolAtomIter_is_oxygen), -1);
  rb_define_method(cOBMolAtomIter.klass, "is_sulfur", VALUEFUNC(_wrap_OBMolAtomIter_is_sulfur), -1);
  rb_define_method(cOBMolAtomIter.klass, "is_phosphorus", VALUEFUNC(_wrap_OBMolAtomIter_is_phosphorus), -1);
  rb_define_method(cOBMolAtomIter.klass, "is_aromatic", VALUEFUNC(_wrap_OBMolAtomIter_is_aromatic), -1);
  rb_define_method(cOBMolAtomIter.klass, "is_in_ring", VALUEFUNC(_wrap_OBMolAtomIter_is_in_ring), -1);
  rb_define_method(cOBMolAtomIter.klass, "is_in_ring_size", VALUEFUNC(_wrap_OBMolAtomIter_is_in_ring_size), -1);
  rb_define_method(cOBMolAtomIter.klass, "is_heteroatom", VALUEFUNC(_wrap_OBMolAtomIter_is_heteroatom), -1);
  rb_define_method(cOBMolAtomIter.klass, "is_not_cor_h", VALUEFUNC(_wrap_OBMolAtomIter_is_not_cor_h), -1);
  rb_define_method(cOBMolAtomIter.klass, "is_connected", VALUEFUNC(_wrap_OBMolAtomIter_is_connected), -1);
  rb_define_method(cOBMolAtomIter.klass, "is_one_three", VALUEFUNC(_wrap_OBMolAtomIter_is_one_three), -1);
  rb_define_method(cOBMolAtomIter.klass, "is_one_four", VALUEFUNC(_wrap_OBMolAtomIter_is_one_four), -1);
  rb_define_method(cOBMolAtomIter.klass, "is_carboxyl_oxygen", VALUEFUNC(_wrap_OBMolAtomIter_is_carboxyl_oxygen), -1);
  rb_define_method(cOBMolAtomIter.klass, "is_phosphate_oxygen", VALUEFUNC(_wrap_OBMolAtomIter_is_phosphate_oxygen), -1);
  rb_define_method(cOBMolAtomIter.klass, "is_sulfate_oxygen", VALUEFUNC(_wrap_OBMolAtomIter_is_sulfate_oxygen), -1);
  rb_define_method(cOBMolAtomIter.klass, "is_nitro_oxygen", VALUEFUNC(_wrap_OBMolAtomIter_is_nitro_oxygen), -1);
  rb_define_method(cOBMolAtomIter.klass, "is_amide_nitrogen", VALUEFUNC(_wrap_OBMolAtomIter_is_amide_nitrogen), -1);
  rb_define_method(cOBMolAtomIter.klass, "is_polar_hydrogen", VALUEFUNC(_wrap_OBMolAtomIter_is_polar_hydrogen), -1);
  rb_define_method(cOBMolAtomIter.klass, "is_non_polar_hydrogen", VALUEFUNC(_wrap_OBMolAtomIter_is_non_polar_hydrogen), -1);
  rb_define_method(cOBMolAtomIter.klass, "is_aromatic_noxide", VALUEFUNC(_wrap_OBMolAtomIter_is_aromatic_noxide), -1);
  rb_define_method(cOBMolAtomIter.klass, "is_chiral", VALUEFUNC(_wrap_OBMolAtomIter_is_chiral), -1);
  rb_define_method(cOBMolAtomIter.klass, "is_axial", VALUEFUNC(_wrap_OBMolAtomIter_is_axial), -1);
  rb_define_method(cOBMolAtomIter.klass, "is_clockwise", VALUEFUNC(_wrap_OBMolAtomIter_is_clockwise), -1);
  rb_define_method(cOBMolAtomIter.klass, "is_anti_clockwise", VALUEFUNC(_wrap_OBMolAtomIter_is_anti_clockwise), -1);
  rb_define_method(cOBMolAtomIter.klass, "is_positive_stereo", VALUEFUNC(_wrap_OBMolAtomIter_is_positive_stereo), -1);
  rb_define_method(cOBMolAtomIter.klass, "is_negative_stereo", VALUEFUNC(_wrap_OBMolAtomIter_is_negative_stereo), -1);
  rb_define_method(cOBMolAtomIter.klass, "has_chirality_specified", VALUEFUNC(_wrap_OBMolAtomIter_has_chirality_specified), -1);
  rb_define_method(cOBMolAtomIter.klass, "has_chiral_volume", VALUEFUNC(_wrap_OBMolAtomIter_has_chiral_volume), -1);
  rb_define_method(cOBMolAtomIter.klass, "is_hbond_acceptor", VALUEFUNC(_wrap_OBMolAtomIter_is_hbond_acceptor), -1);
  rb_define_method(cOBMolAtomIter.klass, "is_hbond_donor", VALUEFUNC(_wrap_OBMolAtomIter_is_hbond_donor), -1);
  rb_define_method(cOBMolAtomIter.klass, "is_hbond_donor_h", VALUEFUNC(_wrap_OBMolAtomIter_is_hbond_donor_h), -1);
  rb_define_method(cOBMolAtomIter.klass, "has_alpha_beta_unsat", VALUEFUNC(_wrap_OBMolAtomIter_has_alpha_beta_unsat), -1);
  rb_define_method(cOBMolAtomIter.klass, "has_bond_of_order", VALUEFUNC(_wrap_OBMolAtomIter_has_bond_of_order), -1);
  rb_define_method(cOBMolAtomIter.klass, "count_bonds_of_order", VALUEFUNC(_wrap_OBMolAtomIter_count_bonds_of_order), -1);
  rb_define_method(cOBMolAtomIter.klass, "has_non_single_bond", VALUEFUNC(_wrap_OBMolAtomIter_has_non_single_bond), -1);
  rb_define_method(cOBMolAtomIter.klass, "has_single_bond", VALUEFUNC(_wrap_OBMolAtomIter_has_single_bond), -1);
  rb_define_method(cOBMolAtomIter.klass, "has_double_bond", VALUEFUNC(_wrap_OBMolAtomIter_has_double_bond), -1);
  rb_define_method(cOBMolAtomIter.klass, "has_aromatic_bond", VALUEFUNC(_wrap_OBMolAtomIter_has_aromatic_bond), -1);
  rb_define_method(cOBMolAtomIter.klass, "matches_smarts", VALUEFUNC(_wrap_OBMolAtomIter_matches_smarts), -1);
  rb_define_method(cOBMolAtomIter.klass, "do_transformations", VALUEFUNC(_wrap_OBMolAtomIter_do_transformations), -1);
  rb_define_method(cOBMolAtomIter.klass, "class_description", VALUEFUNC(_wrap_OBMolAtomIter_class_description), -1);
  rb_define_method(cOBMolAtomIter.klass, "has_data", VALUEFUNC(_wrap_OBMolAtomIter_has_data), -1);
  rb_define_method(cOBMolAtomIter.klass, "delete_data", VALUEFUNC(_wrap_OBMolAtomIter_delete_data), -1);
  rb_define_method(cOBMolAtomIter.klass, "set_data", VALUEFUNC(_wrap_OBMolAtomIter_set_data), -1);
  rb_define_method(cOBMolAtomIter.klass, "data_size", VALUEFUNC(_wrap_OBMolAtomIter_data_size), -1);
  rb_define_method(cOBMolAtomIter.klass, "get_data", VALUEFUNC(_wrap_OBMolAtomIter_get_data), -1);
  rb_define_method(cOBMolAtomIter.klass, "begin_data", VALUEFUNC(_wrap_OBMolAtomIter_begin_data), -1);
  rb_define_method(cOBMolAtomIter.klass, "end_data", VALUEFUNC(_wrap_OBMolAtomIter_end_data), -1);
  cOBMolAtomIter.mark = 0;
  cOBMolAtomIter.destroy = (void (*)(void *)) free_OpenBabel_OBMolAtomIter;
  cOBMolAtomIter.trackObjects = 0;
  
  cOBMolAtomDFSIter.klass = rb_define_class_under(mOpenbabel, "OBMolAtomDFSIter", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter, (void *) &cOBMolAtomDFSIter);
  rb_define_alloc_func(cOBMolAtomDFSIter.klass, _wrap_OBMolAtomDFSIter_allocate);
  rb_define_method(cOBMolAtomDFSIter.klass, "initialize", VALUEFUNC(_wrap_new_OBMolAtomDFSIter), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "good", VALUEFUNC(_wrap_OBMolAtomDFSIter_good), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "inc", VALUEFUNC(_wrap_OBMolAtomDFSIter_inc), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "deref", VALUEFUNC(_wrap_OBMolAtomDFSIter_deref), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "__ref__", VALUEFUNC(_wrap_OBMolAtomDFSIter___ref__), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "next", VALUEFUNC(_wrap_OBMolAtomDFSIter_next), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "Visit=", VALUEFUNC(_wrap_OBMolAtomDFSIter_Visit_set), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "Visit", VALUEFUNC(_wrap_OBMolAtomDFSIter_Visit_get), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "clear", VALUEFUNC(_wrap_OBMolAtomDFSIter_clear), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "set_idx", VALUEFUNC(_wrap_OBMolAtomDFSIter_set_idx), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "set_hyb", VALUEFUNC(_wrap_OBMolAtomDFSIter_set_hyb), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "set_atomic_num", VALUEFUNC(_wrap_OBMolAtomDFSIter_set_atomic_num), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "set_isotope", VALUEFUNC(_wrap_OBMolAtomDFSIter_set_isotope), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "set_implicit_valence", VALUEFUNC(_wrap_OBMolAtomDFSIter_set_implicit_valence), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "increment_implicit_valence", VALUEFUNC(_wrap_OBMolAtomDFSIter_increment_implicit_valence), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "decrement_implicit_valence", VALUEFUNC(_wrap_OBMolAtomDFSIter_decrement_implicit_valence), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "set_formal_charge", VALUEFUNC(_wrap_OBMolAtomDFSIter_set_formal_charge), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "set_spin_multiplicity", VALUEFUNC(_wrap_OBMolAtomDFSIter_set_spin_multiplicity), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "set_type", VALUEFUNC(_wrap_OBMolAtomDFSIter_set_type), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "set_partial_charge", VALUEFUNC(_wrap_OBMolAtomDFSIter_set_partial_charge), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "set_vector", VALUEFUNC(_wrap_OBMolAtomDFSIter_set_vector), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "set_coord_ptr", VALUEFUNC(_wrap_OBMolAtomDFSIter_set_coord_ptr), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "set_residue", VALUEFUNC(_wrap_OBMolAtomDFSIter_set_residue), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "set_parent", VALUEFUNC(_wrap_OBMolAtomDFSIter_set_parent), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "set_aromatic", VALUEFUNC(_wrap_OBMolAtomDFSIter_set_aromatic), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "unset_aromatic", VALUEFUNC(_wrap_OBMolAtomDFSIter_unset_aromatic), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "set_clockwise_stereo", VALUEFUNC(_wrap_OBMolAtomDFSIter_set_clockwise_stereo), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "set_anti_clockwise_stereo", VALUEFUNC(_wrap_OBMolAtomDFSIter_set_anti_clockwise_stereo), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "set_positive_stereo", VALUEFUNC(_wrap_OBMolAtomDFSIter_set_positive_stereo), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "set_negative_stereo", VALUEFUNC(_wrap_OBMolAtomDFSIter_set_negative_stereo), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "unset_stereo", VALUEFUNC(_wrap_OBMolAtomDFSIter_unset_stereo), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "set_in_ring", VALUEFUNC(_wrap_OBMolAtomDFSIter_set_in_ring), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "set_chiral", VALUEFUNC(_wrap_OBMolAtomDFSIter_set_chiral), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "clear_coord_ptr", VALUEFUNC(_wrap_OBMolAtomDFSIter_clear_coord_ptr), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "get_formal_charge", VALUEFUNC(_wrap_OBMolAtomDFSIter_get_formal_charge), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "get_atomic_num", VALUEFUNC(_wrap_OBMolAtomDFSIter_get_atomic_num), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "get_isotope", VALUEFUNC(_wrap_OBMolAtomDFSIter_get_isotope), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "get_spin_multiplicity", VALUEFUNC(_wrap_OBMolAtomDFSIter_get_spin_multiplicity), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "get_atomic_mass", VALUEFUNC(_wrap_OBMolAtomDFSIter_get_atomic_mass), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "get_exact_mass", VALUEFUNC(_wrap_OBMolAtomDFSIter_get_exact_mass), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "get_idx", VALUEFUNC(_wrap_OBMolAtomDFSIter_get_idx), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "get_coordinate_idx", VALUEFUNC(_wrap_OBMolAtomDFSIter_get_coordinate_idx), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "get_cidx", VALUEFUNC(_wrap_OBMolAtomDFSIter_get_cidx), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "get_valence", VALUEFUNC(_wrap_OBMolAtomDFSIter_get_valence), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "get_hyb", VALUEFUNC(_wrap_OBMolAtomDFSIter_get_hyb), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "get_implicit_valence", VALUEFUNC(_wrap_OBMolAtomDFSIter_get_implicit_valence), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "get_hvy_valence", VALUEFUNC(_wrap_OBMolAtomDFSIter_get_hvy_valence), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "get_hetero_valence", VALUEFUNC(_wrap_OBMolAtomDFSIter_get_hetero_valence), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "get_type", VALUEFUNC(_wrap_OBMolAtomDFSIter_get_type), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "get_x", VALUEFUNC(_wrap_OBMolAtomDFSIter_get_x), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "get_y", VALUEFUNC(_wrap_OBMolAtomDFSIter_get_y), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "get_z", VALUEFUNC(_wrap_OBMolAtomDFSIter_get_z), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "x", VALUEFUNC(_wrap_OBMolAtomDFSIter_x), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "y", VALUEFUNC(_wrap_OBMolAtomDFSIter_y), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "z", VALUEFUNC(_wrap_OBMolAtomDFSIter_z), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "get_coordinate", VALUEFUNC(_wrap_OBMolAtomDFSIter_get_coordinate), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "get_vector", VALUEFUNC(_wrap_OBMolAtomDFSIter_get_vector), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "get_partial_charge", VALUEFUNC(_wrap_OBMolAtomDFSIter_get_partial_charge), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "get_residue", VALUEFUNC(_wrap_OBMolAtomDFSIter_get_residue), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "get_parent", VALUEFUNC(_wrap_OBMolAtomDFSIter_get_parent), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "get_new_bond_vector", VALUEFUNC(_wrap_OBMolAtomDFSIter_get_new_bond_vector), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "get_bond", VALUEFUNC(_wrap_OBMolAtomDFSIter_get_bond), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "get_next_atom", VALUEFUNC(_wrap_OBMolAtomDFSIter_get_next_atom), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "begin_bonds", VALUEFUNC(_wrap_OBMolAtomDFSIter_begin_bonds), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "end_bonds", VALUEFUNC(_wrap_OBMolAtomDFSIter_end_bonds), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "begin_bond", VALUEFUNC(_wrap_OBMolAtomDFSIter_begin_bond), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "next_bond", VALUEFUNC(_wrap_OBMolAtomDFSIter_next_bond), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "begin_nbr_atom", VALUEFUNC(_wrap_OBMolAtomDFSIter_begin_nbr_atom), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "next_nbr_atom", VALUEFUNC(_wrap_OBMolAtomDFSIter_next_nbr_atom), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "get_distance", VALUEFUNC(_wrap_OBMolAtomDFSIter_get_distance), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "get_angle", VALUEFUNC(_wrap_OBMolAtomDFSIter_get_angle), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "new_residue", VALUEFUNC(_wrap_OBMolAtomDFSIter_new_residue), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "add_residue", VALUEFUNC(_wrap_OBMolAtomDFSIter_add_residue), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "delete_residue", VALUEFUNC(_wrap_OBMolAtomDFSIter_delete_residue), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "add_bond", VALUEFUNC(_wrap_OBMolAtomDFSIter_add_bond), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "insert_bond", VALUEFUNC(_wrap_OBMolAtomDFSIter_insert_bond), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "delete_bond", VALUEFUNC(_wrap_OBMolAtomDFSIter_delete_bond), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "clear_bond", VALUEFUNC(_wrap_OBMolAtomDFSIter_clear_bond), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "hto_methyl", VALUEFUNC(_wrap_OBMolAtomDFSIter_hto_methyl), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "set_hyb_and_geom", VALUEFUNC(_wrap_OBMolAtomDFSIter_set_hyb_and_geom), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "force_no_h", VALUEFUNC(_wrap_OBMolAtomDFSIter_force_no_h), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "has_no_hforced", VALUEFUNC(_wrap_OBMolAtomDFSIter_has_no_hforced), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "count_free_oxygens", VALUEFUNC(_wrap_OBMolAtomDFSIter_count_free_oxygens), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "implicit_hydrogen_count", VALUEFUNC(_wrap_OBMolAtomDFSIter_implicit_hydrogen_count), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "explicit_hydrogen_count", VALUEFUNC(_wrap_OBMolAtomDFSIter_explicit_hydrogen_count), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "member_of_ring_count", VALUEFUNC(_wrap_OBMolAtomDFSIter_member_of_ring_count), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "member_of_ring_size", VALUEFUNC(_wrap_OBMolAtomDFSIter_member_of_ring_size), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "count_ring_bonds", VALUEFUNC(_wrap_OBMolAtomDFSIter_count_ring_bonds), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "smallest_bond_angle", VALUEFUNC(_wrap_OBMolAtomDFSIter_smallest_bond_angle), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "average_bond_angle", VALUEFUNC(_wrap_OBMolAtomDFSIter_average_bond_angle), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "bosum", VALUEFUNC(_wrap_OBMolAtomDFSIter_bosum), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "kbosum", VALUEFUNC(_wrap_OBMolAtomDFSIter_kbosum), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "has_residue", VALUEFUNC(_wrap_OBMolAtomDFSIter_has_residue), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "is_hydrogen", VALUEFUNC(_wrap_OBMolAtomDFSIter_is_hydrogen), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "is_carbon", VALUEFUNC(_wrap_OBMolAtomDFSIter_is_carbon), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "is_nitrogen", VALUEFUNC(_wrap_OBMolAtomDFSIter_is_nitrogen), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "is_oxygen", VALUEFUNC(_wrap_OBMolAtomDFSIter_is_oxygen), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "is_sulfur", VALUEFUNC(_wrap_OBMolAtomDFSIter_is_sulfur), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "is_phosphorus", VALUEFUNC(_wrap_OBMolAtomDFSIter_is_phosphorus), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "is_aromatic", VALUEFUNC(_wrap_OBMolAtomDFSIter_is_aromatic), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "is_in_ring", VALUEFUNC(_wrap_OBMolAtomDFSIter_is_in_ring), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "is_in_ring_size", VALUEFUNC(_wrap_OBMolAtomDFSIter_is_in_ring_size), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "is_heteroatom", VALUEFUNC(_wrap_OBMolAtomDFSIter_is_heteroatom), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "is_not_cor_h", VALUEFUNC(_wrap_OBMolAtomDFSIter_is_not_cor_h), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "is_connected", VALUEFUNC(_wrap_OBMolAtomDFSIter_is_connected), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "is_one_three", VALUEFUNC(_wrap_OBMolAtomDFSIter_is_one_three), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "is_one_four", VALUEFUNC(_wrap_OBMolAtomDFSIter_is_one_four), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "is_carboxyl_oxygen", VALUEFUNC(_wrap_OBMolAtomDFSIter_is_carboxyl_oxygen), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "is_phosphate_oxygen", VALUEFUNC(_wrap_OBMolAtomDFSIter_is_phosphate_oxygen), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "is_sulfate_oxygen", VALUEFUNC(_wrap_OBMolAtomDFSIter_is_sulfate_oxygen), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "is_nitro_oxygen", VALUEFUNC(_wrap_OBMolAtomDFSIter_is_nitro_oxygen), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "is_amide_nitrogen", VALUEFUNC(_wrap_OBMolAtomDFSIter_is_amide_nitrogen), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "is_polar_hydrogen", VALUEFUNC(_wrap_OBMolAtomDFSIter_is_polar_hydrogen), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "is_non_polar_hydrogen", VALUEFUNC(_wrap_OBMolAtomDFSIter_is_non_polar_hydrogen), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "is_aromatic_noxide", VALUEFUNC(_wrap_OBMolAtomDFSIter_is_aromatic_noxide), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "is_chiral", VALUEFUNC(_wrap_OBMolAtomDFSIter_is_chiral), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "is_axial", VALUEFUNC(_wrap_OBMolAtomDFSIter_is_axial), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "is_clockwise", VALUEFUNC(_wrap_OBMolAtomDFSIter_is_clockwise), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "is_anti_clockwise", VALUEFUNC(_wrap_OBMolAtomDFSIter_is_anti_clockwise), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "is_positive_stereo", VALUEFUNC(_wrap_OBMolAtomDFSIter_is_positive_stereo), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "is_negative_stereo", VALUEFUNC(_wrap_OBMolAtomDFSIter_is_negative_stereo), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "has_chirality_specified", VALUEFUNC(_wrap_OBMolAtomDFSIter_has_chirality_specified), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "has_chiral_volume", VALUEFUNC(_wrap_OBMolAtomDFSIter_has_chiral_volume), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "is_hbond_acceptor", VALUEFUNC(_wrap_OBMolAtomDFSIter_is_hbond_acceptor), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "is_hbond_donor", VALUEFUNC(_wrap_OBMolAtomDFSIter_is_hbond_donor), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "is_hbond_donor_h", VALUEFUNC(_wrap_OBMolAtomDFSIter_is_hbond_donor_h), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "has_alpha_beta_unsat", VALUEFUNC(_wrap_OBMolAtomDFSIter_has_alpha_beta_unsat), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "has_bond_of_order", VALUEFUNC(_wrap_OBMolAtomDFSIter_has_bond_of_order), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "count_bonds_of_order", VALUEFUNC(_wrap_OBMolAtomDFSIter_count_bonds_of_order), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "has_non_single_bond", VALUEFUNC(_wrap_OBMolAtomDFSIter_has_non_single_bond), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "has_single_bond", VALUEFUNC(_wrap_OBMolAtomDFSIter_has_single_bond), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "has_double_bond", VALUEFUNC(_wrap_OBMolAtomDFSIter_has_double_bond), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "has_aromatic_bond", VALUEFUNC(_wrap_OBMolAtomDFSIter_has_aromatic_bond), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "matches_smarts", VALUEFUNC(_wrap_OBMolAtomDFSIter_matches_smarts), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "do_transformations", VALUEFUNC(_wrap_OBMolAtomDFSIter_do_transformations), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "class_description", VALUEFUNC(_wrap_OBMolAtomDFSIter_class_description), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "has_data", VALUEFUNC(_wrap_OBMolAtomDFSIter_has_data), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "delete_data", VALUEFUNC(_wrap_OBMolAtomDFSIter_delete_data), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "set_data", VALUEFUNC(_wrap_OBMolAtomDFSIter_set_data), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "data_size", VALUEFUNC(_wrap_OBMolAtomDFSIter_data_size), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "get_data", VALUEFUNC(_wrap_OBMolAtomDFSIter_get_data), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "begin_data", VALUEFUNC(_wrap_OBMolAtomDFSIter_begin_data), -1);
  rb_define_method(cOBMolAtomDFSIter.klass, "end_data", VALUEFUNC(_wrap_OBMolAtomDFSIter_end_data), -1);
  cOBMolAtomDFSIter.mark = 0;
  cOBMolAtomDFSIter.destroy = (void (*)(void *)) free_OpenBabel_OBMolAtomDFSIter;
  cOBMolAtomDFSIter.trackObjects = 0;
  
  cOBMolAtomBFSIter.klass = rb_define_class_under(mOpenbabel, "OBMolAtomBFSIter", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBMolAtomBFSIter, (void *) &cOBMolAtomBFSIter);
  rb_define_alloc_func(cOBMolAtomBFSIter.klass, _wrap_OBMolAtomBFSIter_allocate);
  rb_define_method(cOBMolAtomBFSIter.klass, "initialize", VALUEFUNC(_wrap_new_OBMolAtomBFSIter), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "good", VALUEFUNC(_wrap_OBMolAtomBFSIter_good), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "inc", VALUEFUNC(_wrap_OBMolAtomBFSIter_inc), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "deref", VALUEFUNC(_wrap_OBMolAtomBFSIter_deref), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "__ref__", VALUEFUNC(_wrap_OBMolAtomBFSIter___ref__), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "Visit=", VALUEFUNC(_wrap_OBMolAtomBFSIter_Visit_set), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "Visit", VALUEFUNC(_wrap_OBMolAtomBFSIter_Visit_get), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "clear", VALUEFUNC(_wrap_OBMolAtomBFSIter_clear), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "set_idx", VALUEFUNC(_wrap_OBMolAtomBFSIter_set_idx), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "set_hyb", VALUEFUNC(_wrap_OBMolAtomBFSIter_set_hyb), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "set_atomic_num", VALUEFUNC(_wrap_OBMolAtomBFSIter_set_atomic_num), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "set_isotope", VALUEFUNC(_wrap_OBMolAtomBFSIter_set_isotope), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "set_implicit_valence", VALUEFUNC(_wrap_OBMolAtomBFSIter_set_implicit_valence), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "increment_implicit_valence", VALUEFUNC(_wrap_OBMolAtomBFSIter_increment_implicit_valence), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "decrement_implicit_valence", VALUEFUNC(_wrap_OBMolAtomBFSIter_decrement_implicit_valence), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "set_formal_charge", VALUEFUNC(_wrap_OBMolAtomBFSIter_set_formal_charge), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "set_spin_multiplicity", VALUEFUNC(_wrap_OBMolAtomBFSIter_set_spin_multiplicity), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "set_type", VALUEFUNC(_wrap_OBMolAtomBFSIter_set_type), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "set_partial_charge", VALUEFUNC(_wrap_OBMolAtomBFSIter_set_partial_charge), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "set_vector", VALUEFUNC(_wrap_OBMolAtomBFSIter_set_vector), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "set_coord_ptr", VALUEFUNC(_wrap_OBMolAtomBFSIter_set_coord_ptr), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "set_residue", VALUEFUNC(_wrap_OBMolAtomBFSIter_set_residue), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "set_parent", VALUEFUNC(_wrap_OBMolAtomBFSIter_set_parent), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "set_aromatic", VALUEFUNC(_wrap_OBMolAtomBFSIter_set_aromatic), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "unset_aromatic", VALUEFUNC(_wrap_OBMolAtomBFSIter_unset_aromatic), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "set_clockwise_stereo", VALUEFUNC(_wrap_OBMolAtomBFSIter_set_clockwise_stereo), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "set_anti_clockwise_stereo", VALUEFUNC(_wrap_OBMolAtomBFSIter_set_anti_clockwise_stereo), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "set_positive_stereo", VALUEFUNC(_wrap_OBMolAtomBFSIter_set_positive_stereo), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "set_negative_stereo", VALUEFUNC(_wrap_OBMolAtomBFSIter_set_negative_stereo), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "unset_stereo", VALUEFUNC(_wrap_OBMolAtomBFSIter_unset_stereo), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "set_in_ring", VALUEFUNC(_wrap_OBMolAtomBFSIter_set_in_ring), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "set_chiral", VALUEFUNC(_wrap_OBMolAtomBFSIter_set_chiral), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "clear_coord_ptr", VALUEFUNC(_wrap_OBMolAtomBFSIter_clear_coord_ptr), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "get_formal_charge", VALUEFUNC(_wrap_OBMolAtomBFSIter_get_formal_charge), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "get_atomic_num", VALUEFUNC(_wrap_OBMolAtomBFSIter_get_atomic_num), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "get_isotope", VALUEFUNC(_wrap_OBMolAtomBFSIter_get_isotope), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "get_spin_multiplicity", VALUEFUNC(_wrap_OBMolAtomBFSIter_get_spin_multiplicity), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "get_atomic_mass", VALUEFUNC(_wrap_OBMolAtomBFSIter_get_atomic_mass), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "get_exact_mass", VALUEFUNC(_wrap_OBMolAtomBFSIter_get_exact_mass), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "get_idx", VALUEFUNC(_wrap_OBMolAtomBFSIter_get_idx), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "get_coordinate_idx", VALUEFUNC(_wrap_OBMolAtomBFSIter_get_coordinate_idx), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "get_cidx", VALUEFUNC(_wrap_OBMolAtomBFSIter_get_cidx), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "get_valence", VALUEFUNC(_wrap_OBMolAtomBFSIter_get_valence), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "get_hyb", VALUEFUNC(_wrap_OBMolAtomBFSIter_get_hyb), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "get_implicit_valence", VALUEFUNC(_wrap_OBMolAtomBFSIter_get_implicit_valence), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "get_hvy_valence", VALUEFUNC(_wrap_OBMolAtomBFSIter_get_hvy_valence), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "get_hetero_valence", VALUEFUNC(_wrap_OBMolAtomBFSIter_get_hetero_valence), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "get_type", VALUEFUNC(_wrap_OBMolAtomBFSIter_get_type), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "get_x", VALUEFUNC(_wrap_OBMolAtomBFSIter_get_x), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "get_y", VALUEFUNC(_wrap_OBMolAtomBFSIter_get_y), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "get_z", VALUEFUNC(_wrap_OBMolAtomBFSIter_get_z), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "x", VALUEFUNC(_wrap_OBMolAtomBFSIter_x), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "y", VALUEFUNC(_wrap_OBMolAtomBFSIter_y), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "z", VALUEFUNC(_wrap_OBMolAtomBFSIter_z), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "get_coordinate", VALUEFUNC(_wrap_OBMolAtomBFSIter_get_coordinate), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "get_vector", VALUEFUNC(_wrap_OBMolAtomBFSIter_get_vector), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "get_partial_charge", VALUEFUNC(_wrap_OBMolAtomBFSIter_get_partial_charge), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "get_residue", VALUEFUNC(_wrap_OBMolAtomBFSIter_get_residue), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "get_parent", VALUEFUNC(_wrap_OBMolAtomBFSIter_get_parent), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "get_new_bond_vector", VALUEFUNC(_wrap_OBMolAtomBFSIter_get_new_bond_vector), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "get_bond", VALUEFUNC(_wrap_OBMolAtomBFSIter_get_bond), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "get_next_atom", VALUEFUNC(_wrap_OBMolAtomBFSIter_get_next_atom), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "begin_bonds", VALUEFUNC(_wrap_OBMolAtomBFSIter_begin_bonds), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "end_bonds", VALUEFUNC(_wrap_OBMolAtomBFSIter_end_bonds), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "begin_bond", VALUEFUNC(_wrap_OBMolAtomBFSIter_begin_bond), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "next_bond", VALUEFUNC(_wrap_OBMolAtomBFSIter_next_bond), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "begin_nbr_atom", VALUEFUNC(_wrap_OBMolAtomBFSIter_begin_nbr_atom), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "next_nbr_atom", VALUEFUNC(_wrap_OBMolAtomBFSIter_next_nbr_atom), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "get_distance", VALUEFUNC(_wrap_OBMolAtomBFSIter_get_distance), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "get_angle", VALUEFUNC(_wrap_OBMolAtomBFSIter_get_angle), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "new_residue", VALUEFUNC(_wrap_OBMolAtomBFSIter_new_residue), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "add_residue", VALUEFUNC(_wrap_OBMolAtomBFSIter_add_residue), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "delete_residue", VALUEFUNC(_wrap_OBMolAtomBFSIter_delete_residue), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "add_bond", VALUEFUNC(_wrap_OBMolAtomBFSIter_add_bond), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "insert_bond", VALUEFUNC(_wrap_OBMolAtomBFSIter_insert_bond), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "delete_bond", VALUEFUNC(_wrap_OBMolAtomBFSIter_delete_bond), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "clear_bond", VALUEFUNC(_wrap_OBMolAtomBFSIter_clear_bond), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "hto_methyl", VALUEFUNC(_wrap_OBMolAtomBFSIter_hto_methyl), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "set_hyb_and_geom", VALUEFUNC(_wrap_OBMolAtomBFSIter_set_hyb_and_geom), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "force_no_h", VALUEFUNC(_wrap_OBMolAtomBFSIter_force_no_h), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "has_no_hforced", VALUEFUNC(_wrap_OBMolAtomBFSIter_has_no_hforced), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "count_free_oxygens", VALUEFUNC(_wrap_OBMolAtomBFSIter_count_free_oxygens), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "implicit_hydrogen_count", VALUEFUNC(_wrap_OBMolAtomBFSIter_implicit_hydrogen_count), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "explicit_hydrogen_count", VALUEFUNC(_wrap_OBMolAtomBFSIter_explicit_hydrogen_count), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "member_of_ring_count", VALUEFUNC(_wrap_OBMolAtomBFSIter_member_of_ring_count), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "member_of_ring_size", VALUEFUNC(_wrap_OBMolAtomBFSIter_member_of_ring_size), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "count_ring_bonds", VALUEFUNC(_wrap_OBMolAtomBFSIter_count_ring_bonds), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "smallest_bond_angle", VALUEFUNC(_wrap_OBMolAtomBFSIter_smallest_bond_angle), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "average_bond_angle", VALUEFUNC(_wrap_OBMolAtomBFSIter_average_bond_angle), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "bosum", VALUEFUNC(_wrap_OBMolAtomBFSIter_bosum), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "kbosum", VALUEFUNC(_wrap_OBMolAtomBFSIter_kbosum), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "has_residue", VALUEFUNC(_wrap_OBMolAtomBFSIter_has_residue), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "is_hydrogen", VALUEFUNC(_wrap_OBMolAtomBFSIter_is_hydrogen), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "is_carbon", VALUEFUNC(_wrap_OBMolAtomBFSIter_is_carbon), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "is_nitrogen", VALUEFUNC(_wrap_OBMolAtomBFSIter_is_nitrogen), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "is_oxygen", VALUEFUNC(_wrap_OBMolAtomBFSIter_is_oxygen), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "is_sulfur", VALUEFUNC(_wrap_OBMolAtomBFSIter_is_sulfur), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "is_phosphorus", VALUEFUNC(_wrap_OBMolAtomBFSIter_is_phosphorus), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "is_aromatic", VALUEFUNC(_wrap_OBMolAtomBFSIter_is_aromatic), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "is_in_ring", VALUEFUNC(_wrap_OBMolAtomBFSIter_is_in_ring), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "is_in_ring_size", VALUEFUNC(_wrap_OBMolAtomBFSIter_is_in_ring_size), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "is_heteroatom", VALUEFUNC(_wrap_OBMolAtomBFSIter_is_heteroatom), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "is_not_cor_h", VALUEFUNC(_wrap_OBMolAtomBFSIter_is_not_cor_h), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "is_connected", VALUEFUNC(_wrap_OBMolAtomBFSIter_is_connected), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "is_one_three", VALUEFUNC(_wrap_OBMolAtomBFSIter_is_one_three), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "is_one_four", VALUEFUNC(_wrap_OBMolAtomBFSIter_is_one_four), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "is_carboxyl_oxygen", VALUEFUNC(_wrap_OBMolAtomBFSIter_is_carboxyl_oxygen), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "is_phosphate_oxygen", VALUEFUNC(_wrap_OBMolAtomBFSIter_is_phosphate_oxygen), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "is_sulfate_oxygen", VALUEFUNC(_wrap_OBMolAtomBFSIter_is_sulfate_oxygen), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "is_nitro_oxygen", VALUEFUNC(_wrap_OBMolAtomBFSIter_is_nitro_oxygen), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "is_amide_nitrogen", VALUEFUNC(_wrap_OBMolAtomBFSIter_is_amide_nitrogen), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "is_polar_hydrogen", VALUEFUNC(_wrap_OBMolAtomBFSIter_is_polar_hydrogen), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "is_non_polar_hydrogen", VALUEFUNC(_wrap_OBMolAtomBFSIter_is_non_polar_hydrogen), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "is_aromatic_noxide", VALUEFUNC(_wrap_OBMolAtomBFSIter_is_aromatic_noxide), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "is_chiral", VALUEFUNC(_wrap_OBMolAtomBFSIter_is_chiral), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "is_axial", VALUEFUNC(_wrap_OBMolAtomBFSIter_is_axial), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "is_clockwise", VALUEFUNC(_wrap_OBMolAtomBFSIter_is_clockwise), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "is_anti_clockwise", VALUEFUNC(_wrap_OBMolAtomBFSIter_is_anti_clockwise), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "is_positive_stereo", VALUEFUNC(_wrap_OBMolAtomBFSIter_is_positive_stereo), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "is_negative_stereo", VALUEFUNC(_wrap_OBMolAtomBFSIter_is_negative_stereo), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "has_chirality_specified", VALUEFUNC(_wrap_OBMolAtomBFSIter_has_chirality_specified), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "has_chiral_volume", VALUEFUNC(_wrap_OBMolAtomBFSIter_has_chiral_volume), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "is_hbond_acceptor", VALUEFUNC(_wrap_OBMolAtomBFSIter_is_hbond_acceptor), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "is_hbond_donor", VALUEFUNC(_wrap_OBMolAtomBFSIter_is_hbond_donor), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "is_hbond_donor_h", VALUEFUNC(_wrap_OBMolAtomBFSIter_is_hbond_donor_h), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "has_alpha_beta_unsat", VALUEFUNC(_wrap_OBMolAtomBFSIter_has_alpha_beta_unsat), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "has_bond_of_order", VALUEFUNC(_wrap_OBMolAtomBFSIter_has_bond_of_order), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "count_bonds_of_order", VALUEFUNC(_wrap_OBMolAtomBFSIter_count_bonds_of_order), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "has_non_single_bond", VALUEFUNC(_wrap_OBMolAtomBFSIter_has_non_single_bond), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "has_single_bond", VALUEFUNC(_wrap_OBMolAtomBFSIter_has_single_bond), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "has_double_bond", VALUEFUNC(_wrap_OBMolAtomBFSIter_has_double_bond), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "has_aromatic_bond", VALUEFUNC(_wrap_OBMolAtomBFSIter_has_aromatic_bond), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "matches_smarts", VALUEFUNC(_wrap_OBMolAtomBFSIter_matches_smarts), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "do_transformations", VALUEFUNC(_wrap_OBMolAtomBFSIter_do_transformations), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "class_description", VALUEFUNC(_wrap_OBMolAtomBFSIter_class_description), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "has_data", VALUEFUNC(_wrap_OBMolAtomBFSIter_has_data), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "delete_data", VALUEFUNC(_wrap_OBMolAtomBFSIter_delete_data), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "set_data", VALUEFUNC(_wrap_OBMolAtomBFSIter_set_data), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "data_size", VALUEFUNC(_wrap_OBMolAtomBFSIter_data_size), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "get_data", VALUEFUNC(_wrap_OBMolAtomBFSIter_get_data), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "begin_data", VALUEFUNC(_wrap_OBMolAtomBFSIter_begin_data), -1);
  rb_define_method(cOBMolAtomBFSIter.klass, "end_data", VALUEFUNC(_wrap_OBMolAtomBFSIter_end_data), -1);
  cOBMolAtomBFSIter.mark = 0;
  cOBMolAtomBFSIter.destroy = (void (*)(void *)) free_OpenBabel_OBMolAtomBFSIter;
  cOBMolAtomBFSIter.trackObjects = 0;
  
  cOBMolBondIter.klass = rb_define_class_under(mOpenbabel, "OBMolBondIter", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBMolBondIter, (void *) &cOBMolBondIter);
  rb_define_alloc_func(cOBMolBondIter.klass, _wrap_OBMolBondIter_allocate);
  rb_define_method(cOBMolBondIter.klass, "initialize", VALUEFUNC(_wrap_new_OBMolBondIter), -1);
  rb_define_method(cOBMolBondIter.klass, "good", VALUEFUNC(_wrap_OBMolBondIter_good), -1);
  rb_define_method(cOBMolBondIter.klass, "inc", VALUEFUNC(_wrap_OBMolBondIter_inc), -1);
  rb_define_method(cOBMolBondIter.klass, "deref", VALUEFUNC(_wrap_OBMolBondIter_deref), -1);
  rb_define_method(cOBMolBondIter.klass, "__ref__", VALUEFUNC(_wrap_OBMolBondIter___ref__), -1);
  rb_define_method(cOBMolBondIter.klass, "Visit=", VALUEFUNC(_wrap_OBMolBondIter_Visit_set), -1);
  rb_define_method(cOBMolBondIter.klass, "Visit", VALUEFUNC(_wrap_OBMolBondIter_Visit_get), -1);
  rb_define_method(cOBMolBondIter.klass, "set_idx", VALUEFUNC(_wrap_OBMolBondIter_set_idx), -1);
  rb_define_method(cOBMolBondIter.klass, "set_bo", VALUEFUNC(_wrap_OBMolBondIter_set_bo), -1);
  rb_define_method(cOBMolBondIter.klass, "set_bond_order", VALUEFUNC(_wrap_OBMolBondIter_set_bond_order), -1);
  rb_define_method(cOBMolBondIter.klass, "set_begin", VALUEFUNC(_wrap_OBMolBondIter_set_begin), -1);
  rb_define_method(cOBMolBondIter.klass, "set_end", VALUEFUNC(_wrap_OBMolBondIter_set_end), -1);
  rb_define_method(cOBMolBondIter.klass, "set_parent", VALUEFUNC(_wrap_OBMolBondIter_set_parent), -1);
  rb_define_method(cOBMolBondIter.klass, "set_length", VALUEFUNC(_wrap_OBMolBondIter_set_length), -1);
  rb_define_method(cOBMolBondIter.klass, "set", VALUEFUNC(_wrap_OBMolBondIter_set), -1);
  rb_define_method(cOBMolBondIter.klass, "set_ksingle", VALUEFUNC(_wrap_OBMolBondIter_set_ksingle), -1);
  rb_define_method(cOBMolBondIter.klass, "set_kdouble", VALUEFUNC(_wrap_OBMolBondIter_set_kdouble), -1);
  rb_define_method(cOBMolBondIter.klass, "set_ktriple", VALUEFUNC(_wrap_OBMolBondIter_set_ktriple), -1);
  rb_define_method(cOBMolBondIter.klass, "set_aromatic", VALUEFUNC(_wrap_OBMolBondIter_set_aromatic), -1);
  rb_define_method(cOBMolBondIter.klass, "set_hash", VALUEFUNC(_wrap_OBMolBondIter_set_hash), -1);
  rb_define_method(cOBMolBondIter.klass, "set_wedge", VALUEFUNC(_wrap_OBMolBondIter_set_wedge), -1);
  rb_define_method(cOBMolBondIter.klass, "set_up", VALUEFUNC(_wrap_OBMolBondIter_set_up), -1);
  rb_define_method(cOBMolBondIter.klass, "set_down", VALUEFUNC(_wrap_OBMolBondIter_set_down), -1);
  rb_define_method(cOBMolBondIter.klass, "set_in_ring", VALUEFUNC(_wrap_OBMolBondIter_set_in_ring), -1);
  rb_define_method(cOBMolBondIter.klass, "set_closure", VALUEFUNC(_wrap_OBMolBondIter_set_closure), -1);
  rb_define_method(cOBMolBondIter.klass, "unset_hash", VALUEFUNC(_wrap_OBMolBondIter_unset_hash), -1);
  rb_define_method(cOBMolBondIter.klass, "unset_wedge", VALUEFUNC(_wrap_OBMolBondIter_unset_wedge), -1);
  rb_define_method(cOBMolBondIter.klass, "unset_up", VALUEFUNC(_wrap_OBMolBondIter_unset_up), -1);
  rb_define_method(cOBMolBondIter.klass, "unset_down", VALUEFUNC(_wrap_OBMolBondIter_unset_down), -1);
  rb_define_method(cOBMolBondIter.klass, "unset_aromatic", VALUEFUNC(_wrap_OBMolBondIter_unset_aromatic), -1);
  rb_define_method(cOBMolBondIter.klass, "unset_kekule", VALUEFUNC(_wrap_OBMolBondIter_unset_kekule), -1);
  rb_define_method(cOBMolBondIter.klass, "get_idx", VALUEFUNC(_wrap_OBMolBondIter_get_idx), -1);
  rb_define_method(cOBMolBondIter.klass, "get_bo", VALUEFUNC(_wrap_OBMolBondIter_get_bo), -1);
  rb_define_method(cOBMolBondIter.klass, "get_bond_order", VALUEFUNC(_wrap_OBMolBondIter_get_bond_order), -1);
  rb_define_method(cOBMolBondIter.klass, "get_flags", VALUEFUNC(_wrap_OBMolBondIter_get_flags), -1);
  rb_define_method(cOBMolBondIter.klass, "get_begin_atom_idx", VALUEFUNC(_wrap_OBMolBondIter_get_begin_atom_idx), -1);
  rb_define_method(cOBMolBondIter.klass, "get_end_atom_idx", VALUEFUNC(_wrap_OBMolBondIter_get_end_atom_idx), -1);
  rb_define_method(cOBMolBondIter.klass, "get_begin_atom", VALUEFUNC(_wrap_OBMolBondIter_get_begin_atom), -1);
  rb_define_method(cOBMolBondIter.klass, "get_end_atom", VALUEFUNC(_wrap_OBMolBondIter_get_end_atom), -1);
  rb_define_method(cOBMolBondIter.klass, "get_nbr_atom", VALUEFUNC(_wrap_OBMolBondIter_get_nbr_atom), -1);
  rb_define_method(cOBMolBondIter.klass, "get_parent", VALUEFUNC(_wrap_OBMolBondIter_get_parent), -1);
  rb_define_method(cOBMolBondIter.klass, "get_equib_length", VALUEFUNC(_wrap_OBMolBondIter_get_equib_length), -1);
  rb_define_method(cOBMolBondIter.klass, "get_length", VALUEFUNC(_wrap_OBMolBondIter_get_length), -1);
  rb_define_method(cOBMolBondIter.klass, "get_nbr_atom_idx", VALUEFUNC(_wrap_OBMolBondIter_get_nbr_atom_idx), -1);
  rb_define_method(cOBMolBondIter.klass, "is_aromatic", VALUEFUNC(_wrap_OBMolBondIter_is_aromatic), -1);
  rb_define_method(cOBMolBondIter.klass, "is_in_ring", VALUEFUNC(_wrap_OBMolBondIter_is_in_ring), -1);
  rb_define_method(cOBMolBondIter.klass, "is_rotor", VALUEFUNC(_wrap_OBMolBondIter_is_rotor), -1);
  rb_define_method(cOBMolBondIter.klass, "is_amide", VALUEFUNC(_wrap_OBMolBondIter_is_amide), -1);
  rb_define_method(cOBMolBondIter.klass, "is_primary_amide", VALUEFUNC(_wrap_OBMolBondIter_is_primary_amide), -1);
  rb_define_method(cOBMolBondIter.klass, "is_secondary_amide", VALUEFUNC(_wrap_OBMolBondIter_is_secondary_amide), -1);
  rb_define_method(cOBMolBondIter.klass, "is_ester", VALUEFUNC(_wrap_OBMolBondIter_is_ester), -1);
  rb_define_method(cOBMolBondIter.klass, "is_carbonyl", VALUEFUNC(_wrap_OBMolBondIter_is_carbonyl), -1);
  rb_define_method(cOBMolBondIter.klass, "is_single", VALUEFUNC(_wrap_OBMolBondIter_is_single), -1);
  rb_define_method(cOBMolBondIter.klass, "is_double", VALUEFUNC(_wrap_OBMolBondIter_is_double), -1);
  rb_define_method(cOBMolBondIter.klass, "is_triple", VALUEFUNC(_wrap_OBMolBondIter_is_triple), -1);
  rb_define_method(cOBMolBondIter.klass, "is_ksingle", VALUEFUNC(_wrap_OBMolBondIter_is_ksingle), -1);
  rb_define_method(cOBMolBondIter.klass, "is_kdouble", VALUEFUNC(_wrap_OBMolBondIter_is_kdouble), -1);
  rb_define_method(cOBMolBondIter.klass, "is_ktriple", VALUEFUNC(_wrap_OBMolBondIter_is_ktriple), -1);
  rb_define_method(cOBMolBondIter.klass, "is_closure", VALUEFUNC(_wrap_OBMolBondIter_is_closure), -1);
  rb_define_method(cOBMolBondIter.klass, "is_up", VALUEFUNC(_wrap_OBMolBondIter_is_up), -1);
  rb_define_method(cOBMolBondIter.klass, "is_down", VALUEFUNC(_wrap_OBMolBondIter_is_down), -1);
  rb_define_method(cOBMolBondIter.klass, "is_wedge", VALUEFUNC(_wrap_OBMolBondIter_is_wedge), -1);
  rb_define_method(cOBMolBondIter.klass, "is_hash", VALUEFUNC(_wrap_OBMolBondIter_is_hash), -1);
  rb_define_method(cOBMolBondIter.klass, "is_double_bond_geometry", VALUEFUNC(_wrap_OBMolBondIter_is_double_bond_geometry), -1);
  rb_define_method(cOBMolBondIter.klass, "clear", VALUEFUNC(_wrap_OBMolBondIter_clear), -1);
  rb_define_method(cOBMolBondIter.klass, "do_transformations", VALUEFUNC(_wrap_OBMolBondIter_do_transformations), -1);
  rb_define_method(cOBMolBondIter.klass, "class_description", VALUEFUNC(_wrap_OBMolBondIter_class_description), -1);
  rb_define_method(cOBMolBondIter.klass, "has_data", VALUEFUNC(_wrap_OBMolBondIter_has_data), -1);
  rb_define_method(cOBMolBondIter.klass, "delete_data", VALUEFUNC(_wrap_OBMolBondIter_delete_data), -1);
  rb_define_method(cOBMolBondIter.klass, "set_data", VALUEFUNC(_wrap_OBMolBondIter_set_data), -1);
  rb_define_method(cOBMolBondIter.klass, "data_size", VALUEFUNC(_wrap_OBMolBondIter_data_size), -1);
  rb_define_method(cOBMolBondIter.klass, "get_data", VALUEFUNC(_wrap_OBMolBondIter_get_data), -1);
  rb_define_method(cOBMolBondIter.klass, "begin_data", VALUEFUNC(_wrap_OBMolBondIter_begin_data), -1);
  rb_define_method(cOBMolBondIter.klass, "end_data", VALUEFUNC(_wrap_OBMolBondIter_end_data), -1);
  cOBMolBondIter.mark = 0;
  cOBMolBondIter.destroy = (void (*)(void *)) free_OpenBabel_OBMolBondIter;
  cOBMolBondIter.trackObjects = 0;
  
  cOBAtomAtomIter.klass = rb_define_class_under(mOpenbabel, "OBAtomAtomIter", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBAtomAtomIter, (void *) &cOBAtomAtomIter);
  rb_define_alloc_func(cOBAtomAtomIter.klass, _wrap_OBAtomAtomIter_allocate);
  rb_define_method(cOBAtomAtomIter.klass, "initialize", VALUEFUNC(_wrap_new_OBAtomAtomIter), -1);
  rb_define_method(cOBAtomAtomIter.klass, "good", VALUEFUNC(_wrap_OBAtomAtomIter_good), -1);
  rb_define_method(cOBAtomAtomIter.klass, "inc", VALUEFUNC(_wrap_OBAtomAtomIter_inc), -1);
  rb_define_method(cOBAtomAtomIter.klass, "deref", VALUEFUNC(_wrap_OBAtomAtomIter_deref), -1);
  rb_define_method(cOBAtomAtomIter.klass, "__ref__", VALUEFUNC(_wrap_OBAtomAtomIter___ref__), -1);
  rb_define_method(cOBAtomAtomIter.klass, "Visit=", VALUEFUNC(_wrap_OBAtomAtomIter_Visit_set), -1);
  rb_define_method(cOBAtomAtomIter.klass, "Visit", VALUEFUNC(_wrap_OBAtomAtomIter_Visit_get), -1);
  rb_define_method(cOBAtomAtomIter.klass, "clear", VALUEFUNC(_wrap_OBAtomAtomIter_clear), -1);
  rb_define_method(cOBAtomAtomIter.klass, "set_idx", VALUEFUNC(_wrap_OBAtomAtomIter_set_idx), -1);
  rb_define_method(cOBAtomAtomIter.klass, "set_hyb", VALUEFUNC(_wrap_OBAtomAtomIter_set_hyb), -1);
  rb_define_method(cOBAtomAtomIter.klass, "set_atomic_num", VALUEFUNC(_wrap_OBAtomAtomIter_set_atomic_num), -1);
  rb_define_method(cOBAtomAtomIter.klass, "set_isotope", VALUEFUNC(_wrap_OBAtomAtomIter_set_isotope), -1);
  rb_define_method(cOBAtomAtomIter.klass, "set_implicit_valence", VALUEFUNC(_wrap_OBAtomAtomIter_set_implicit_valence), -1);
  rb_define_method(cOBAtomAtomIter.klass, "increment_implicit_valence", VALUEFUNC(_wrap_OBAtomAtomIter_increment_implicit_valence), -1);
  rb_define_method(cOBAtomAtomIter.klass, "decrement_implicit_valence", VALUEFUNC(_wrap_OBAtomAtomIter_decrement_implicit_valence), -1);
  rb_define_method(cOBAtomAtomIter.klass, "set_formal_charge", VALUEFUNC(_wrap_OBAtomAtomIter_set_formal_charge), -1);
  rb_define_method(cOBAtomAtomIter.klass, "set_spin_multiplicity", VALUEFUNC(_wrap_OBAtomAtomIter_set_spin_multiplicity), -1);
  rb_define_method(cOBAtomAtomIter.klass, "set_type", VALUEFUNC(_wrap_OBAtomAtomIter_set_type), -1);
  rb_define_method(cOBAtomAtomIter.klass, "set_partial_charge", VALUEFUNC(_wrap_OBAtomAtomIter_set_partial_charge), -1);
  rb_define_method(cOBAtomAtomIter.klass, "set_vector", VALUEFUNC(_wrap_OBAtomAtomIter_set_vector), -1);
  rb_define_method(cOBAtomAtomIter.klass, "set_coord_ptr", VALUEFUNC(_wrap_OBAtomAtomIter_set_coord_ptr), -1);
  rb_define_method(cOBAtomAtomIter.klass, "set_residue", VALUEFUNC(_wrap_OBAtomAtomIter_set_residue), -1);
  rb_define_method(cOBAtomAtomIter.klass, "set_parent", VALUEFUNC(_wrap_OBAtomAtomIter_set_parent), -1);
  rb_define_method(cOBAtomAtomIter.klass, "set_aromatic", VALUEFUNC(_wrap_OBAtomAtomIter_set_aromatic), -1);
  rb_define_method(cOBAtomAtomIter.klass, "unset_aromatic", VALUEFUNC(_wrap_OBAtomAtomIter_unset_aromatic), -1);
  rb_define_method(cOBAtomAtomIter.klass, "set_clockwise_stereo", VALUEFUNC(_wrap_OBAtomAtomIter_set_clockwise_stereo), -1);
  rb_define_method(cOBAtomAtomIter.klass, "set_anti_clockwise_stereo", VALUEFUNC(_wrap_OBAtomAtomIter_set_anti_clockwise_stereo), -1);
  rb_define_method(cOBAtomAtomIter.klass, "set_positive_stereo", VALUEFUNC(_wrap_OBAtomAtomIter_set_positive_stereo), -1);
  rb_define_method(cOBAtomAtomIter.klass, "set_negative_stereo", VALUEFUNC(_wrap_OBAtomAtomIter_set_negative_stereo), -1);
  rb_define_method(cOBAtomAtomIter.klass, "unset_stereo", VALUEFUNC(_wrap_OBAtomAtomIter_unset_stereo), -1);
  rb_define_method(cOBAtomAtomIter.klass, "set_in_ring", VALUEFUNC(_wrap_OBAtomAtomIter_set_in_ring), -1);
  rb_define_method(cOBAtomAtomIter.klass, "set_chiral", VALUEFUNC(_wrap_OBAtomAtomIter_set_chiral), -1);
  rb_define_method(cOBAtomAtomIter.klass, "clear_coord_ptr", VALUEFUNC(_wrap_OBAtomAtomIter_clear_coord_ptr), -1);
  rb_define_method(cOBAtomAtomIter.klass, "get_formal_charge", VALUEFUNC(_wrap_OBAtomAtomIter_get_formal_charge), -1);
  rb_define_method(cOBAtomAtomIter.klass, "get_atomic_num", VALUEFUNC(_wrap_OBAtomAtomIter_get_atomic_num), -1);
  rb_define_method(cOBAtomAtomIter.klass, "get_isotope", VALUEFUNC(_wrap_OBAtomAtomIter_get_isotope), -1);
  rb_define_method(cOBAtomAtomIter.klass, "get_spin_multiplicity", VALUEFUNC(_wrap_OBAtomAtomIter_get_spin_multiplicity), -1);
  rb_define_method(cOBAtomAtomIter.klass, "get_atomic_mass", VALUEFUNC(_wrap_OBAtomAtomIter_get_atomic_mass), -1);
  rb_define_method(cOBAtomAtomIter.klass, "get_exact_mass", VALUEFUNC(_wrap_OBAtomAtomIter_get_exact_mass), -1);
  rb_define_method(cOBAtomAtomIter.klass, "get_idx", VALUEFUNC(_wrap_OBAtomAtomIter_get_idx), -1);
  rb_define_method(cOBAtomAtomIter.klass, "get_coordinate_idx", VALUEFUNC(_wrap_OBAtomAtomIter_get_coordinate_idx), -1);
  rb_define_method(cOBAtomAtomIter.klass, "get_cidx", VALUEFUNC(_wrap_OBAtomAtomIter_get_cidx), -1);
  rb_define_method(cOBAtomAtomIter.klass, "get_valence", VALUEFUNC(_wrap_OBAtomAtomIter_get_valence), -1);
  rb_define_method(cOBAtomAtomIter.klass, "get_hyb", VALUEFUNC(_wrap_OBAtomAtomIter_get_hyb), -1);
  rb_define_method(cOBAtomAtomIter.klass, "get_implicit_valence", VALUEFUNC(_wrap_OBAtomAtomIter_get_implicit_valence), -1);
  rb_define_method(cOBAtomAtomIter.klass, "get_hvy_valence", VALUEFUNC(_wrap_OBAtomAtomIter_get_hvy_valence), -1);
  rb_define_method(cOBAtomAtomIter.klass, "get_hetero_valence", VALUEFUNC(_wrap_OBAtomAtomIter_get_hetero_valence), -1);
  rb_define_method(cOBAtomAtomIter.klass, "get_type", VALUEFUNC(_wrap_OBAtomAtomIter_get_type), -1);
  rb_define_method(cOBAtomAtomIter.klass, "get_x", VALUEFUNC(_wrap_OBAtomAtomIter_get_x), -1);
  rb_define_method(cOBAtomAtomIter.klass, "get_y", VALUEFUNC(_wrap_OBAtomAtomIter_get_y), -1);
  rb_define_method(cOBAtomAtomIter.klass, "get_z", VALUEFUNC(_wrap_OBAtomAtomIter_get_z), -1);
  rb_define_method(cOBAtomAtomIter.klass, "x", VALUEFUNC(_wrap_OBAtomAtomIter_x), -1);
  rb_define_method(cOBAtomAtomIter.klass, "y", VALUEFUNC(_wrap_OBAtomAtomIter_y), -1);
  rb_define_method(cOBAtomAtomIter.klass, "z", VALUEFUNC(_wrap_OBAtomAtomIter_z), -1);
  rb_define_method(cOBAtomAtomIter.klass, "get_coordinate", VALUEFUNC(_wrap_OBAtomAtomIter_get_coordinate), -1);
  rb_define_method(cOBAtomAtomIter.klass, "get_vector", VALUEFUNC(_wrap_OBAtomAtomIter_get_vector), -1);
  rb_define_method(cOBAtomAtomIter.klass, "get_partial_charge", VALUEFUNC(_wrap_OBAtomAtomIter_get_partial_charge), -1);
  rb_define_method(cOBAtomAtomIter.klass, "get_residue", VALUEFUNC(_wrap_OBAtomAtomIter_get_residue), -1);
  rb_define_method(cOBAtomAtomIter.klass, "get_parent", VALUEFUNC(_wrap_OBAtomAtomIter_get_parent), -1);
  rb_define_method(cOBAtomAtomIter.klass, "get_new_bond_vector", VALUEFUNC(_wrap_OBAtomAtomIter_get_new_bond_vector), -1);
  rb_define_method(cOBAtomAtomIter.klass, "get_bond", VALUEFUNC(_wrap_OBAtomAtomIter_get_bond), -1);
  rb_define_method(cOBAtomAtomIter.klass, "get_next_atom", VALUEFUNC(_wrap_OBAtomAtomIter_get_next_atom), -1);
  rb_define_method(cOBAtomAtomIter.klass, "begin_bonds", VALUEFUNC(_wrap_OBAtomAtomIter_begin_bonds), -1);
  rb_define_method(cOBAtomAtomIter.klass, "end_bonds", VALUEFUNC(_wrap_OBAtomAtomIter_end_bonds), -1);
  rb_define_method(cOBAtomAtomIter.klass, "begin_bond", VALUEFUNC(_wrap_OBAtomAtomIter_begin_bond), -1);
  rb_define_method(cOBAtomAtomIter.klass, "next_bond", VALUEFUNC(_wrap_OBAtomAtomIter_next_bond), -1);
  rb_define_method(cOBAtomAtomIter.klass, "begin_nbr_atom", VALUEFUNC(_wrap_OBAtomAtomIter_begin_nbr_atom), -1);
  rb_define_method(cOBAtomAtomIter.klass, "next_nbr_atom", VALUEFUNC(_wrap_OBAtomAtomIter_next_nbr_atom), -1);
  rb_define_method(cOBAtomAtomIter.klass, "get_distance", VALUEFUNC(_wrap_OBAtomAtomIter_get_distance), -1);
  rb_define_method(cOBAtomAtomIter.klass, "get_angle", VALUEFUNC(_wrap_OBAtomAtomIter_get_angle), -1);
  rb_define_method(cOBAtomAtomIter.klass, "new_residue", VALUEFUNC(_wrap_OBAtomAtomIter_new_residue), -1);
  rb_define_method(cOBAtomAtomIter.klass, "add_residue", VALUEFUNC(_wrap_OBAtomAtomIter_add_residue), -1);
  rb_define_method(cOBAtomAtomIter.klass, "delete_residue", VALUEFUNC(_wrap_OBAtomAtomIter_delete_residue), -1);
  rb_define_method(cOBAtomAtomIter.klass, "add_bond", VALUEFUNC(_wrap_OBAtomAtomIter_add_bond), -1);
  rb_define_method(cOBAtomAtomIter.klass, "insert_bond", VALUEFUNC(_wrap_OBAtomAtomIter_insert_bond), -1);
  rb_define_method(cOBAtomAtomIter.klass, "delete_bond", VALUEFUNC(_wrap_OBAtomAtomIter_delete_bond), -1);
  rb_define_method(cOBAtomAtomIter.klass, "clear_bond", VALUEFUNC(_wrap_OBAtomAtomIter_clear_bond), -1);
  rb_define_method(cOBAtomAtomIter.klass, "hto_methyl", VALUEFUNC(_wrap_OBAtomAtomIter_hto_methyl), -1);
  rb_define_method(cOBAtomAtomIter.klass, "set_hyb_and_geom", VALUEFUNC(_wrap_OBAtomAtomIter_set_hyb_and_geom), -1);
  rb_define_method(cOBAtomAtomIter.klass, "force_no_h", VALUEFUNC(_wrap_OBAtomAtomIter_force_no_h), -1);
  rb_define_method(cOBAtomAtomIter.klass, "has_no_hforced", VALUEFUNC(_wrap_OBAtomAtomIter_has_no_hforced), -1);
  rb_define_method(cOBAtomAtomIter.klass, "count_free_oxygens", VALUEFUNC(_wrap_OBAtomAtomIter_count_free_oxygens), -1);
  rb_define_method(cOBAtomAtomIter.klass, "implicit_hydrogen_count", VALUEFUNC(_wrap_OBAtomAtomIter_implicit_hydrogen_count), -1);
  rb_define_method(cOBAtomAtomIter.klass, "explicit_hydrogen_count", VALUEFUNC(_wrap_OBAtomAtomIter_explicit_hydrogen_count), -1);
  rb_define_method(cOBAtomAtomIter.klass, "member_of_ring_count", VALUEFUNC(_wrap_OBAtomAtomIter_member_of_ring_count), -1);
  rb_define_method(cOBAtomAtomIter.klass, "member_of_ring_size", VALUEFUNC(_wrap_OBAtomAtomIter_member_of_ring_size), -1);
  rb_define_method(cOBAtomAtomIter.klass, "count_ring_bonds", VALUEFUNC(_wrap_OBAtomAtomIter_count_ring_bonds), -1);
  rb_define_method(cOBAtomAtomIter.klass, "smallest_bond_angle", VALUEFUNC(_wrap_OBAtomAtomIter_smallest_bond_angle), -1);
  rb_define_method(cOBAtomAtomIter.klass, "average_bond_angle", VALUEFUNC(_wrap_OBAtomAtomIter_average_bond_angle), -1);
  rb_define_method(cOBAtomAtomIter.klass, "bosum", VALUEFUNC(_wrap_OBAtomAtomIter_bosum), -1);
  rb_define_method(cOBAtomAtomIter.klass, "kbosum", VALUEFUNC(_wrap_OBAtomAtomIter_kbosum), -1);
  rb_define_method(cOBAtomAtomIter.klass, "has_residue", VALUEFUNC(_wrap_OBAtomAtomIter_has_residue), -1);
  rb_define_method(cOBAtomAtomIter.klass, "is_hydrogen", VALUEFUNC(_wrap_OBAtomAtomIter_is_hydrogen), -1);
  rb_define_method(cOBAtomAtomIter.klass, "is_carbon", VALUEFUNC(_wrap_OBAtomAtomIter_is_carbon), -1);
  rb_define_method(cOBAtomAtomIter.klass, "is_nitrogen", VALUEFUNC(_wrap_OBAtomAtomIter_is_nitrogen), -1);
  rb_define_method(cOBAtomAtomIter.klass, "is_oxygen", VALUEFUNC(_wrap_OBAtomAtomIter_is_oxygen), -1);
  rb_define_method(cOBAtomAtomIter.klass, "is_sulfur", VALUEFUNC(_wrap_OBAtomAtomIter_is_sulfur), -1);
  rb_define_method(cOBAtomAtomIter.klass, "is_phosphorus", VALUEFUNC(_wrap_OBAtomAtomIter_is_phosphorus), -1);
  rb_define_method(cOBAtomAtomIter.klass, "is_aromatic", VALUEFUNC(_wrap_OBAtomAtomIter_is_aromatic), -1);
  rb_define_method(cOBAtomAtomIter.klass, "is_in_ring", VALUEFUNC(_wrap_OBAtomAtomIter_is_in_ring), -1);
  rb_define_method(cOBAtomAtomIter.klass, "is_in_ring_size", VALUEFUNC(_wrap_OBAtomAtomIter_is_in_ring_size), -1);
  rb_define_method(cOBAtomAtomIter.klass, "is_heteroatom", VALUEFUNC(_wrap_OBAtomAtomIter_is_heteroatom), -1);
  rb_define_method(cOBAtomAtomIter.klass, "is_not_cor_h", VALUEFUNC(_wrap_OBAtomAtomIter_is_not_cor_h), -1);
  rb_define_method(cOBAtomAtomIter.klass, "is_connected", VALUEFUNC(_wrap_OBAtomAtomIter_is_connected), -1);
  rb_define_method(cOBAtomAtomIter.klass, "is_one_three", VALUEFUNC(_wrap_OBAtomAtomIter_is_one_three), -1);
  rb_define_method(cOBAtomAtomIter.klass, "is_one_four", VALUEFUNC(_wrap_OBAtomAtomIter_is_one_four), -1);
  rb_define_method(cOBAtomAtomIter.klass, "is_carboxyl_oxygen", VALUEFUNC(_wrap_OBAtomAtomIter_is_carboxyl_oxygen), -1);
  rb_define_method(cOBAtomAtomIter.klass, "is_phosphate_oxygen", VALUEFUNC(_wrap_OBAtomAtomIter_is_phosphate_oxygen), -1);
  rb_define_method(cOBAtomAtomIter.klass, "is_sulfate_oxygen", VALUEFUNC(_wrap_OBAtomAtomIter_is_sulfate_oxygen), -1);
  rb_define_method(cOBAtomAtomIter.klass, "is_nitro_oxygen", VALUEFUNC(_wrap_OBAtomAtomIter_is_nitro_oxygen), -1);
  rb_define_method(cOBAtomAtomIter.klass, "is_amide_nitrogen", VALUEFUNC(_wrap_OBAtomAtomIter_is_amide_nitrogen), -1);
  rb_define_method(cOBAtomAtomIter.klass, "is_polar_hydrogen", VALUEFUNC(_wrap_OBAtomAtomIter_is_polar_hydrogen), -1);
  rb_define_method(cOBAtomAtomIter.klass, "is_non_polar_hydrogen", VALUEFUNC(_wrap_OBAtomAtomIter_is_non_polar_hydrogen), -1);
  rb_define_method(cOBAtomAtomIter.klass, "is_aromatic_noxide", VALUEFUNC(_wrap_OBAtomAtomIter_is_aromatic_noxide), -1);
  rb_define_method(cOBAtomAtomIter.klass, "is_chiral", VALUEFUNC(_wrap_OBAtomAtomIter_is_chiral), -1);
  rb_define_method(cOBAtomAtomIter.klass, "is_axial", VALUEFUNC(_wrap_OBAtomAtomIter_is_axial), -1);
  rb_define_method(cOBAtomAtomIter.klass, "is_clockwise", VALUEFUNC(_wrap_OBAtomAtomIter_is_clockwise), -1);
  rb_define_method(cOBAtomAtomIter.klass, "is_anti_clockwise", VALUEFUNC(_wrap_OBAtomAtomIter_is_anti_clockwise), -1);
  rb_define_method(cOBAtomAtomIter.klass, "is_positive_stereo", VALUEFUNC(_wrap_OBAtomAtomIter_is_positive_stereo), -1);
  rb_define_method(cOBAtomAtomIter.klass, "is_negative_stereo", VALUEFUNC(_wrap_OBAtomAtomIter_is_negative_stereo), -1);
  rb_define_method(cOBAtomAtomIter.klass, "has_chirality_specified", VALUEFUNC(_wrap_OBAtomAtomIter_has_chirality_specified), -1);
  rb_define_method(cOBAtomAtomIter.klass, "has_chiral_volume", VALUEFUNC(_wrap_OBAtomAtomIter_has_chiral_volume), -1);
  rb_define_method(cOBAtomAtomIter.klass, "is_hbond_acceptor", VALUEFUNC(_wrap_OBAtomAtomIter_is_hbond_acceptor), -1);
  rb_define_method(cOBAtomAtomIter.klass, "is_hbond_donor", VALUEFUNC(_wrap_OBAtomAtomIter_is_hbond_donor), -1);
  rb_define_method(cOBAtomAtomIter.klass, "is_hbond_donor_h", VALUEFUNC(_wrap_OBAtomAtomIter_is_hbond_donor_h), -1);
  rb_define_method(cOBAtomAtomIter.klass, "has_alpha_beta_unsat", VALUEFUNC(_wrap_OBAtomAtomIter_has_alpha_beta_unsat), -1);
  rb_define_method(cOBAtomAtomIter.klass, "has_bond_of_order", VALUEFUNC(_wrap_OBAtomAtomIter_has_bond_of_order), -1);
  rb_define_method(cOBAtomAtomIter.klass, "count_bonds_of_order", VALUEFUNC(_wrap_OBAtomAtomIter_count_bonds_of_order), -1);
  rb_define_method(cOBAtomAtomIter.klass, "has_non_single_bond", VALUEFUNC(_wrap_OBAtomAtomIter_has_non_single_bond), -1);
  rb_define_method(cOBAtomAtomIter.klass, "has_single_bond", VALUEFUNC(_wrap_OBAtomAtomIter_has_single_bond), -1);
  rb_define_method(cOBAtomAtomIter.klass, "has_double_bond", VALUEFUNC(_wrap_OBAtomAtomIter_has_double_bond), -1);
  rb_define_method(cOBAtomAtomIter.klass, "has_aromatic_bond", VALUEFUNC(_wrap_OBAtomAtomIter_has_aromatic_bond), -1);
  rb_define_method(cOBAtomAtomIter.klass, "matches_smarts", VALUEFUNC(_wrap_OBAtomAtomIter_matches_smarts), -1);
  rb_define_method(cOBAtomAtomIter.klass, "do_transformations", VALUEFUNC(_wrap_OBAtomAtomIter_do_transformations), -1);
  rb_define_method(cOBAtomAtomIter.klass, "class_description", VALUEFUNC(_wrap_OBAtomAtomIter_class_description), -1);
  rb_define_method(cOBAtomAtomIter.klass, "has_data", VALUEFUNC(_wrap_OBAtomAtomIter_has_data), -1);
  rb_define_method(cOBAtomAtomIter.klass, "delete_data", VALUEFUNC(_wrap_OBAtomAtomIter_delete_data), -1);
  rb_define_method(cOBAtomAtomIter.klass, "set_data", VALUEFUNC(_wrap_OBAtomAtomIter_set_data), -1);
  rb_define_method(cOBAtomAtomIter.klass, "data_size", VALUEFUNC(_wrap_OBAtomAtomIter_data_size), -1);
  rb_define_method(cOBAtomAtomIter.klass, "get_data", VALUEFUNC(_wrap_OBAtomAtomIter_get_data), -1);
  rb_define_method(cOBAtomAtomIter.klass, "begin_data", VALUEFUNC(_wrap_OBAtomAtomIter_begin_data), -1);
  rb_define_method(cOBAtomAtomIter.klass, "end_data", VALUEFUNC(_wrap_OBAtomAtomIter_end_data), -1);
  cOBAtomAtomIter.mark = 0;
  cOBAtomAtomIter.destroy = (void (*)(void *)) free_OpenBabel_OBAtomAtomIter;
  cOBAtomAtomIter.trackObjects = 0;
  
  cOBAtomBondIter.klass = rb_define_class_under(mOpenbabel, "OBAtomBondIter", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBAtomBondIter, (void *) &cOBAtomBondIter);
  rb_define_alloc_func(cOBAtomBondIter.klass, _wrap_OBAtomBondIter_allocate);
  rb_define_method(cOBAtomBondIter.klass, "initialize", VALUEFUNC(_wrap_new_OBAtomBondIter), -1);
  rb_define_method(cOBAtomBondIter.klass, "good", VALUEFUNC(_wrap_OBAtomBondIter_good), -1);
  rb_define_method(cOBAtomBondIter.klass, "inc", VALUEFUNC(_wrap_OBAtomBondIter_inc), -1);
  rb_define_method(cOBAtomBondIter.klass, "deref", VALUEFUNC(_wrap_OBAtomBondIter_deref), -1);
  rb_define_method(cOBAtomBondIter.klass, "__ref__", VALUEFUNC(_wrap_OBAtomBondIter___ref__), -1);
  rb_define_method(cOBAtomBondIter.klass, "Visit=", VALUEFUNC(_wrap_OBAtomBondIter_Visit_set), -1);
  rb_define_method(cOBAtomBondIter.klass, "Visit", VALUEFUNC(_wrap_OBAtomBondIter_Visit_get), -1);
  rb_define_method(cOBAtomBondIter.klass, "set_idx", VALUEFUNC(_wrap_OBAtomBondIter_set_idx), -1);
  rb_define_method(cOBAtomBondIter.klass, "set_bo", VALUEFUNC(_wrap_OBAtomBondIter_set_bo), -1);
  rb_define_method(cOBAtomBondIter.klass, "set_bond_order", VALUEFUNC(_wrap_OBAtomBondIter_set_bond_order), -1);
  rb_define_method(cOBAtomBondIter.klass, "set_begin", VALUEFUNC(_wrap_OBAtomBondIter_set_begin), -1);
  rb_define_method(cOBAtomBondIter.klass, "set_end", VALUEFUNC(_wrap_OBAtomBondIter_set_end), -1);
  rb_define_method(cOBAtomBondIter.klass, "set_parent", VALUEFUNC(_wrap_OBAtomBondIter_set_parent), -1);
  rb_define_method(cOBAtomBondIter.klass, "set_length", VALUEFUNC(_wrap_OBAtomBondIter_set_length), -1);
  rb_define_method(cOBAtomBondIter.klass, "set", VALUEFUNC(_wrap_OBAtomBondIter_set), -1);
  rb_define_method(cOBAtomBondIter.klass, "set_ksingle", VALUEFUNC(_wrap_OBAtomBondIter_set_ksingle), -1);
  rb_define_method(cOBAtomBondIter.klass, "set_kdouble", VALUEFUNC(_wrap_OBAtomBondIter_set_kdouble), -1);
  rb_define_method(cOBAtomBondIter.klass, "set_ktriple", VALUEFUNC(_wrap_OBAtomBondIter_set_ktriple), -1);
  rb_define_method(cOBAtomBondIter.klass, "set_aromatic", VALUEFUNC(_wrap_OBAtomBondIter_set_aromatic), -1);
  rb_define_method(cOBAtomBondIter.klass, "set_hash", VALUEFUNC(_wrap_OBAtomBondIter_set_hash), -1);
  rb_define_method(cOBAtomBondIter.klass, "set_wedge", VALUEFUNC(_wrap_OBAtomBondIter_set_wedge), -1);
  rb_define_method(cOBAtomBondIter.klass, "set_up", VALUEFUNC(_wrap_OBAtomBondIter_set_up), -1);
  rb_define_method(cOBAtomBondIter.klass, "set_down", VALUEFUNC(_wrap_OBAtomBondIter_set_down), -1);
  rb_define_method(cOBAtomBondIter.klass, "set_in_ring", VALUEFUNC(_wrap_OBAtomBondIter_set_in_ring), -1);
  rb_define_method(cOBAtomBondIter.klass, "set_closure", VALUEFUNC(_wrap_OBAtomBondIter_set_closure), -1);
  rb_define_method(cOBAtomBondIter.klass, "unset_hash", VALUEFUNC(_wrap_OBAtomBondIter_unset_hash), -1);
  rb_define_method(cOBAtomBondIter.klass, "unset_wedge", VALUEFUNC(_wrap_OBAtomBondIter_unset_wedge), -1);
  rb_define_method(cOBAtomBondIter.klass, "unset_up", VALUEFUNC(_wrap_OBAtomBondIter_unset_up), -1);
  rb_define_method(cOBAtomBondIter.klass, "unset_down", VALUEFUNC(_wrap_OBAtomBondIter_unset_down), -1);
  rb_define_method(cOBAtomBondIter.klass, "unset_aromatic", VALUEFUNC(_wrap_OBAtomBondIter_unset_aromatic), -1);
  rb_define_method(cOBAtomBondIter.klass, "unset_kekule", VALUEFUNC(_wrap_OBAtomBondIter_unset_kekule), -1);
  rb_define_method(cOBAtomBondIter.klass, "get_idx", VALUEFUNC(_wrap_OBAtomBondIter_get_idx), -1);
  rb_define_method(cOBAtomBondIter.klass, "get_bo", VALUEFUNC(_wrap_OBAtomBondIter_get_bo), -1);
  rb_define_method(cOBAtomBondIter.klass, "get_bond_order", VALUEFUNC(_wrap_OBAtomBondIter_get_bond_order), -1);
  rb_define_method(cOBAtomBondIter.klass, "get_flags", VALUEFUNC(_wrap_OBAtomBondIter_get_flags), -1);
  rb_define_method(cOBAtomBondIter.klass, "get_begin_atom_idx", VALUEFUNC(_wrap_OBAtomBondIter_get_begin_atom_idx), -1);
  rb_define_method(cOBAtomBondIter.klass, "get_end_atom_idx", VALUEFUNC(_wrap_OBAtomBondIter_get_end_atom_idx), -1);
  rb_define_method(cOBAtomBondIter.klass, "get_begin_atom", VALUEFUNC(_wrap_OBAtomBondIter_get_begin_atom), -1);
  rb_define_method(cOBAtomBondIter.klass, "get_end_atom", VALUEFUNC(_wrap_OBAtomBondIter_get_end_atom), -1);
  rb_define_method(cOBAtomBondIter.klass, "get_nbr_atom", VALUEFUNC(_wrap_OBAtomBondIter_get_nbr_atom), -1);
  rb_define_method(cOBAtomBondIter.klass, "get_parent", VALUEFUNC(_wrap_OBAtomBondIter_get_parent), -1);
  rb_define_method(cOBAtomBondIter.klass, "get_equib_length", VALUEFUNC(_wrap_OBAtomBondIter_get_equib_length), -1);
  rb_define_method(cOBAtomBondIter.klass, "get_length", VALUEFUNC(_wrap_OBAtomBondIter_get_length), -1);
  rb_define_method(cOBAtomBondIter.klass, "get_nbr_atom_idx", VALUEFUNC(_wrap_OBAtomBondIter_get_nbr_atom_idx), -1);
  rb_define_method(cOBAtomBondIter.klass, "is_aromatic", VALUEFUNC(_wrap_OBAtomBondIter_is_aromatic), -1);
  rb_define_method(cOBAtomBondIter.klass, "is_in_ring", VALUEFUNC(_wrap_OBAtomBondIter_is_in_ring), -1);
  rb_define_method(cOBAtomBondIter.klass, "is_rotor", VALUEFUNC(_wrap_OBAtomBondIter_is_rotor), -1);
  rb_define_method(cOBAtomBondIter.klass, "is_amide", VALUEFUNC(_wrap_OBAtomBondIter_is_amide), -1);
  rb_define_method(cOBAtomBondIter.klass, "is_primary_amide", VALUEFUNC(_wrap_OBAtomBondIter_is_primary_amide), -1);
  rb_define_method(cOBAtomBondIter.klass, "is_secondary_amide", VALUEFUNC(_wrap_OBAtomBondIter_is_secondary_amide), -1);
  rb_define_method(cOBAtomBondIter.klass, "is_ester", VALUEFUNC(_wrap_OBAtomBondIter_is_ester), -1);
  rb_define_method(cOBAtomBondIter.klass, "is_carbonyl", VALUEFUNC(_wrap_OBAtomBondIter_is_carbonyl), -1);
  rb_define_method(cOBAtomBondIter.klass, "is_single", VALUEFUNC(_wrap_OBAtomBondIter_is_single), -1);
  rb_define_method(cOBAtomBondIter.klass, "is_double", VALUEFUNC(_wrap_OBAtomBondIter_is_double), -1);
  rb_define_method(cOBAtomBondIter.klass, "is_triple", VALUEFUNC(_wrap_OBAtomBondIter_is_triple), -1);
  rb_define_method(cOBAtomBondIter.klass, "is_ksingle", VALUEFUNC(_wrap_OBAtomBondIter_is_ksingle), -1);
  rb_define_method(cOBAtomBondIter.klass, "is_kdouble", VALUEFUNC(_wrap_OBAtomBondIter_is_kdouble), -1);
  rb_define_method(cOBAtomBondIter.klass, "is_ktriple", VALUEFUNC(_wrap_OBAtomBondIter_is_ktriple), -1);
  rb_define_method(cOBAtomBondIter.klass, "is_closure", VALUEFUNC(_wrap_OBAtomBondIter_is_closure), -1);
  rb_define_method(cOBAtomBondIter.klass, "is_up", VALUEFUNC(_wrap_OBAtomBondIter_is_up), -1);
  rb_define_method(cOBAtomBondIter.klass, "is_down", VALUEFUNC(_wrap_OBAtomBondIter_is_down), -1);
  rb_define_method(cOBAtomBondIter.klass, "is_wedge", VALUEFUNC(_wrap_OBAtomBondIter_is_wedge), -1);
  rb_define_method(cOBAtomBondIter.klass, "is_hash", VALUEFUNC(_wrap_OBAtomBondIter_is_hash), -1);
  rb_define_method(cOBAtomBondIter.klass, "is_double_bond_geometry", VALUEFUNC(_wrap_OBAtomBondIter_is_double_bond_geometry), -1);
  rb_define_method(cOBAtomBondIter.klass, "clear", VALUEFUNC(_wrap_OBAtomBondIter_clear), -1);
  rb_define_method(cOBAtomBondIter.klass, "do_transformations", VALUEFUNC(_wrap_OBAtomBondIter_do_transformations), -1);
  rb_define_method(cOBAtomBondIter.klass, "class_description", VALUEFUNC(_wrap_OBAtomBondIter_class_description), -1);
  rb_define_method(cOBAtomBondIter.klass, "has_data", VALUEFUNC(_wrap_OBAtomBondIter_has_data), -1);
  rb_define_method(cOBAtomBondIter.klass, "delete_data", VALUEFUNC(_wrap_OBAtomBondIter_delete_data), -1);
  rb_define_method(cOBAtomBondIter.klass, "set_data", VALUEFUNC(_wrap_OBAtomBondIter_set_data), -1);
  rb_define_method(cOBAtomBondIter.klass, "data_size", VALUEFUNC(_wrap_OBAtomBondIter_data_size), -1);
  rb_define_method(cOBAtomBondIter.klass, "get_data", VALUEFUNC(_wrap_OBAtomBondIter_get_data), -1);
  rb_define_method(cOBAtomBondIter.klass, "begin_data", VALUEFUNC(_wrap_OBAtomBondIter_begin_data), -1);
  rb_define_method(cOBAtomBondIter.klass, "end_data", VALUEFUNC(_wrap_OBAtomBondIter_end_data), -1);
  cOBAtomBondIter.mark = 0;
  cOBAtomBondIter.destroy = (void (*)(void *)) free_OpenBabel_OBAtomBondIter;
  cOBAtomBondIter.trackObjects = 0;
  
  cOBResidueIter.klass = rb_define_class_under(mOpenbabel, "OBResidueIter", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBResidueIter, (void *) &cOBResidueIter);
  rb_define_alloc_func(cOBResidueIter.klass, _wrap_OBResidueIter_allocate);
  rb_define_method(cOBResidueIter.klass, "initialize", VALUEFUNC(_wrap_new_OBResidueIter), -1);
  rb_define_method(cOBResidueIter.klass, "good", VALUEFUNC(_wrap_OBResidueIter_good), -1);
  rb_define_method(cOBResidueIter.klass, "inc", VALUEFUNC(_wrap_OBResidueIter_inc), -1);
  rb_define_method(cOBResidueIter.klass, "deref", VALUEFUNC(_wrap_OBResidueIter_deref), -1);
  rb_define_method(cOBResidueIter.klass, "__ref__", VALUEFUNC(_wrap_OBResidueIter___ref__), -1);
  rb_define_method(cOBResidueIter.klass, "add_atom", VALUEFUNC(_wrap_OBResidueIter_add_atom), -1);
  rb_define_method(cOBResidueIter.klass, "insert_atom", VALUEFUNC(_wrap_OBResidueIter_insert_atom), -1);
  rb_define_method(cOBResidueIter.klass, "remove_atom", VALUEFUNC(_wrap_OBResidueIter_remove_atom), -1);
  rb_define_method(cOBResidueIter.klass, "clear", VALUEFUNC(_wrap_OBResidueIter_clear), -1);
  rb_define_method(cOBResidueIter.klass, "set_name", VALUEFUNC(_wrap_OBResidueIter_set_name), -1);
  rb_define_method(cOBResidueIter.klass, "set_num", VALUEFUNC(_wrap_OBResidueIter_set_num), -1);
  rb_define_method(cOBResidueIter.klass, "set_chain", VALUEFUNC(_wrap_OBResidueIter_set_chain), -1);
  rb_define_method(cOBResidueIter.klass, "set_chain_num", VALUEFUNC(_wrap_OBResidueIter_set_chain_num), -1);
  rb_define_method(cOBResidueIter.klass, "set_idx", VALUEFUNC(_wrap_OBResidueIter_set_idx), -1);
  rb_define_method(cOBResidueIter.klass, "set_atom_id", VALUEFUNC(_wrap_OBResidueIter_set_atom_id), -1);
  rb_define_method(cOBResidueIter.klass, "set_het_atom", VALUEFUNC(_wrap_OBResidueIter_set_het_atom), -1);
  rb_define_method(cOBResidueIter.klass, "set_serial_num", VALUEFUNC(_wrap_OBResidueIter_set_serial_num), -1);
  rb_define_method(cOBResidueIter.klass, "get_name", VALUEFUNC(_wrap_OBResidueIter_get_name), -1);
  rb_define_method(cOBResidueIter.klass, "get_num", VALUEFUNC(_wrap_OBResidueIter_get_num), -1);
  rb_define_method(cOBResidueIter.klass, "get_num_atoms", VALUEFUNC(_wrap_OBResidueIter_get_num_atoms), -1);
  rb_define_method(cOBResidueIter.klass, "get_chain", VALUEFUNC(_wrap_OBResidueIter_get_chain), -1);
  rb_define_method(cOBResidueIter.klass, "get_chain_num", VALUEFUNC(_wrap_OBResidueIter_get_chain_num), -1);
  rb_define_method(cOBResidueIter.klass, "get_idx", VALUEFUNC(_wrap_OBResidueIter_get_idx), -1);
  rb_define_method(cOBResidueIter.klass, "get_res_key", VALUEFUNC(_wrap_OBResidueIter_get_res_key), -1);
  rb_define_method(cOBResidueIter.klass, "get_atoms", VALUEFUNC(_wrap_OBResidueIter_get_atoms), -1);
  rb_define_method(cOBResidueIter.klass, "get_bonds", VALUEFUNC(_wrap_OBResidueIter_get_bonds), -1);
  rb_define_method(cOBResidueIter.klass, "get_atom_id", VALUEFUNC(_wrap_OBResidueIter_get_atom_id), -1);
  rb_define_method(cOBResidueIter.klass, "get_serial_num", VALUEFUNC(_wrap_OBResidueIter_get_serial_num), -1);
  rb_define_method(cOBResidueIter.klass, "get_amino_acid_property", VALUEFUNC(_wrap_OBResidueIter_get_amino_acid_property), -1);
  rb_define_method(cOBResidueIter.klass, "get_atom_property", VALUEFUNC(_wrap_OBResidueIter_get_atom_property), -1);
  rb_define_method(cOBResidueIter.klass, "get_residue_property", VALUEFUNC(_wrap_OBResidueIter_get_residue_property), -1);
  rb_define_method(cOBResidueIter.klass, "is_het_atom", VALUEFUNC(_wrap_OBResidueIter_is_het_atom), -1);
  rb_define_method(cOBResidueIter.klass, "is_residue_type", VALUEFUNC(_wrap_OBResidueIter_is_residue_type), -1);
  rb_define_method(cOBResidueIter.klass, "begin_atoms", VALUEFUNC(_wrap_OBResidueIter_begin_atoms), -1);
  rb_define_method(cOBResidueIter.klass, "end_atoms", VALUEFUNC(_wrap_OBResidueIter_end_atoms), -1);
  rb_define_method(cOBResidueIter.klass, "begin_atom", VALUEFUNC(_wrap_OBResidueIter_begin_atom), -1);
  rb_define_method(cOBResidueIter.klass, "next_atom", VALUEFUNC(_wrap_OBResidueIter_next_atom), -1);
  rb_define_method(cOBResidueIter.klass, "do_transformations", VALUEFUNC(_wrap_OBResidueIter_do_transformations), -1);
  rb_define_method(cOBResidueIter.klass, "class_description", VALUEFUNC(_wrap_OBResidueIter_class_description), -1);
  rb_define_method(cOBResidueIter.klass, "has_data", VALUEFUNC(_wrap_OBResidueIter_has_data), -1);
  rb_define_method(cOBResidueIter.klass, "delete_data", VALUEFUNC(_wrap_OBResidueIter_delete_data), -1);
  rb_define_method(cOBResidueIter.klass, "set_data", VALUEFUNC(_wrap_OBResidueIter_set_data), -1);
  rb_define_method(cOBResidueIter.klass, "data_size", VALUEFUNC(_wrap_OBResidueIter_data_size), -1);
  rb_define_method(cOBResidueIter.klass, "get_data", VALUEFUNC(_wrap_OBResidueIter_get_data), -1);
  rb_define_method(cOBResidueIter.klass, "begin_data", VALUEFUNC(_wrap_OBResidueIter_begin_data), -1);
  rb_define_method(cOBResidueIter.klass, "end_data", VALUEFUNC(_wrap_OBResidueIter_end_data), -1);
  cOBResidueIter.mark = 0;
  cOBResidueIter.destroy = (void (*)(void *)) free_OpenBabel_OBResidueIter;
  cOBResidueIter.trackObjects = 0;
  
  cOBResidueAtomIter.klass = rb_define_class_under(mOpenbabel, "OBResidueAtomIter", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBResidueAtomIter, (void *) &cOBResidueAtomIter);
  rb_define_alloc_func(cOBResidueAtomIter.klass, _wrap_OBResidueAtomIter_allocate);
  rb_define_method(cOBResidueAtomIter.klass, "initialize", VALUEFUNC(_wrap_new_OBResidueAtomIter), -1);
  rb_define_method(cOBResidueAtomIter.klass, "good", VALUEFUNC(_wrap_OBResidueAtomIter_good), -1);
  rb_define_method(cOBResidueAtomIter.klass, "inc", VALUEFUNC(_wrap_OBResidueAtomIter_inc), -1);
  rb_define_method(cOBResidueAtomIter.klass, "deref", VALUEFUNC(_wrap_OBResidueAtomIter_deref), -1);
  rb_define_method(cOBResidueAtomIter.klass, "__ref__", VALUEFUNC(_wrap_OBResidueAtomIter___ref__), -1);
  rb_define_method(cOBResidueAtomIter.klass, "Visit=", VALUEFUNC(_wrap_OBResidueAtomIter_Visit_set), -1);
  rb_define_method(cOBResidueAtomIter.klass, "Visit", VALUEFUNC(_wrap_OBResidueAtomIter_Visit_get), -1);
  rb_define_method(cOBResidueAtomIter.klass, "clear", VALUEFUNC(_wrap_OBResidueAtomIter_clear), -1);
  rb_define_method(cOBResidueAtomIter.klass, "set_idx", VALUEFUNC(_wrap_OBResidueAtomIter_set_idx), -1);
  rb_define_method(cOBResidueAtomIter.klass, "set_hyb", VALUEFUNC(_wrap_OBResidueAtomIter_set_hyb), -1);
  rb_define_method(cOBResidueAtomIter.klass, "set_atomic_num", VALUEFUNC(_wrap_OBResidueAtomIter_set_atomic_num), -1);
  rb_define_method(cOBResidueAtomIter.klass, "set_isotope", VALUEFUNC(_wrap_OBResidueAtomIter_set_isotope), -1);
  rb_define_method(cOBResidueAtomIter.klass, "set_implicit_valence", VALUEFUNC(_wrap_OBResidueAtomIter_set_implicit_valence), -1);
  rb_define_method(cOBResidueAtomIter.klass, "increment_implicit_valence", VALUEFUNC(_wrap_OBResidueAtomIter_increment_implicit_valence), -1);
  rb_define_method(cOBResidueAtomIter.klass, "decrement_implicit_valence", VALUEFUNC(_wrap_OBResidueAtomIter_decrement_implicit_valence), -1);
  rb_define_method(cOBResidueAtomIter.klass, "set_formal_charge", VALUEFUNC(_wrap_OBResidueAtomIter_set_formal_charge), -1);
  rb_define_method(cOBResidueAtomIter.klass, "set_spin_multiplicity", VALUEFUNC(_wrap_OBResidueAtomIter_set_spin_multiplicity), -1);
  rb_define_method(cOBResidueAtomIter.klass, "set_type", VALUEFUNC(_wrap_OBResidueAtomIter_set_type), -1);
  rb_define_method(cOBResidueAtomIter.klass, "set_partial_charge", VALUEFUNC(_wrap_OBResidueAtomIter_set_partial_charge), -1);
  rb_define_method(cOBResidueAtomIter.klass, "set_vector", VALUEFUNC(_wrap_OBResidueAtomIter_set_vector), -1);
  rb_define_method(cOBResidueAtomIter.klass, "set_coord_ptr", VALUEFUNC(_wrap_OBResidueAtomIter_set_coord_ptr), -1);
  rb_define_method(cOBResidueAtomIter.klass, "set_residue", VALUEFUNC(_wrap_OBResidueAtomIter_set_residue), -1);
  rb_define_method(cOBResidueAtomIter.klass, "set_parent", VALUEFUNC(_wrap_OBResidueAtomIter_set_parent), -1);
  rb_define_method(cOBResidueAtomIter.klass, "set_aromatic", VALUEFUNC(_wrap_OBResidueAtomIter_set_aromatic), -1);
  rb_define_method(cOBResidueAtomIter.klass, "unset_aromatic", VALUEFUNC(_wrap_OBResidueAtomIter_unset_aromatic), -1);
  rb_define_method(cOBResidueAtomIter.klass, "set_clockwise_stereo", VALUEFUNC(_wrap_OBResidueAtomIter_set_clockwise_stereo), -1);
  rb_define_method(cOBResidueAtomIter.klass, "set_anti_clockwise_stereo", VALUEFUNC(_wrap_OBResidueAtomIter_set_anti_clockwise_stereo), -1);
  rb_define_method(cOBResidueAtomIter.klass, "set_positive_stereo", VALUEFUNC(_wrap_OBResidueAtomIter_set_positive_stereo), -1);
  rb_define_method(cOBResidueAtomIter.klass, "set_negative_stereo", VALUEFUNC(_wrap_OBResidueAtomIter_set_negative_stereo), -1);
  rb_define_method(cOBResidueAtomIter.klass, "unset_stereo", VALUEFUNC(_wrap_OBResidueAtomIter_unset_stereo), -1);
  rb_define_method(cOBResidueAtomIter.klass, "set_in_ring", VALUEFUNC(_wrap_OBResidueAtomIter_set_in_ring), -1);
  rb_define_method(cOBResidueAtomIter.klass, "set_chiral", VALUEFUNC(_wrap_OBResidueAtomIter_set_chiral), -1);
  rb_define_method(cOBResidueAtomIter.klass, "clear_coord_ptr", VALUEFUNC(_wrap_OBResidueAtomIter_clear_coord_ptr), -1);
  rb_define_method(cOBResidueAtomIter.klass, "get_formal_charge", VALUEFUNC(_wrap_OBResidueAtomIter_get_formal_charge), -1);
  rb_define_method(cOBResidueAtomIter.klass, "get_atomic_num", VALUEFUNC(_wrap_OBResidueAtomIter_get_atomic_num), -1);
  rb_define_method(cOBResidueAtomIter.klass, "get_isotope", VALUEFUNC(_wrap_OBResidueAtomIter_get_isotope), -1);
  rb_define_method(cOBResidueAtomIter.klass, "get_spin_multiplicity", VALUEFUNC(_wrap_OBResidueAtomIter_get_spin_multiplicity), -1);
  rb_define_method(cOBResidueAtomIter.klass, "get_atomic_mass", VALUEFUNC(_wrap_OBResidueAtomIter_get_atomic_mass), -1);
  rb_define_method(cOBResidueAtomIter.klass, "get_exact_mass", VALUEFUNC(_wrap_OBResidueAtomIter_get_exact_mass), -1);
  rb_define_method(cOBResidueAtomIter.klass, "get_idx", VALUEFUNC(_wrap_OBResidueAtomIter_get_idx), -1);
  rb_define_method(cOBResidueAtomIter.klass, "get_coordinate_idx", VALUEFUNC(_wrap_OBResidueAtomIter_get_coordinate_idx), -1);
  rb_define_method(cOBResidueAtomIter.klass, "get_cidx", VALUEFUNC(_wrap_OBResidueAtomIter_get_cidx), -1);
  rb_define_method(cOBResidueAtomIter.klass, "get_valence", VALUEFUNC(_wrap_OBResidueAtomIter_get_valence), -1);
  rb_define_method(cOBResidueAtomIter.klass, "get_hyb", VALUEFUNC(_wrap_OBResidueAtomIter_get_hyb), -1);
  rb_define_method(cOBResidueAtomIter.klass, "get_implicit_valence", VALUEFUNC(_wrap_OBResidueAtomIter_get_implicit_valence), -1);
  rb_define_method(cOBResidueAtomIter.klass, "get_hvy_valence", VALUEFUNC(_wrap_OBResidueAtomIter_get_hvy_valence), -1);
  rb_define_method(cOBResidueAtomIter.klass, "get_hetero_valence", VALUEFUNC(_wrap_OBResidueAtomIter_get_hetero_valence), -1);
  rb_define_method(cOBResidueAtomIter.klass, "get_type", VALUEFUNC(_wrap_OBResidueAtomIter_get_type), -1);
  rb_define_method(cOBResidueAtomIter.klass, "get_x", VALUEFUNC(_wrap_OBResidueAtomIter_get_x), -1);
  rb_define_method(cOBResidueAtomIter.klass, "get_y", VALUEFUNC(_wrap_OBResidueAtomIter_get_y), -1);
  rb_define_method(cOBResidueAtomIter.klass, "get_z", VALUEFUNC(_wrap_OBResidueAtomIter_get_z), -1);
  rb_define_method(cOBResidueAtomIter.klass, "x", VALUEFUNC(_wrap_OBResidueAtomIter_x), -1);
  rb_define_method(cOBResidueAtomIter.klass, "y", VALUEFUNC(_wrap_OBResidueAtomIter_y), -1);
  rb_define_method(cOBResidueAtomIter.klass, "z", VALUEFUNC(_wrap_OBResidueAtomIter_z), -1);
  rb_define_method(cOBResidueAtomIter.klass, "get_coordinate", VALUEFUNC(_wrap_OBResidueAtomIter_get_coordinate), -1);
  rb_define_method(cOBResidueAtomIter.klass, "get_vector", VALUEFUNC(_wrap_OBResidueAtomIter_get_vector), -1);
  rb_define_method(cOBResidueAtomIter.klass, "get_partial_charge", VALUEFUNC(_wrap_OBResidueAtomIter_get_partial_charge), -1);
  rb_define_method(cOBResidueAtomIter.klass, "get_residue", VALUEFUNC(_wrap_OBResidueAtomIter_get_residue), -1);
  rb_define_method(cOBResidueAtomIter.klass, "get_parent", VALUEFUNC(_wrap_OBResidueAtomIter_get_parent), -1);
  rb_define_method(cOBResidueAtomIter.klass, "get_new_bond_vector", VALUEFUNC(_wrap_OBResidueAtomIter_get_new_bond_vector), -1);
  rb_define_method(cOBResidueAtomIter.klass, "get_bond", VALUEFUNC(_wrap_OBResidueAtomIter_get_bond), -1);
  rb_define_method(cOBResidueAtomIter.klass, "get_next_atom", VALUEFUNC(_wrap_OBResidueAtomIter_get_next_atom), -1);
  rb_define_method(cOBResidueAtomIter.klass, "begin_bonds", VALUEFUNC(_wrap_OBResidueAtomIter_begin_bonds), -1);
  rb_define_method(cOBResidueAtomIter.klass, "end_bonds", VALUEFUNC(_wrap_OBResidueAtomIter_end_bonds), -1);
  rb_define_method(cOBResidueAtomIter.klass, "begin_bond", VALUEFUNC(_wrap_OBResidueAtomIter_begin_bond), -1);
  rb_define_method(cOBResidueAtomIter.klass, "next_bond", VALUEFUNC(_wrap_OBResidueAtomIter_next_bond), -1);
  rb_define_method(cOBResidueAtomIter.klass, "begin_nbr_atom", VALUEFUNC(_wrap_OBResidueAtomIter_begin_nbr_atom), -1);
  rb_define_method(cOBResidueAtomIter.klass, "next_nbr_atom", VALUEFUNC(_wrap_OBResidueAtomIter_next_nbr_atom), -1);
  rb_define_method(cOBResidueAtomIter.klass, "get_distance", VALUEFUNC(_wrap_OBResidueAtomIter_get_distance), -1);
  rb_define_method(cOBResidueAtomIter.klass, "get_angle", VALUEFUNC(_wrap_OBResidueAtomIter_get_angle), -1);
  rb_define_method(cOBResidueAtomIter.klass, "new_residue", VALUEFUNC(_wrap_OBResidueAtomIter_new_residue), -1);
  rb_define_method(cOBResidueAtomIter.klass, "add_residue", VALUEFUNC(_wrap_OBResidueAtomIter_add_residue), -1);
  rb_define_method(cOBResidueAtomIter.klass, "delete_residue", VALUEFUNC(_wrap_OBResidueAtomIter_delete_residue), -1);
  rb_define_method(cOBResidueAtomIter.klass, "add_bond", VALUEFUNC(_wrap_OBResidueAtomIter_add_bond), -1);
  rb_define_method(cOBResidueAtomIter.klass, "insert_bond", VALUEFUNC(_wrap_OBResidueAtomIter_insert_bond), -1);
  rb_define_method(cOBResidueAtomIter.klass, "delete_bond", VALUEFUNC(_wrap_OBResidueAtomIter_delete_bond), -1);
  rb_define_method(cOBResidueAtomIter.klass, "clear_bond", VALUEFUNC(_wrap_OBResidueAtomIter_clear_bond), -1);
  rb_define_method(cOBResidueAtomIter.klass, "hto_methyl", VALUEFUNC(_wrap_OBResidueAtomIter_hto_methyl), -1);
  rb_define_method(cOBResidueAtomIter.klass, "set_hyb_and_geom", VALUEFUNC(_wrap_OBResidueAtomIter_set_hyb_and_geom), -1);
  rb_define_method(cOBResidueAtomIter.klass, "force_no_h", VALUEFUNC(_wrap_OBResidueAtomIter_force_no_h), -1);
  rb_define_method(cOBResidueAtomIter.klass, "has_no_hforced", VALUEFUNC(_wrap_OBResidueAtomIter_has_no_hforced), -1);
  rb_define_method(cOBResidueAtomIter.klass, "count_free_oxygens", VALUEFUNC(_wrap_OBResidueAtomIter_count_free_oxygens), -1);
  rb_define_method(cOBResidueAtomIter.klass, "implicit_hydrogen_count", VALUEFUNC(_wrap_OBResidueAtomIter_implicit_hydrogen_count), -1);
  rb_define_method(cOBResidueAtomIter.klass, "explicit_hydrogen_count", VALUEFUNC(_wrap_OBResidueAtomIter_explicit_hydrogen_count), -1);
  rb_define_method(cOBResidueAtomIter.klass, "member_of_ring_count", VALUEFUNC(_wrap_OBResidueAtomIter_member_of_ring_count), -1);
  rb_define_method(cOBResidueAtomIter.klass, "member_of_ring_size", VALUEFUNC(_wrap_OBResidueAtomIter_member_of_ring_size), -1);
  rb_define_method(cOBResidueAtomIter.klass, "count_ring_bonds", VALUEFUNC(_wrap_OBResidueAtomIter_count_ring_bonds), -1);
  rb_define_method(cOBResidueAtomIter.klass, "smallest_bond_angle", VALUEFUNC(_wrap_OBResidueAtomIter_smallest_bond_angle), -1);
  rb_define_method(cOBResidueAtomIter.klass, "average_bond_angle", VALUEFUNC(_wrap_OBResidueAtomIter_average_bond_angle), -1);
  rb_define_method(cOBResidueAtomIter.klass, "bosum", VALUEFUNC(_wrap_OBResidueAtomIter_bosum), -1);
  rb_define_method(cOBResidueAtomIter.klass, "kbosum", VALUEFUNC(_wrap_OBResidueAtomIter_kbosum), -1);
  rb_define_method(cOBResidueAtomIter.klass, "has_residue", VALUEFUNC(_wrap_OBResidueAtomIter_has_residue), -1);
  rb_define_method(cOBResidueAtomIter.klass, "is_hydrogen", VALUEFUNC(_wrap_OBResidueAtomIter_is_hydrogen), -1);
  rb_define_method(cOBResidueAtomIter.klass, "is_carbon", VALUEFUNC(_wrap_OBResidueAtomIter_is_carbon), -1);
  rb_define_method(cOBResidueAtomIter.klass, "is_nitrogen", VALUEFUNC(_wrap_OBResidueAtomIter_is_nitrogen), -1);
  rb_define_method(cOBResidueAtomIter.klass, "is_oxygen", VALUEFUNC(_wrap_OBResidueAtomIter_is_oxygen), -1);
  rb_define_method(cOBResidueAtomIter.klass, "is_sulfur", VALUEFUNC(_wrap_OBResidueAtomIter_is_sulfur), -1);
  rb_define_method(cOBResidueAtomIter.klass, "is_phosphorus", VALUEFUNC(_wrap_OBResidueAtomIter_is_phosphorus), -1);
  rb_define_method(cOBResidueAtomIter.klass, "is_aromatic", VALUEFUNC(_wrap_OBResidueAtomIter_is_aromatic), -1);
  rb_define_method(cOBResidueAtomIter.klass, "is_in_ring", VALUEFUNC(_wrap_OBResidueAtomIter_is_in_ring), -1);
  rb_define_method(cOBResidueAtomIter.klass, "is_in_ring_size", VALUEFUNC(_wrap_OBResidueAtomIter_is_in_ring_size), -1);
  rb_define_method(cOBResidueAtomIter.klass, "is_heteroatom", VALUEFUNC(_wrap_OBResidueAtomIter_is_heteroatom), -1);
  rb_define_method(cOBResidueAtomIter.klass, "is_not_cor_h", VALUEFUNC(_wrap_OBResidueAtomIter_is_not_cor_h), -1);
  rb_define_method(cOBResidueAtomIter.klass, "is_connected", VALUEFUNC(_wrap_OBResidueAtomIter_is_connected), -1);
  rb_define_method(cOBResidueAtomIter.klass, "is_one_three", VALUEFUNC(_wrap_OBResidueAtomIter_is_one_three), -1);
  rb_define_method(cOBResidueAtomIter.klass, "is_one_four", VALUEFUNC(_wrap_OBResidueAtomIter_is_one_four), -1);
  rb_define_method(cOBResidueAtomIter.klass, "is_carboxyl_oxygen", VALUEFUNC(_wrap_OBResidueAtomIter_is_carboxyl_oxygen), -1);
  rb_define_method(cOBResidueAtomIter.klass, "is_phosphate_oxygen", VALUEFUNC(_wrap_OBResidueAtomIter_is_phosphate_oxygen), -1);
  rb_define_method(cOBResidueAtomIter.klass, "is_sulfate_oxygen", VALUEFUNC(_wrap_OBResidueAtomIter_is_sulfate_oxygen), -1);
  rb_define_method(cOBResidueAtomIter.klass, "is_nitro_oxygen", VALUEFUNC(_wrap_OBResidueAtomIter_is_nitro_oxygen), -1);
  rb_define_method(cOBResidueAtomIter.klass, "is_amide_nitrogen", VALUEFUNC(_wrap_OBResidueAtomIter_is_amide_nitrogen), -1);
  rb_define_method(cOBResidueAtomIter.klass, "is_polar_hydrogen", VALUEFUNC(_wrap_OBResidueAtomIter_is_polar_hydrogen), -1);
  rb_define_method(cOBResidueAtomIter.klass, "is_non_polar_hydrogen", VALUEFUNC(_wrap_OBResidueAtomIter_is_non_polar_hydrogen), -1);
  rb_define_method(cOBResidueAtomIter.klass, "is_aromatic_noxide", VALUEFUNC(_wrap_OBResidueAtomIter_is_aromatic_noxide), -1);
  rb_define_method(cOBResidueAtomIter.klass, "is_chiral", VALUEFUNC(_wrap_OBResidueAtomIter_is_chiral), -1);
  rb_define_method(cOBResidueAtomIter.klass, "is_axial", VALUEFUNC(_wrap_OBResidueAtomIter_is_axial), -1);
  rb_define_method(cOBResidueAtomIter.klass, "is_clockwise", VALUEFUNC(_wrap_OBResidueAtomIter_is_clockwise), -1);
  rb_define_method(cOBResidueAtomIter.klass, "is_anti_clockwise", VALUEFUNC(_wrap_OBResidueAtomIter_is_anti_clockwise), -1);
  rb_define_method(cOBResidueAtomIter.klass, "is_positive_stereo", VALUEFUNC(_wrap_OBResidueAtomIter_is_positive_stereo), -1);
  rb_define_method(cOBResidueAtomIter.klass, "is_negative_stereo", VALUEFUNC(_wrap_OBResidueAtomIter_is_negative_stereo), -1);
  rb_define_method(cOBResidueAtomIter.klass, "has_chirality_specified", VALUEFUNC(_wrap_OBResidueAtomIter_has_chirality_specified), -1);
  rb_define_method(cOBResidueAtomIter.klass, "has_chiral_volume", VALUEFUNC(_wrap_OBResidueAtomIter_has_chiral_volume), -1);
  rb_define_method(cOBResidueAtomIter.klass, "is_hbond_acceptor", VALUEFUNC(_wrap_OBResidueAtomIter_is_hbond_acceptor), -1);
  rb_define_method(cOBResidueAtomIter.klass, "is_hbond_donor", VALUEFUNC(_wrap_OBResidueAtomIter_is_hbond_donor), -1);
  rb_define_method(cOBResidueAtomIter.klass, "is_hbond_donor_h", VALUEFUNC(_wrap_OBResidueAtomIter_is_hbond_donor_h), -1);
  rb_define_method(cOBResidueAtomIter.klass, "has_alpha_beta_unsat", VALUEFUNC(_wrap_OBResidueAtomIter_has_alpha_beta_unsat), -1);
  rb_define_method(cOBResidueAtomIter.klass, "has_bond_of_order", VALUEFUNC(_wrap_OBResidueAtomIter_has_bond_of_order), -1);
  rb_define_method(cOBResidueAtomIter.klass, "count_bonds_of_order", VALUEFUNC(_wrap_OBResidueAtomIter_count_bonds_of_order), -1);
  rb_define_method(cOBResidueAtomIter.klass, "has_non_single_bond", VALUEFUNC(_wrap_OBResidueAtomIter_has_non_single_bond), -1);
  rb_define_method(cOBResidueAtomIter.klass, "has_single_bond", VALUEFUNC(_wrap_OBResidueAtomIter_has_single_bond), -1);
  rb_define_method(cOBResidueAtomIter.klass, "has_double_bond", VALUEFUNC(_wrap_OBResidueAtomIter_has_double_bond), -1);
  rb_define_method(cOBResidueAtomIter.klass, "has_aromatic_bond", VALUEFUNC(_wrap_OBResidueAtomIter_has_aromatic_bond), -1);
  rb_define_method(cOBResidueAtomIter.klass, "matches_smarts", VALUEFUNC(_wrap_OBResidueAtomIter_matches_smarts), -1);
  rb_define_method(cOBResidueAtomIter.klass, "do_transformations", VALUEFUNC(_wrap_OBResidueAtomIter_do_transformations), -1);
  rb_define_method(cOBResidueAtomIter.klass, "class_description", VALUEFUNC(_wrap_OBResidueAtomIter_class_description), -1);
  rb_define_method(cOBResidueAtomIter.klass, "has_data", VALUEFUNC(_wrap_OBResidueAtomIter_has_data), -1);
  rb_define_method(cOBResidueAtomIter.klass, "delete_data", VALUEFUNC(_wrap_OBResidueAtomIter_delete_data), -1);
  rb_define_method(cOBResidueAtomIter.klass, "set_data", VALUEFUNC(_wrap_OBResidueAtomIter_set_data), -1);
  rb_define_method(cOBResidueAtomIter.klass, "data_size", VALUEFUNC(_wrap_OBResidueAtomIter_data_size), -1);
  rb_define_method(cOBResidueAtomIter.klass, "get_data", VALUEFUNC(_wrap_OBResidueAtomIter_get_data), -1);
  rb_define_method(cOBResidueAtomIter.klass, "begin_data", VALUEFUNC(_wrap_OBResidueAtomIter_begin_data), -1);
  rb_define_method(cOBResidueAtomIter.klass, "end_data", VALUEFUNC(_wrap_OBResidueAtomIter_end_data), -1);
  cOBResidueAtomIter.mark = 0;
  cOBResidueAtomIter.destroy = (void (*)(void *)) free_OpenBabel_OBResidueAtomIter;
  cOBResidueAtomIter.trackObjects = 0;
  
  cOBMolAngleIter.klass = rb_define_class_under(mOpenbabel, "OBMolAngleIter", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBMolAngleIter, (void *) &cOBMolAngleIter);
  rb_define_alloc_func(cOBMolAngleIter.klass, _wrap_OBMolAngleIter_allocate);
  rb_define_method(cOBMolAngleIter.klass, "initialize", VALUEFUNC(_wrap_new_OBMolAngleIter), -1);
  rb_define_method(cOBMolAngleIter.klass, "good", VALUEFUNC(_wrap_OBMolAngleIter_good), -1);
  rb_define_method(cOBMolAngleIter.klass, "inc", VALUEFUNC(_wrap_OBMolAngleIter_inc), -1);
  rb_define_method(cOBMolAngleIter.klass, "__ref__", VALUEFUNC(_wrap_OBMolAngleIter___ref__), -1);
  cOBMolAngleIter.mark = 0;
  cOBMolAngleIter.destroy = (void (*)(void *)) free_OpenBabel_OBMolAngleIter;
  cOBMolAngleIter.trackObjects = 0;
  
  cOBMolTorsionIter.klass = rb_define_class_under(mOpenbabel, "OBMolTorsionIter", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBMolTorsionIter, (void *) &cOBMolTorsionIter);
  rb_define_alloc_func(cOBMolTorsionIter.klass, _wrap_OBMolTorsionIter_allocate);
  rb_define_method(cOBMolTorsionIter.klass, "initialize", VALUEFUNC(_wrap_new_OBMolTorsionIter), -1);
  rb_define_method(cOBMolTorsionIter.klass, "good", VALUEFUNC(_wrap_OBMolTorsionIter_good), -1);
  rb_define_method(cOBMolTorsionIter.klass, "inc", VALUEFUNC(_wrap_OBMolTorsionIter_inc), -1);
  rb_define_method(cOBMolTorsionIter.klass, "__ref__", VALUEFUNC(_wrap_OBMolTorsionIter___ref__), -1);
  cOBMolTorsionIter.mark = 0;
  cOBMolTorsionIter.destroy = (void (*)(void *)) free_OpenBabel_OBMolTorsionIter;
  cOBMolTorsionIter.trackObjects = 0;
  
  cOBMolPairIter.klass = rb_define_class_under(mOpenbabel, "OBMolPairIter", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBMolPairIter, (void *) &cOBMolPairIter);
  rb_define_alloc_func(cOBMolPairIter.klass, _wrap_OBMolPairIter_allocate);
  rb_define_method(cOBMolPairIter.klass, "initialize", VALUEFUNC(_wrap_new_OBMolPairIter), -1);
  rb_define_method(cOBMolPairIter.klass, "good", VALUEFUNC(_wrap_OBMolPairIter_good), -1);
  rb_define_method(cOBMolPairIter.klass, "inc", VALUEFUNC(_wrap_OBMolPairIter_inc), -1);
  rb_define_method(cOBMolPairIter.klass, "__ref__", VALUEFUNC(_wrap_OBMolPairIter___ref__), -1);
  cOBMolPairIter.mark = 0;
  cOBMolPairIter.destroy = (void (*)(void *)) free_OpenBabel_OBMolPairIter;
  cOBMolPairIter.trackObjects = 0;
  
  cOBMolRingIter.klass = rb_define_class_under(mOpenbabel, "OBMolRingIter", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBMolRingIter, (void *) &cOBMolRingIter);
  rb_define_alloc_func(cOBMolRingIter.klass, _wrap_OBMolRingIter_allocate);
  rb_define_method(cOBMolRingIter.klass, "initialize", VALUEFUNC(_wrap_new_OBMolRingIter), -1);
  rb_define_method(cOBMolRingIter.klass, "good", VALUEFUNC(_wrap_OBMolRingIter_good), -1);
  rb_define_method(cOBMolRingIter.klass, "inc", VALUEFUNC(_wrap_OBMolRingIter_inc), -1);
  rb_define_method(cOBMolRingIter.klass, "deref", VALUEFUNC(_wrap_OBMolRingIter_deref), -1);
  rb_define_method(cOBMolRingIter.klass, "__ref__", VALUEFUNC(_wrap_OBMolRingIter___ref__), -1);
  rb_define_method(cOBMolRingIter.klass, "_path=", VALUEFUNC(_wrap_OBMolRingIter__path_set), -1);
  rb_define_method(cOBMolRingIter.klass, "_path", VALUEFUNC(_wrap_OBMolRingIter__path_get), -1);
  rb_define_method(cOBMolRingIter.klass, "_pathset=", VALUEFUNC(_wrap_OBMolRingIter__pathset_set), -1);
  rb_define_method(cOBMolRingIter.klass, "_pathset", VALUEFUNC(_wrap_OBMolRingIter__pathset_get), -1);
  rb_define_method(cOBMolRingIter.klass, "size", VALUEFUNC(_wrap_OBMolRingIter_size), -1);
  rb_define_method(cOBMolRingIter.klass, "path_size", VALUEFUNC(_wrap_OBMolRingIter_path_size), -1);
  rb_define_method(cOBMolRingIter.klass, "is_aromatic", VALUEFUNC(_wrap_OBMolRingIter_is_aromatic), -1);
  rb_define_method(cOBMolRingIter.klass, "is_member", VALUEFUNC(_wrap_OBMolRingIter_is_member), -1);
  rb_define_method(cOBMolRingIter.klass, "is_in_ring", VALUEFUNC(_wrap_OBMolRingIter_is_in_ring), -1);
  rb_define_method(cOBMolRingIter.klass, "set_parent", VALUEFUNC(_wrap_OBMolRingIter_set_parent), -1);
  rb_define_method(cOBMolRingIter.klass, "get_parent", VALUEFUNC(_wrap_OBMolRingIter_get_parent), -1);
  rb_define_method(cOBMolRingIter.klass, "find_center_and_normal", VALUEFUNC(_wrap_OBMolRingIter_find_center_and_normal), -1);
  cOBMolRingIter.mark = 0;
  cOBMolRingIter.destroy = (void (*)(void *)) free_OpenBabel_OBMolRingIter;
  cOBMolRingIter.trackObjects = 0;
}

